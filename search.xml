<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ARM-Trusted-Firmware 学习</title>
      <link href="/posts/56859/"/>
      <url>/posts/56859/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在 ARMv8 之后，Uboot 在启动前需要先进行 ATF 的初始化，为了充分了解启动过程，对 ATF 进行了一波学习，总结在此篇文章中。</p><h1 id="ATF-概念"><a href="#ATF-概念" class="headerlink" title="ATF 概念"></a>ATF 概念</h1><p>安全是操作系统领域这些年经常提到的话题，TF（Trusted Firmware）是 ARM 为了提升安全在 ARMv8 引入的安全解决方案，其包括了启动和运行过程中的特权级划分。由于 TF 是 ARM 引入，所以也叫 ATF，其实现上有两种 Profile，对 arm-a 系列的 TF-A，对 arm-m 系列的 TF-M，由于 a 系列使用较多的原因经常不区分 ATF 和 TF-A。</p><p>其作用是细化了特权级，帮助进行安全侧与非安全侧的切换，如下图所示，EL3 即为 ATF 的一部分。</p><p><img src="ELn.png" alt="ELn.png"></p><p>在实现上，EL0 和 EL1 是 ATF 必须实现的，EL2 和 EL3 可选。EL0-EL2 每一个层次又可以分为安全和非安全两部分，EL3 只有安全模式一种。</p><p>ATF 的作用是建立一套从启动到执行的信任链，借此提高 ARM 架构的安全性。</p><h1 id="ATF-功能"><a href="#ATF-功能" class="headerlink" title="ATF 功能"></a>ATF 功能</h1><p>过去的 ATF 只是为了电源管理，以及 Trust_zone 的切换，现在随着技术的不断发展，功能愈发庞大，现如今 ATF 的重要功能有：</p><ol><li>安全世界的初始化（BL32）</li><li>CPU rest</li><li>系统设备的驱动，例如 GIC</li><li>SMC 处理。</li><li>PSCI 库的支持。</li><li>Secure monitor 代码。</li><li>Secure Boot 实现</li></ol><h1 id="ATF-启动流程"><a href="#ATF-启动流程" class="headerlink" title="ATF 启动流程"></a>ATF 启动流程</h1><p><img src="ATF启动流程.png" alt="ATF启动流程.png"></p><p>其整体流程如上，接下来逐个说明。</p><h2 id="BL1"><a href="#BL1" class="headerlink" title="BL1"></a>BL1</h2><p>BL1,又名 Trusted Boot ROM,是放在 ROM 中的一段程序，是信任链建立的信任根，其目的是建立 Trusted SRAM（为运行 C 程序作堆栈准备），异常向量表，初始化 Console。找到并验证 BL2（验 CSF 头），然后汇编跳转到 BL2。</p><h2 id="BL2"><a href="#BL2" class="headerlink" title="BL2"></a>BL2</h2><p>BL2，又名 Trusted Boot FIrmware，其运行在 Flash 中，可信建立在 BL1 对其的验证上。其完成很多硬件的初始化。</p><p>其负责加载所有 BL3n 的 Images，例如 BL31,BL32,BL33。</p><p>最后会验证 BL31，然后跳转到 BL31。</p><p>但如何跳转是不同于 BL1 的，这里区分了 BL2 是否在 EL3 运行，如果在 EL3 运行，则由 BL2 跳转 BL31，如果不是，则 BL2 将会发起 SMC 中断，其由 BL1 异常向量表接收后进行汇编跳转。</p><p>也由此，我们可以明确 GIC 初始化大概率在 BL2 完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#if !BL2_RUNS_AT_EL3</span><br><span class="line">...</span><br><span class="line">smc(BL1_SMC_RUN_IMAGE, (unsigned long)next_bl_ep_info, 0, 0, 0, 0, 0, 0);</span><br><span class="line">...</span><br><span class="line">#else</span><br><span class="line">bl2_run_next_image(next_bl_ep_info);</span><br></pre></td></tr></table></figure><h2 id="BL31"><a href="#BL31" class="headerlink" title="BL31"></a>BL31</h2><p>BL31，又名 EL3 Runtime Firmware，其区别于 BL1 和 BL2 的一次性运行，其运行后将持续服务在 EL3，办法自通过 SMC 为 Non-Secure 提供服务。</p><p>其会初始化所有服务，如果初始化的服务中有 BL32 相关，则会验证并跳转到 BL32 初始化 TEE OS。最后在由 TEE OS 恢复 CPU 到 BL31，让其验证并进行 BL33 的初始化，由于 BL32 是可选的，所以如果没有实现 BL32，BL31 会转而立刻验证并进行 BL33 的初始化。</p><h2 id="BL32"><a href="#BL32" class="headerlink" title="BL32"></a>BL32</h2><p>BL32，其实是 Open Protable Trusted Execution Enveironment OS + APP,该 OS 运行在 SEL-1,其上的安全程序运行在 SEL-0。TEE OS 运行完毕后，会通过 SMC 中断，返回到 BL31。</p><h2 id="BL33"><a href="#BL33" class="headerlink" title="BL33"></a>BL33</h2><p>BL33，又名 Non-Trusted Firmware，其实就是 Uboot 或者 UEFI firmware。之后的信任由这些 Bootloader 完成。例如 UEFI SECURE BOOT。</p><p>到了 BL33，就和正常的启动差不多了，通过 Uboot 或者 UEFI 加载操作系统镜像进来启动。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>下图给出了 ATF 更多的细节：</p><p><img src="ATF功能细节.png" alt="ATF功能细节.png"></p><p>正因为这样的 Firmware 的引入，我们需要在编译 ATF 前就要指定好系统硬件，例如 GIC 的版本等等，否则启动将会遇到问题。</p><h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><p><a href="https://github.com/bao-project/bao-demos/tree/master/platforms/qemu-aarch64-virt">Bao-demo</a> 为上述提供了一种 QEMU 的验证方法，其可以编译出一个 ATF + Uboot 的 Flash.bin 文件在 QEMU 中执行。</p><p>下图是笔者尝试使用 GICV2 架构后的结果：</p><p><img src="验证.png" alt="验证.png"></p><p>QEMU 启动命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-aarch64 -machine virt,secure=on,gic-version=2,virtualization=on -cpu cortex-a53 -smp 4 -m 2G -nographic -bios flash.bin</span><br></pre></td></tr></table></figure><p>根据信息可以看出，启动流程和上文所述相同，BL1 启动 BL2，BL2 发送 SMC 让 BL1 启动 BL31，由于 BL32 没有实现，所以BL31 启动了 BL33，即 Uboot。</p><h1 id="UltraScale-的启动"><a href="#UltraScale-的启动" class="headerlink" title="UltraScale+ 的启动"></a>UltraScale+ 的启动</h1><p><img src="Ultrascale+.png" alt="Ultrascale+.png"></p><p>和一般嵌入式开发板不同，启动顺序是</p><p>BOOTROM—&gt;FSBL—&gt;ATF—&gt;optee—&gt;uboot-&gt;linux, FSBL 已经将所有镜像加载到内存。</p><p>因此，无需进行 BL1,BL2 加载镜像的过程，直接从 BL31 开始启动。</p><p>这也就是为什么，在制作 UltraScale+ 板子的启动镜像时，没有 BL1 和 BL2 的原因。</p><p><img src="OnlyBL31.png" alt="OnlyBL31.png"></p>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ATF Uboot Linux 交叉编译命令留档</title>
      <link href="/posts/39082/"/>
      <url>/posts/39082/</url>
      
        <content type="html"><![CDATA[<h1 id="交叉工具链配置"><a href="#交叉工具链配置" class="headerlink" title="交叉工具链配置"></a>交叉工具链配置</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载需要的交叉编译链</span><br><span class="line"># 解压到目录</span><br><span class="line"># 加入环境变量 /etc/profile</span><br><span class="line">eg: export PATH=$PATH:/home/hangqi-ren/tools/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin:/home/hangqi-ren/qemu/qemu-7.2.12/build</span><br></pre></td></tr></table></figure><h1 id="Uboot-编译"><a href="#Uboot-编译" class="headerlink" title="Uboot 编译"></a>Uboot 编译</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 拉取 2022.10 版本的 Uboot 且只拉取最新的 Commit.</span><br><span class="line">git clone https://github.com/u-boot/u-boot.git --depth 1\</span><br><span class="line">   --branch v2022.10</span><br><span class="line"># 生成 .config 文件</span><br><span class="line">make qemu_arm64_defconfig</span><br><span class="line"># 交叉编译</span><br><span class="line">make -j$(nproc) CROSS_COMPILE=aarch64-none-linux-gnu-</span><br></pre></td></tr></table></figure><h1 id="Linux-编译"><a href="#Linux-编译" class="headerlink" title="Linux 编译"></a>Linux 编译</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 官网下载 Linux 任意版本源码</span><br><span class="line">https://cdn.kernel.org</span><br><span class="line"># 配置 .config 自行配置：</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- menuconfig</span><br><span class="line"># 配置 .config 采用现有配置：</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- /(defconfig)</span><br><span class="line"># 编译</span><br><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j6</span><br></pre></td></tr></table></figure><h1 id="ATF-编译"><a href="#ATF-编译" class="headerlink" title="ATF 编译"></a>ATF 编译</h1><p>由于 BL33 本质是 Uboot / Uefi 等 bootloader，所以需要提供编好的 bootloader 作为输入。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编译</span><br><span class="line">make PLAT=qemu bl1 fip BL33=u-boot.bin   QEMU_USE_GIC_DRIVER=QEMU_GICV2</span><br><span class="line"># 打包</span><br><span class="line">dd if=bl1.bin   of=flash.bin</span><br><span class="line">dd if=fip.bin   of=flash.bin seek=64 bs=4096 conv=notrunc</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Unix-Linux-系统学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM-Gicv2 第四章学习</title>
      <link href="/posts/57122/"/>
      <url>/posts/57122/</url>
      
        <content type="html"><![CDATA[<p>第四章标题是编程模型</p><p>该章主要介绍了寄存器位置、每个寄存器的详细用法。建议当工具章进行查阅使用，所以未进行深入学习，这里放一个 GICV2 文档链接。</p><p><a href="https://bhpan.buaa.edu.cn/link/AA1ADE7AD026F640199D8ECD8F5E9551B1">Gicv2-Spec</a></p>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM-Gicv2 第三章学习</title>
      <link href="/posts/51163/"/>
      <url>/posts/51163/</url>
      
        <content type="html"><![CDATA[<h1 id="多核处理不同中断"><a href="#多核处理不同中断" class="headerlink" title="多核处理不同中断"></a>多核处理不同中断</h1><ul><li>SGI：N-N 模型。</li><li>外设中断：1-N 模型。<h1 id="识别支持的中断"><a href="#识别支持的中断" class="headerlink" title="识别支持的中断"></a>识别支持的中断</h1><h2 id="GICD-ISENABLERn"><a href="#GICD-ISENABLERn" class="headerlink" title="GICD_ISENABLERn"></a>GICD_ISENABLERn</h2>访问 GICD_ISENABLERn，来了解 GIC 目前支持那些中断，GICD_ISENABLER0[15:0] 对应 SGI 0-15，GICD_ISENABLER0[31:16] 对应 PPI 16-31。以此类推 GICD_ISENABLE1[31:0] 对应 SPI 32 - 63。</li></ul><p>对于一个中断，如果不被支持，则对应的寄存器位读为0且写无效；如果支持且永久启用，对应的寄存器读为1且写无效，其余的读写规则：</p><p><img src="GICD_ISENABLERn.png" alt="GICD_ISENABLERn.png"></p><h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><ol><li>访问 GICD_TYPER.ITLinesNumber 揭示有多少数量的 GICD_ISENABLER。</li><li>写 GICD_CTLR 来禁用分发器分发中断</li><li>对于每个 GICD_ISENABLER 的位对应的中断，利用不支持则写无效原则，写 0xffffffff 给寄存器，再次读寄存器，读出 1 则可知道支持的中断号。</li></ol><h1 id="识别永久启用的中断"><a href="#识别永久启用的中断" class="headerlink" title="识别永久启用的中断"></a>识别永久启用的中断</h1><h2 id="GICD-ICENABLERn"><a href="#GICD-ICENABLERn" class="headerlink" title="GICD_ICENABLERn"></a>GICD_ICENABLERn</h2><p>访问 GICD_ICENABLERn，来了解 GIC 目前关闭哪些中断，其是 GICD_ISENABLER 的反寄存器。</p><p>写规则如下：</p><p><img src="GICD_ICENABLER.png" alt="GICD_ICENABLER.png"></p><h2 id="GICD-IGROUPRn"><a href="#GICD-IGROUPRn" class="headerlink" title="GICD_IGROUPRn"></a>GICD_IGROUPRn</h2><p>访问 GICD_IGROUPRn，来了解 GIC 中断分组情况，结构和前面类似，每一位确定一个中断号的分组。</p><blockquote><p>控制某一分组是否进行路由是在 GICD_CTLR.EnableGrp0，GICD_CTLR.EnableGrp1 位进行的。</p></blockquote><h2 id="操作方法-1"><a href="#操作方法-1" class="headerlink" title="操作方法"></a>操作方法</h2><ol><li>访问 GICD_TYPER.ITLinesNumber 揭示有多少数量的 GICD_ICENABLER（和GICD_ISENABLER数量一致）。</li><li>对于每个 GICD_ICENABLER 的位对应的中断，写 0xffffffff 给寄存器，再次读寄存器，读出 1 则可知道永久启用的中断。</li><li>给 GICD_ISENABLER 写 1 来恢复必要的中断。</li></ol><blockquote><p>GICD_ISENABLER 写 0 无效，即不能通过 ISENABLER 禁用某一中断号。<br>GICD_ICENABLER 写 0 无效，即不能通过 ICENABLER 启用某一中断号。</p></blockquote><h1 id="中断处理流程"><a href="#中断处理流程" class="headerlink" title="中断处理流程"></a>中断处理流程</h1><ol><li>一个中断发起后，GIC 确认该中断是否启用，不启用的中断将被无效。</li><li>对于每个启用的且正在等待被处理的中断，分发器决定目标CPU。</li><li>对于每个CPU，分发器确定最高优先级的等待中断，然后将此中断路由给目标CPU接口。</li><li>如果一个分发器将中断分配到CPU接口，该CPU接口将确认该中断优先级是否足够有效以至于向CPU提出中断请求。</li><li>当 CPU 处理此中断请求，其访问 GICC_IAR 来确认此中断，这次访问将返回中断号，而且如果是 SGI 中断，也会返回源 CPUID。</li><li>当 GIC 识别到 5 中的访问时，GIC 会更改中断的状态以如下规则：<ul><li>如果中断的等待状态不可变或者中断再次产生，更改为等待并活跃状态。</li><li>否则，更改为活跃状态。</li></ul></li></ol><blockquote><p>一个等待状态不可变的例子是对于电平触发的中断，CPU 的确认行为并不会使电平回归低位，只有 CPU 处理程序处理中断后才会回归低位。</p></blockquote><ol><li>当 CPU 处理完中断后，其必须向 GIC 表明中断处理完成，通过：<ul><li>总是向 EOIR 寄存器写</li><li>可能会向 GICC_DIR 写</li></ul></li></ol><blockquote><p>对于 CPU 接口来说，GIC 要求向 EOIR 写的顺序是向 GICC_IAR 读的反顺序，确保每次的 EOIR 对应最近的中断确认。<br>其次，CPU接口永远不会对处于等待并活跃的中断向 CPU 发出中断请求。</p></blockquote><blockquote><p>对于 PPI 和 SGI 中断，每个中断号的状态是 banking 的，这意味着如果一个中断在某一CPU接口是活跃或者等待并活跃的，只有该CPU接口不会再次向CPU提出相同的中断请求。<br>对于 SPI 中断，每个中断号的状态是统一的，这意味着如果一个中断号是活跃或者等待并活跃的，那么所有 CPU 接口都不会提出相同的中断请求。</p></blockquote><h1 id="优先级降低和中断关闭"><a href="#优先级降低和中断关闭" class="headerlink" title="优先级降低和中断关闭"></a>优先级降低和中断关闭</h1><h2 id="优先级降低"><a href="#优先级降低" class="headerlink" title="优先级降低"></a>优先级降低</h2><p>优先级降低发生在一个对 EOIR 寄存器的有效写上，此时优先级从此次写 EOIR 对应的中断优先级降低到还没有写 EOIR 寄存器的最高优先级活跃中断，如果没有这样的中断，降低到 Idle 优先级。</p><h2 id="中断关闭"><a href="#中断关闭" class="headerlink" title="中断关闭"></a>中断关闭</h2><p>中断关闭是中断状态的改变：</p><ul><li>从等待并活跃转换到等待。</li><li>从活跃转换到空闲。</li></ul><p>如前面讲述的那样，如果中断优先级降低和中断关闭这两个阶段因为 GICC_CTLR.EOImode 设为 1 而分离，那么中断处理程序必须：</p><ol><li>进行一个有效的 EOIR 写，产生中断优先级降低在 CPU 接口上</li><li>进行 GICC_DIR 写，来正式关闭中断。</li></ol><p><img src="安全扩展别名寄存器.png" alt="安全扩展别名寄存器.png"></p><h1 id="GIC-中断控制"><a href="#GIC-中断控制" class="headerlink" title="GIC 中断控制"></a>GIC 中断控制</h1><h2 id="设置并清理中断的等待状态"><a href="#设置并清理中断的等待状态" class="headerlink" title="设置并清理中断的等待状态"></a>设置并清理中断的等待状态</h2><ol><li>对于外设中断，处理器可以：<ul><li>设置等待状态通过写 GICD_ISPENDRn 的某一位。</li><li>清理等待状态通过写 GICD_ICPENDRn 的某一位。</li></ul></li><li>对于电平敏感的中断：<ul><li>通过写 GICD_ICPENDRn 来清除等待状态无效。</li><li>如果通过写 GICD_ISPENDRn 来设置等待状态，则电平变化不会影响等待状态。</li></ul></li><li>对于 SGI 中断：<ul><li>写 GICD_ISPENDRn 和 GICD_ICPENDRn 是无效的。</li><li>SGI 等待状态通过写 GICD_SGIR 设置。在 GICV2 中，也可以通过写 GICD_SPENDSGIRn 和 GICD_CPENDSGIRn 来生效。<h2 id="产生一个-SGI"><a href="#产生一个-SGI" class="headerlink" title="产生一个 SGI"></a>产生一个 SGI</h2>一个处理器可以通过写 GICD_SGIR 来产生 SGI 中断<br><img src="GICD_SGIR.png" alt="GICD_SGIR.png"><br>SGI通过中断号、源CPU和目标CPU三者区分，等待状态独立。</li></ul></li></ol><p>在一个CPU接口上同一中断号只能有一个活跃。</p><h2 id="中断处理状态机"><a href="#中断处理状态机" class="headerlink" title="中断处理状态机"></a>中断处理状态机</h2><p>GIC 为每个中断维护一个状态机。</p><p><img src="statemachine.png" alt="statemachine.png"></p><ol><li>A1,A2:增加等待状态</li></ol><ul><li>对于SGI，发生如下状况之一：<ol><li>软件写 GICD_SGIR 来指定某一处理器作为目标</li><li>目标寄存器写 GICD_SPENDSGIRn 来指定源寄存器和中断号。</li></ol></li><li>对于SPI和PPI，发生如下状况之一：<ol><li>一个外设产生一个中断信号。</li><li>软件写了 GICD_ISPENDRn。</li></ol></li></ul><ol><li>B1,B2:删除等待状态</li></ol><ul><li>对于SGI，仅仅在目标寄存器写 GICD_CPENDSGIRn 时发生。</li><li>对于SPI和PPI，发生如下状况之一：<ol><li>电平触发的中断信号置位为无效。</li><li>边沿触发的中断信号或者通过写 GICD_ISPENDRn 产生的等待状态被软件写 GICD_ICPENDRn 清楚。</li></ol></li></ul><ol><li>C:等待到活跃状态</li></ol><ul><li>CPU 读取 GICC_IAR</li></ul><ol><li>D:等待到等待并活跃状态</li></ol><ul><li>对于SGI，发生如下情况之一：<ol><li>读 GICC_IAR 和设置 SGI 中断同时发生。</li><li>当同中断号、同源CPU、同目标CPU的两个中断有一个转变为活跃时，另一个转变为等待并活跃。</li></ol></li><li>对于SPI和PPI，按顺序发生如下情况：<ol><li>中断是启用的。</li><li>CPU 读 GICC_IAR，向该中断添加活跃状态。</li><li>如果是电平触发的中断，则中断一般情况就会变成等待并活跃状态。</li><li>如果是边沿触发的中断，则取决于是否再次触发中断。</li></ol></li></ul><ol><li>E1,E2:移除活跃状态。<br>发生在CPU通过写GICC_EOIR或者GICC_DIR清除中断时。</li></ol><h1 id="中断优先级"><a href="#中断优先级" class="headerlink" title="中断优先级"></a>中断优先级</h1><h2 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h2><p>GICv2 最多支持 256 种优先级，但具体支持多少是实现定义的，如果少于256则低位是读恒为0且写无效的。<br><img src="中断优先级数量.png" alt="中断优先级数量.png"></p><p>想知道具体的中断优先级数量可以通过向 GICD_IPRIORITYR 寄存器写 0xff 后读取来确定（根据写无效），该寄存器也配置了每个中断的优先级（8位对应一个）</p><p><img src="注意事项.png" alt="注意事项.png"></p><h2 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h2><p>一个处于等待的中断可以被发起需要满足以下条件：</p><ol><li>其优先级大于CPU接口的优先级掩码。</li><li>其所在组的组优先级大于CPU接口的运行优先级。</li></ol><h2 id="优先级掩码"><a href="#优先级掩码" class="headerlink" title="优先级掩码"></a>优先级掩码</h2><p>设置 GICC_PMR 可以定义目标处理器的优先级门槛，只有大于此优先级的中断才可能被发起中断请求。</p><p><img src="GICC_PMR.png" alt="GICC_PMR.png"></p><h2 id="优先级分组"><a href="#优先级分组" class="headerlink" title="优先级分组"></a>优先级分组</h2><p>优先级分组使用 GICC_BPR 来将一个优先级值分为两个区域——组优先级和子优先级，如下图所示，向该寄存器写入的值即为 <code>Binary point value</code>。</p><p><img src="组优先级.png" alt="组优先级.png"></p><p>当决定是否需要抢占时，同一组内的中断视为同一优先级。</p><h1 id="中断分组对中断处理的影响"><a href="#中断分组对中断处理的影响" class="headerlink" title="中断分组对中断处理的影响"></a>中断分组对中断处理的影响</h1><h2 id="GIC-中断分组支持"><a href="#GIC-中断分组支持" class="headerlink" title="GIC 中断分组支持"></a>GIC 中断分组支持</h2><p>GIC 为组 0 和组 1 提供了别名寄存器如下：<br><img src="GICGROUP.png" alt="GICGROUP.png"></p><h2 id="特殊中断号"><a href="#特殊中断号" class="headerlink" title="特殊中断号"></a>特殊中断号</h2><p>如果 GIC 支持中断分组。<br>1020-1021：保留。<br>1022: 发生在以下条件满足时：</p><ol><li>读 GICC_IAR 进行中断确认</li><li>此时最高优先级的等待中断在组 1</li><li>GICC_CTLR.AckCtl 设置为 0</li><li>该中断足够有效可以发起中断请求<br>这向程序表明此时有组1中断应该去处理，且应该读 GICC_AIAR，如果是对于实现了安全扩展的GIC，这表明应该以非安全的形式读 GICC_IAR。<h2 id="中断分组对中断处理的影响-1"><a href="#中断分组对中断处理的影响-1" class="headerlink" title="中断分组对中断处理的影响"></a>中断分组对中断处理的影响</h2>ARM强烈推荐对于支持中断分组的GIC，应该设置GICC_CTLR.AckCtl为0，在这种情况下：</li><li>组0中断应该通过读 GICC_IAR 来确认，或者在安全扩展的情况下通过安全读 GICC_IAR 实现。</li><li>组1中断应该通过读 GICC_AIAR 来确认，或者在安全扩展的情况下通过非安全读 GICC_IAR 实现。<br>建议组0的中断优先级都比组1高。<h2 id="中断确认在安全扩展"><a href="#中断确认在安全扩展" class="headerlink" title="中断确认在安全扩展"></a>中断确认在安全扩展</h2>安全扩展启用的情况下，组0中断是安全中断，组1中断是非安全中断，同样是在GICC_CTLR.AckCtl为0情况下：</li></ol><p>确认非安全中断，处理器可以非安全读GICC_IAR 或者安全读 GICC_AIAR 寄存器。</p><p>确认安全中断，处理器可以安全读 GICC_IAR 寄存器。</p><p>此时安全读到 1022 代表当前最高优先级等待中断为非安全中断，非安全读到 1023 代表当前最高级中断是安全中断。</p><h1 id="启动或者初始化配置"><a href="#启动或者初始化配置" class="headerlink" title="启动或者初始化配置"></a>启动或者初始化配置</h1><p>GIC 会将所有的中断归到组0，并且关闭 FIQ 异常请求。</p><h1 id="软件视角对于-GIC-安全扩展的优先级"><a href="#软件视角对于-GIC-安全扩展的优先级" class="headerlink" title="软件视角对于 GIC 安全扩展的优先级"></a>软件视角对于 GIC 安全扩展的优先级</h1><h2 id="安全与非安全优先级"><a href="#安全与非安全优先级" class="headerlink" title="安全与非安全优先级"></a>安全与非安全优先级</h2><p>很多系统在实现时需要 Group 0 的所有中断优先级高于 Group 1。因此 ARM 强烈推荐在分配优先级时遵循以下原则：</p><ol><li>组 0 中断优先级分配 GIC 所支持优先级的低半部分，即最高位为 0.</li><li>组 1 中断优先级分配 GIC 所支持优先级的高半部分。即最高位为 1.<h2 id="安全访问"><a href="#安全访问" class="headerlink" title="安全访问"></a>安全访问</h2>安全访问/写入 GICD_IPRIORITYR 寄存器，访问/写入结果和寄存器所存值相同。<br>![SecureView.jpg]<h2 id="非安全访问"><a href="#非安全访问" class="headerlink" title="非安全访问"></a>非安全访问</h2>非安全访问 GICD_IPRIORITYR 寄存器，访问结果是寄存器所存值左移 1 位的结果。非安全写 GICD_IPRIORITYR 寄存器，写的结果是所写值右移一位，以及 bit[7] = 1。<h3 id="寄存器值"><a href="#寄存器值" class="headerlink" title="寄存器值"></a>寄存器值</h3><img src="SecureRead.jpg" alt="SecureRead.jpg"><h3 id="访问结果"><a href="#访问结果" class="headerlink" title="访问结果"></a>访问结果</h3><img src="NonSecureRead.jpg" alt="NonSecureRead.jpg"><h2 id="软件视角"><a href="#软件视角" class="headerlink" title="软件视角"></a>软件视角</h2><img src="Software.jpg" alt="Software.jpg"><h2 id="组-1-中断的抢占控制"><a href="#组-1-中断的抢占控制" class="headerlink" title="组 1 中断的抢占控制"></a>组 1 中断的抢占控制</h2>如前文所述，一般情况下 GICC_BPR 决定组 0 抢占，GICC_ABPR 决定组 1 抢占，但这取决于 GICC_CTLR.CBPR 的控制，如果 CBPR = 1，则 GICC_BPR 同时决定组 0 和组 1 的抢占。<h3 id="安全扩展"><a href="#安全扩展" class="headerlink" title="安全扩展"></a>安全扩展</h3></li></ol><ul><li>CBPR 字段仅仅在 GICC_CTLR 的安全拷贝下实现。</li><li>GICC_BPR 安全拷贝决定组 0 中断，在 CBPR = 1 的情况下，也决定组 1 中断。</li><li>GICC_ABPR 是 GICC_CTLR 的非安全拷贝。</li><li>GICC_ABPR 是安全寄存器，仅能安全访问。<h2 id="中断分组对优先分组的影响"><a href="#中断分组对优先分组的影响" class="headerlink" title="中断分组对优先分组的影响"></a>中断分组对优先分组的影响</h2>当某一中断使用 GICC_ABPR 时，GICC_ABPR 决定的小数点相比 GICC_BPR 将会右移一位，这样保证了软件可以在不清楚自己处于安全/非安全的状态下得到相同的优先级分组。</li></ul><p><img src="GICC_ABPR.jpg" alt="GICC_ABPR.jpg"></p><blockquote><p>至于怎么理解的话，我是想假如以软件视图来看，假设一个中断的优先级是 abcdefg，如果是安全视角，存入 GICD_IPRIORITYR 的就是 abcdefg，然后假如 GICC_BPR 是 1，则分组是 abcde.fg，<br>如果是非安全视角，存入 GICD_IPRIORITYR 的就是 1abcdef，然后加入 GICC_ABPR 是 1， 则分组是 1abcde.f，这样两者之间就是一个数量差的映射关系，分组优先级就不变了。</p></blockquote><h1 id="在虚拟化环境中支持-IRQ-和-FIQ"><a href="#在虚拟化环境中支持-IRQ-和-FIQ" class="headerlink" title="在虚拟化环境中支持 IRQ 和 FIQ"></a>在虚拟化环境中支持 IRQ 和 FIQ</h1><h2 id="Hypervisor-的工作"><a href="#Hypervisor-的工作" class="headerlink" title="Hypervisor 的工作"></a>Hypervisor 的工作</h2><ol><li>实现一个虚拟的分发器，使用 GIC 的虚拟化扩展,这个虚拟化分发器可以虚拟化来自 GIC 的 IRQ 中断为虚拟 IRQ 和 虚拟 FIQ 中断，并且将其路由到合适的虚拟机。</li><li>路由物理 IRQ 到 Hypervisor，让其可以被虚拟分发器处理。<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2>Guest OS 分配中断到组 0 和 组 1，来将他们分配为 FIQ 或者 IRQ，其对 GIC 分发器的访问被 Hypervisor 捕获，变为对虚拟分发器的访问。</li></ol><p>虚拟CPU接口将这些中断以虚拟 FIQ 和 IRQ 的形式发送给 CPU。这个虚拟化过程在 Hypervisor 的控制下进行，对 OS 不可见。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p><img src="VGIC.png" alt="VGIC.png"></p><p>当 GIC 发送一个 IRQ 给处理器时，中断应该被路由到 Hypervisor，Hypervisor 决定这个中断是发给自己还是 Guest OS的，如果是后者，则其应该确定：</p><ol><li>哪个 OS 该处理这个中断</li><li>OS 将这个中断配置为了 FIQ 还是 IRQ</li><li>中断优先级，基于 OS 配置的。</li></ol><p>确定后，Hypervisor 更新寄存器列表，将这个中断加入等待中断中。</p><p>如果收到一个 IRQ 时，当前运行的 OS不能处理这个中断,Hypervisor 应该：</p><ol><li>唤醒可以处理该中断的 OS。</li><li>将这个中断加入可以处理该中断的上下文保存中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM-Gicv2 第二章学习</title>
      <link href="/posts/28608/"/>
      <url>/posts/28608/</url>
      
        <content type="html"><![CDATA[<h1 id="GIC-组成"><a href="#GIC-组成" class="headerlink" title="GIC 组成"></a>GIC 组成</h1><h2 id="分发器-Distributor"><a href="#分发器-Distributor" class="headerlink" title="分发器 Distributor"></a>分发器 Distributor</h2><p>分发器的功能是定义优先级和将中断分发给GIC的CPU结构，其寄存器以 GICD_ 前缀识别。</p><h2 id="CPU-接口"><a href="#CPU-接口" class="headerlink" title="CPU 接口"></a>CPU 接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>每个 CPU 接口层提供优先级掩码和抢占处理，其寄存器以 GICC_ 前缀识别。</p><h2 id="虚拟-CPU-接口"><a href="#虚拟-CPU-接口" class="headerlink" title="虚拟 CPU 接口"></a>虚拟 CPU 接口</h2><h3 id="虚拟接口控制器"><a href="#虚拟接口控制器" class="headerlink" title="虚拟接口控制器"></a>虚拟接口控制器</h3><p>最主要部分是一套寄存器，包含一个当前虚拟机正在处理和等待的中断表。一般情况下，这些寄存器被运行在此处理器上的Hypervisor管理，以 GICH_ 前缀识别。</p><h3 id="虚拟-CPU-接口-1"><a href="#虚拟-CPU-接口-1" class="headerlink" title="虚拟 CPU 接口"></a>虚拟 CPU 接口</h3><p>每个虚拟 CPU 接口对于虚拟中断提供物理信号对于连接到的处理器。ARM 处理器虚拟化扩展将这些中断信号发送到当前处理器正在执行的虚拟机上。虚拟CPU接口的寄存器可以被虚拟机访问，提供中断控制和状态信息。格式类似于 CPU 接口，以 GICV_ 前缀识别。<br><blockquote><p>在实现了虚拟化扩展的GIC中，Hypervisor有义务在切换虚拟机时切换 GICH 中存储的信息。</p></blockquote></p><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="GIC逻辑组成.png" alt="GIC逻辑组成.png"></p><h1 id="Distributor"><a href="#Distributor" class="headerlink" title="Distributor"></a>Distributor</h1><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>分发器集中所有的中断源，确定每个中断的优先级，并为每个CPU接口转发具有最高优先级的中断到该接口，以进行优先级屏蔽和抢占处理。</p><h2 id="可配置参数"><a href="#可配置参数" class="headerlink" title="可配置参数"></a>可配置参数</h2><ul><li>全局启用中断分发。</li><li>开关每个中断。</li><li>设置每个中断的优先级。</li><li>设置每个中断的目标处理器。</li><li>设置每个外设中断的触发方式（边沿、电平）</li><li>设置每个中断的组。</li><li>路由 SGI 中断到目标处理器。<h2 id="中断号"><a href="#中断号" class="headerlink" title="中断号"></a>中断号</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3>中断在 GIC 以 中断号进行标识，每个 CPU 接口可以看到 1020 个中断。Banking 机制增加了分发器支持的中断。<h3 id="分配规则"><a href="#分配规则" class="headerlink" title="分配规则"></a>分配规则</h3>GIC 分配 0 - 1019 以如下规则：</li><li>32-1019 被 SPI 使用</li><li>0 - 31 被私有中断使用（私有针对于CPU接口），这些中断在分发器中 banking，其中 0-15 被 SGI 使用，16-31 被 PPI 使用。<blockquote><p>每个连接到GIC的处理器通过写 GICD_SGIR 来发送 SGI 中断，在分发器中，一个 SGI 通过源CPUID，目标CPUID，中断号独立识别。在CPU接口中，接口在向CPU发送中断ID时会附加源CPUID来独立识别。</p></blockquote></li></ul><h1 id="CPU-接口-1"><a href="#CPU-接口-1" class="headerlink" title="CPU 接口"></a>CPU 接口</h1><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><p>每个CPU接口提供处理器连接到GIC的接口，当CPU接口启用时，CPU接口为处理器取出最高优先级的等待中断并且确认该中断优先级是否足够有效使其向处理器发送中断请求。CPU可以在任意时刻读取GICC_HPPIR寄存器来看当前在CPU接口等待的最高优先级中断号。</p><h2 id="可配置参数-1"><a href="#可配置参数-1" class="headerlink" title="可配置参数"></a>可配置参数</h2><ul><li>启用向处理器发送中断请求信号</li><li>确认一个中断</li><li>表明一个中断的处理完成</li><li>设置处理器中断优先级掩码</li><li>定义处理器抢占策略</li><li>确定处理器待决的最高优先级中断。<h2 id="CPU-中断处理"><a href="#CPU-中断处理" class="headerlink" title="CPU 中断处理"></a>CPU 中断处理</h2>CPU 确认中断通过<strong>读取</strong>IAR寄存器来进行，读取的结果有两种：</li></ul><ol><li>真实中断号</li><li>虚假中断号</li></ol><p>当 CPU 确认中断后，分发器将该中断的状态设置为活跃、活跃和等待。此时 CPU 接口可以发起其他中断给处理器，来进行抢占。</p><p>当 CPU 完成中断处理后，处理器写处理器接口寄存器来表明完成，完成分为两个过程：</p><ol><li>优先级下降，意味着刚才处理中断的优先级无法再影响别的中断的发出了。</li><li>中断关闭，意味着分发器移除了中断的活跃状态。</li></ol><p>在 GICV2 中，两个过程是否同时发生取决于 GICC_CTLR 寄存器的控制。</p>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM-Gicv2 第一章学习</title>
      <link href="/posts/59403/"/>
      <url>/posts/59403/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="GIC-功能"><a href="#GIC-功能" class="headerlink" title="GIC 功能"></a>GIC 功能</h2><ul><li>为管理中断资源、中断行为进行注册，并对中断进行路由。</li><li>支持 ARM 安全扩展、虚拟化扩展</li><li>启用、禁用来自硬件的中断</li><li>SGI（软件中断）</li><li>中断掩码和优先级设置</li><li>在电源管理环境中产生唤醒事件。<h2 id="GIC-分组"><a href="#GIC-分组" class="headerlink" title="GIC 分组"></a>GIC 分组</h2></li><li>将每个中断配置为组 0 或者组 1。</li><li>将组 0 的中断以 IRQ 或者 FIQ 的形式发到处理器。</li><li>将组 1 的中断以 IRQ 的形式发送到处理器。</li><li>以一个统一的表来处理组0组1中断的优先级。</li><li>对组0的某些中断可以锁定。<blockquote><p>在许多 ARM 架构的实现中，IRQ 和 FIQ 中断请求对应于 IRQ 和 FIQ 异步异常。</p></blockquote><h2 id="GIC-安全支持"><a href="#GIC-安全支持" class="headerlink" title="GIC 安全支持"></a>GIC 安全支持</h2>对于实现了安全扩展的处理器：</li><li>组 0 中断为安全中断、组 1 中断为非安全中断。</li><li>处理器对 GIC 寄存器的访问分为安全与非安全。<ul><li>非安全访问只能读写控制非安全中断的寄存器。</li><li>安全访问可以读写任意寄存器。</li></ul></li><li>安全系统软件单独将每个已实施的中断定义为安全和非安全。<h2 id="GIC-虚拟化支持"><a href="#GIC-虚拟化支持" class="headerlink" title="GIC 虚拟化支持"></a>GIC 虚拟化支持</h2>支持对于虚拟中断的处理，降低 Hypervisor 路由中断到虚拟机的开销。<h1 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h1><h2 id="中断状态"><a href="#中断状态" class="headerlink" title="中断状态"></a>中断状态</h2></li><li>Inactive: 中断是未触发或者不在等待被处理。</li><li>Pending： 中断已经被触发，等待目标处理器处理。</li><li>Active: 中断已经被目标处理器确认，正在处理中。</li><li>Active and pending：中断正在被目标处理器处理，与此同时有一个一样的中断等待被处理。<h2 id="中断类型"><a href="#中断类型" class="headerlink" title="中断类型"></a>中断类型</h2><h3 id="外设中断"><a href="#外设中断" class="headerlink" title="外设中断"></a>外设中断</h3></li><li>PPI：私有外设中断，需要指定处理器处理的中断。</li><li>SPI：共享外设中断，可以被指定的一组寄存器处理的中断。<blockquote><p>外设中断在电平上分为两种：</p><ol><li>边沿触发：上升沿触发，一直保持中断触发状态直到被处理。</li><li>电平触发：在高电平时触发，要么被处理、要么回到低电平则撤销中断触发。</li></ol></blockquote><h3 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h3></li><li>通过软件写 GICD_SGIR 寄存器触发。用来进行核间通信。</li><li>软中断的触发属性和边沿触发一致。</li><li>当 SGI 软件中断触发时，通过 GICC_IAR 或者 GICC_AIAR 识别请求中断的处理器 ID。<blockquote><p>对于实现了虚拟扩展的GIC：</p><ol><li>SGI 发生时，在 GIC 虚拟扩展中的管理寄存器将允许将请求中断的CPU报告给虚拟机。</li><li>通过写管理寄存器，Hypervisor可以产生一个在虚拟机表现为SGI的虚拟中断。</li></ol></blockquote><h3 id="虚拟中断"><a href="#虚拟中断" class="headerlink" title="虚拟中断"></a>虚拟中断</h3>发给某一个运行在处理器上的虚拟机的中断。<h3 id="维护中断"><a href="#维护中断" class="headerlink" title="维护中断"></a>维护中断</h3>一个电平触发的中断，来揭示关键事件，例如一组中断被启用了。<h2 id="中断模型"><a href="#中断模型" class="headerlink" title="中断模型"></a>中断模型</h2><h3 id="1-N-模型"><a href="#1-N-模型" class="headerlink" title="1-N 模型"></a>1-N 模型</h3>中断发给多个处理器，但只需要一个处理器处理。<h3 id="N-N-模型"><a href="#N-N-模型" class="headerlink" title="N-N 模型"></a>N-N 模型</h3>中断发给多个处理器，每个处理器都要处理这个中断。<h2 id="虚假中断"><a href="#虚假中断" class="headerlink" title="虚假中断"></a>虚假中断</h2>在 GIC 将中断分发给 CPU 后，此中断不再被需要是可能的。所以在 CPU 确认此中断时，GIC 将会返回一个特殊的中断ID表面此中断是一个虚假中断。<h3 id="Banking"><a href="#Banking" class="headerlink" title="Banking"></a>Banking</h3></li><li>中断 Banking：一组中断在GIC表现为同一个中断号，通过中断号和关联CPU进行区分。</li><li>寄存器 Banking: 同一地址存在多个复制体寄存器。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZCU102提升-PL 协同 PS</title>
      <link href="/posts/2/"/>
      <url>/posts/2/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>本文正式对 ZynqMP Ultrascale+ 的重点特性—— PL 协同 PS 共同工作进行了初步探索。具体为在 PL 段烧写两个 GPIO 控制器来控制 LED 灯和五个按钮，并编写 PS段程序实现按钮通过中断来控制 LED 灯。</p><p>探索过程极其曲折，以至于笔者不得不用一张图来表达现在的心情：</p><p><img src="王雷.jpeg" alt="王雷"></p><h2 id="Vivado"><a href="#Vivado" class="headerlink" title="Vivado"></a>Vivado</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>工作环境 vivado 2024.1, ubuntu 22.04.3。</p></li><li><p>创建 vivado 工程，例如叫做 ZCU102-PSPL-LED。</p></li><li><p>和 Helloworld 一样在 Block Design 对 ZynqMP 芯片初步配置。</p></li></ul><h3 id="GPIO配置"><a href="#GPIO配置" class="headerlink" title="GPIO配置"></a>GPIO配置</h3><ul><li><p>点击 + 号新增两个 GPIO</p><p>  <img src="AXI-GPIO.png" alt="GPIO"></p><p>  GPIO全拼叫General Purpose Input Output（通用输入输出）简称IO口也叫总线扩展器，这里我们加入的 GPIO 将可以让 PL段的 LED灯、按钮得以通过 GPIO 连接到 AXI 进而和 PS 进行交互。</p></li><li><p>GPIO 0 配置 LED 输出</p><p>  <img src="GPIO0.png" alt="GPIO0"></p><p>  Xilinx 提供的 AXI GPIO IP 核有两条通道，因此其实可以使用一个 GPIO 同时管理 LED 和按钮，但为了简化，我们就只使用一通道。</p></li><li><p>GPIO 1 配置 Button 输入，并在下方配置中断</p><p>  <img src="GPIO1.png" alt="GPIO1"></p><p>  对比一下 GPIO0 就会发现模块上多了一条信号线 ip2intc_irpt。 GPIO 通过此来发送中断信号。</p></li><li><p>点击 <code>Run Connection Automation</code> 并全选，自动将 MPsoc 和两个 GPIO 连接起来。</p><p>  <img src="Connect.png" alt="Connect"></p><p>  最终效果类似下图：</p><p>  <img src="连接效果.png" alt="连接效果"></p></li></ul><h3 id="PS-中断配置"><a href="#PS-中断配置" class="headerlink" title="PS 中断配置"></a>PS 中断配置</h3><p>至此，我们可以看到图中的 <code>ip2intc_irpt</code> 还没有连线，我们需要对此进行配置。</p><ul><li><p>重新配置 MPSOC，在 PS-PL Configuration 下找到 Interrupts -&gt; PL to PS -&gt; IRQ0，Select 改为 1。</p><p>  <img src="IRQ0.png" alt="IRQ0"></p><p>  可以看到 MPsoc 芯片上也多了一条信号，叫 <code>pl_ps_irq0</code>。</p></li><li><p>在图上拖动鼠标，将 <code>ip2intc_irpt</code> 和 <code>pl_ps_irq0</code> 连接起来即可。</p><p>  <img src="中断连线.png" alt="中断连线"></p><p>  这样的连线表明，gpio1产生的中断将通过 pl_ps_irq0 传入到 ps 中，进而传入到arm的中断控制器 GIC 中。</p></li></ul><h3 id="Debug-检查（选做）"><a href="#Debug-检查（选做）" class="headerlink" title="Debug 检查（选做）"></a>Debug 检查（选做）</h3><p>为了更好的理解工作原理，我非常建议对中断信号进行一个 debug 处理，即引入一个 ILA 来监测信号变化。</p><ul><li><p>点击 + 号添加一个 ILA。</p><p>  <img src="ila.png" alt="ila"></p></li><li><p>双击 ILA 配置如下。</p><p>  <img src="ila配置.png" alt="ila配置"></p><ul><li><p>Sample Data Depth 可以任选，这代表了可以一次捕捉多少波形，越大在综合时消耗的板上资源越多，所以酌情处理。</p></li><li><p>Number of Probes 代表了探测多少信号，这里我们只探测一个中断信号。</p></li><li><p>Capture Control 需要选上，这样我们可以设置捕捉什么样电位的信号。</p></li></ul></li><li><p>将 <code>Probe0</code> 和 <code>ip2intc_irpt</code> 连接起来。</p></li><li><p>如果配置了此部分，我们可以在之后运行程序时，打开 Vivado 的 Hardware Manager 来捕捉中断信号的波形。</p><p>  <img src="HM.png" alt="HM"></p></li></ul><h3 id="后续工作"><a href="#后续工作" class="headerlink" title="后续工作"></a>后续工作</h3><p>和 helloworld 类似，在生成比特流成功后导出 xsa，这次由于在 PL 实现了两个 GPIO 控制器，因此一定要勾选 Include BitStream。</p><p><img src="Bit.png" alt="Bit"></p><h2 id="Vitis"><a href="#Vitis" class="headerlink" title="Vitis"></a>Vitis</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>和 helloworld 一样，基于导出的 xsa 生成 platform。</p><h3 id="创建-APP"><a href="#创建-APP" class="headerlink" title="创建 APP"></a>创建 APP</h3><p>这次我们由于要自己编写程序，所以理应是创建 Empty Application，但是这样会需要自己导入头文件目录，比较麻烦，所以我们继续创建一个 Helloworld 的 Example Application。</p><h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>我们在 helloworld.c 重写自己的逻辑，代码如下</p><ul><li><p>main 函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打印一个字符画，出于美观的原因</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ooooo        oooooooooooo oooooooooo.        ooooooooooooo oooooooooooo  .oooooo..o ooooooooooooo\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;`888&#x27;        `888&#x27;     `8 `888&#x27;   `Y8b       8&#x27;   888   `8 `888&#x27;     `8 d8P&#x27;    `Y8 8&#x27;   888   `8\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 888          888          888      888           888       888         Y88bo.           888\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 888          888oooo8     888      888           888       888oooo8      `Y8888o.       888\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 888          888          888      888           888       888               `Y88b      888\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; 888       o  888       o  888     d88&#x27;           888       888       o oo     .d8P      888\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;o888ooooood8 o888ooooood8 o888bood8P&#x27;            o888o     o888ooooood8 88888888P&#x27;      o888o\r\n&quot;</span>);</span><br><span class="line">                                                                                                  </span><br><span class="line">                                                                                                </span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Entering main---\n\r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\r\nRunning GpioOutputExample for axi_gpio ... \r\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用核心测试函数，传入两个在 xparameters.h 中定义的 GPIO 基地址。</span></span><br><span class="line">        status = <span class="built_in">GpioOutputExample</span>(XPAR_AXI_GPIO_0_BASEADDR,  XPAR_AXI_GPIO_1_BASEADDR);</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;GpioOutputExample PASSED \r\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;GpioOutputExample FAILED \r\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---Exiting main---&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </li><li><p>GpioOutputExample 函数</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GpioOutputExample</span><span class="params">(UINTPTR BaseAddress_0, UINTPTR BaseAddress_1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">XGpio_Config *CfgPtr;</span><br><span class="line"><span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GPIO 0</span></span><br><span class="line">CfgPtr = <span class="built_in">XGpio_LookupConfig</span>(BaseAddress_0);</span><br><span class="line">Status = <span class="built_in">XGpio_Initialize</span>(&amp;GpioOutput, BaseAddress_0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status != XST_SUCCESS)  &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;XST FAIL\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 GPIO 0 一通道的所有方向为输出（对齐Vivado配置）</span></span><br><span class="line"><span class="built_in">XGpio_SetDataDirection</span>(&amp;GpioOutput, LED_CHANNEL, <span class="number">0x0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 关闭所有 LED 灯</span></span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, LED_CHANNEL, <span class="number">0x0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 GPIO 1</span></span><br><span class="line">    CfgPtr = <span class="built_in">XGpio_LookupConfig</span>(BaseAddress_1);</span><br><span class="line">Status = <span class="built_in">XGpio_Initialize</span>(&amp;GpioInput, BaseAddress_1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Status != XST_SUCCESS)  &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;XST FAIL\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> XST_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 GPIO 1 一通道的所有方向为输入（对齐Vivado配置）</span></span><br><span class="line">    <span class="built_in">XGpio_SetDataDirection</span>(&amp;GpioInput, BTN_CHANNEL, <span class="number">0b11111</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// GPIO 使能中断</span></span><br><span class="line">    <span class="built_in">XGpio_InterruptGlobalEnable</span>(&amp;GpioInput);</span><br><span class="line">    <span class="built_in">XGpio_InterruptEnable</span>(&amp;GpioInput, <span class="number">0b11111</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;config_intrid : %u\r\n&quot;</span>,CfgPtr-&gt;IntrId);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;config_intrparent : %u\r\n&quot;</span>,CfgPtr-&gt;IntrParent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 GIC，绑定中断处理函数 handler_btn（自定义函数）</span></span><br><span class="line">    Status = <span class="built_in">XSetupInterruptSystem</span>(&amp;GpioInput,</span><br><span class="line">    &amp;handler_btn,CfgPtr-&gt;IntrId,</span><br><span class="line">    CfgPtr-&gt;IntrParent,</span><br><span class="line">    XINTERRUPT_DEFAULT_PRIORITY);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;XScuGic Initialized\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (mode)<span class="comment">//选择5种闪烁模式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00000001</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00000010</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00000100</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00001000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00010000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00100000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b01000000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b10000000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00000011</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00001100</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00110000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b11000000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00001111</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b11110000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b11111111</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00000000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b10000001</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b01000010</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00100100</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00011000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">//全熄灭</span></span><br><span class="line"><span class="built_in">XGpio_DiscreteWrite</span>(&amp;GpioOutput, <span class="number">1</span>, <span class="number">0b00000000</span>);</span><br><span class="line"><span class="built_in">usleep</span>(<span class="number">100000</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> XST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <ul><li>handler_btn 函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handler_btn</span><span class="params">(<span class="type">void</span>* Callback)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Interrupt Received !\r\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 将 Callback 强制转为 XGpio 结构体，至于为什么传入的一定是这个结构体，这取决于XSetupInterruptSystem的第一个参数。</span></span><br><span class="line"></span><br><span class="line">XGpio* g = (XGpio*)Callback;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读出按钮状态</span></span><br><span class="line">u32 r;</span><br><span class="line">r = <span class="built_in">XGpio_DiscreteRead</span>(g, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%08x\n\r&quot;</span>, r);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置工作模式</span></span><br><span class="line"><span class="comment">//由于AXI GPIO中断无论接口由0变1还是由1变0都会产生高电平中断给PS，根据当前逻辑不能响应接口由1变0的中断</span></span><br><span class="line"><span class="keyword">switch</span> (r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b1</span>:</span><br><span class="line">mode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b10</span>:</span><br><span class="line">mode = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b100</span>:</span><br><span class="line">mode = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b1000</span>:</span><br><span class="line">mode = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0b10000</span>:</span><br><span class="line">mode = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">//多键按下或者GPIO接口由1变0，都不响应</span></span><br><span class="line">mode = mode;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;falling edge!\r\n&quot;</span>);        </span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除全部中断</span></span><br><span class="line"><span class="built_in">XGpio_InterruptClear</span>(g, <span class="number">0b11111</span>);</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;========================================\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <ul><li>头文件引入和全局变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xil_exception.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xinterrupt_wrap.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xscugic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xparameters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xgpio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xstatus.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;xil_printf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sleep.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_CHANNEL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BTN_CHANNEL 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> printf xil_printf</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GpioOutputExample</span><span class="params">(UINTPTR BaseAddress_0, UINTPTR BaseAddress_1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GpioInputExample</span><span class="params">(UINTPTR BaseAddress, u32 *DataRead)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GpioDriverHandler</span><span class="params">(<span class="type">void</span> *CallBackRef)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">XGpio GpioOutput;</span><br><span class="line">XGpio GpioInput;  </span><br><span class="line">XScuGic ScuGic;</span><br><span class="line"><span class="keyword">volatile</span> u8 mode = <span class="number">0</span>;</span><br></pre></td></tr></table></figure> <ul><li>将上述几段代码拼起来即为全部文件内容。</li></ul><h2 id="烧写测试"><a href="#烧写测试" class="headerlink" title="烧写测试"></a>烧写测试</h2><h3 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h3><p>和 helloworld 类似，生成 boot.bin，将 zcu102 启动模式改为 QSPI 启动。烧写完毕后重启板子，等待 GIC 初始化完成后，按动 5个按钮，观察 LED 显示模式是否变化即可。</p><h3 id="ILA（选做）"><a href="#ILA（选做）" class="headerlink" title="ILA（选做）"></a>ILA（选做）</h3><p>如果之前进行了 ILA 模块的添加和配置，那我们可以观察到按动任意开关时中断信号的变化。</p><p>具体方法如下：</p><ul><li><p>连接 jtag 线到电脑</p></li><li><p>点开 vivado 的 hardware manager。</p></li><li><p>点击 open target -&gt; auto connect，vivado 将自动检测 jtag，如果检测成功，将会出现我们的开发板。</p><p>  <img src="ila测试.png" alt="ila测试"></p><p>  并且我们可以看到我们添加的 ila_1。</p></li><li><p>右键图中的 xzcu9_0 ，点击 program device，选择我们的 bit 流，路径在 工程目录/xx.run/xx.impl下.</p><p>  <img src="select.png" alt="select"></p></li><li><p>点击 program 等待烧写完毕，之后重启板子。</p><p>  重启的原因是一般情况下，此时程序已经运行过了 GPIO 的配置，但我们重新烧写了 PL，相当于 reset 了 GPIO，对于中断的配置将失效，此时我们直接抓信号将得不到正确结果。</p></li><li><p>点击图中的加号，添加仅有的一根信号线进来</p><p>  <img src="sign.png" alt="sign"></p><p>  名字发生变化不奇怪，是因为 Vivado 综合实现可能会进行优化，不会保留原有的名字。</p></li><li><p>修改此信号的抓取逻辑如下，抓取信号为 高电平（1）的时刻。</p><p>  <img src="config.png" alt="config"></p></li><li><p>点击抓取设置左侧的启动，Ila 进入监测模式，检测到高电平将会抓取并显现出来。</p><p>  <img src="waiting.png" alt="waiting"></p></li><li><p>此时我们任意按下一个板上按钮，正确情况将会抓取到高电平的中断信号</p><p>  <img src="result.png" alt="result"></p><p>  这证明了按下按钮，在正确配置的情况下，gpio控制器将拉高中断信号线，ps我们写的handler 对其进行处理后 gpio中断信号线将重新回到低电位。</p></li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>现有的网络教程版本太为落后，xsa已经使用了SDT这种全新的规范，进而导致 vitis 编写和以往大相径庭，笔者已经被坑惨了，所以建议后来者即使是查看这篇 2024 年的文章，如果时间过于久远，版本差距太大，也应该报有着审慎的态度来学习。</p><p>谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZCU102 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZCU102初步-使用 Petalinux 基于 BSP 构建 Linux</title>
      <link href="/posts/3/"/>
      <url>/posts/3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从上一篇从 0 开始构建 Linux 可以看出，有一些坑点和难点，可能最终难度上也会比较高，所以在对自定义需求不高的情况下，本篇提供一种基于 BSP 快速构建 Linux 的方式方法。</p><h2 id="BSP"><a href="#BSP" class="headerlink" title="BSP"></a>BSP</h2><p>BSP 即板级支持包，是定义如何支持特定硬件设备、设备组或硬件平台的信息集合。其介于底层硬件和上层软件之间，目的是为了向上层软件屏蔽下层硬件。</p><p>做个类比的话，笔者认为 .xsa 文件就归属于 BSP</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>依旧是基于 Petaliunx 2024.1，首先在官网下载 ZCU102 BSP，其位置在 Petalinux 下载界面滚轮下滑。</li></ul><p><img src="ZCU102BSP.png" alt="ZCU102"></p><ul><li><p>BSP 使用要通过 Petalinux 来进行，因此首先激活 Petalinux 环境。<code>source settings.sh</code></p></li><li><p><code>petalinux-create -t project -s &lt;BSP路径&gt;</code>，通过此命令即可使用下载好的 BSP 创建出对应的 Petalinux 工程。</p></li></ul><p><img src="BSP-create.png" alt="BSP-create"></p><ul><li>里面的 Pre-build 即为预先编译好的 images，可以直接拿去用。如果要求不高，至此就已经结束了。</li></ul><p><img src="prebuild.png" alt="prebuild"></p><ul><li>如果想进行一些自定义，里面也有 vivado 工程、也可以像前一篇一样进行 config、build。</li></ul><p><img src="vivado.png" alt="vivado"></p><h2 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h2><p>基于此 BSP，无需考虑上一篇最后提到的网卡问题，应该是开发人员已经解决了。</p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZCU102 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZCU102初步-使用 PetaLinux 从 0 构建 Linux</title>
      <link href="/posts/1/"/>
      <url>/posts/1/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>本文介绍了使用 Petalinux 在 ZCU102 硬核上启动 Linux 的方式方法。 PetaLinux 版本为 2024.1</p><h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>参照 ZCU102初步-HelloWorld 配置硬件资源，导出 .xsa 文件，需要注意一定配好 SD Card。 本文将使用 SD Card 来 Boot Linux。而非 HelloWorld 中的 QSPI 方法。</p><h2 id="PetaLinux"><a href="#PetaLinux" class="headerlink" title="PetaLinux"></a>PetaLinux</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>PetaLinux 是 Xilinx 开发出来为 FPGA 运行系统的一套懒人化工具链，其输入类似于 Vitis，为 .xsa 的硬件描述文件。其根据硬件描述文件为其生成启动 Linux 的一切程序，包括但不限于 fsbl、u-boot、linux 本体、设备树，并且将其合并为 Boot.bin，使得用户可以直接使用 Petalinux 的产物在 FPGA 开发板上启动 Linux。</p><h3 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h3><ul><li><p><strong>首先一定进入 PetaLinux 的<a href="https://docs.amd.com/r/en-US/ug1144-petalinux-tools-reference-guide/Installation-Requirements">用户手册</a>查找安装对应版本的 Petalinux 所需要的环境，在不符合要求的环境上运行 PetaLinux 出现任何奇怪报错都是可能的！</strong></p><p>笔者使用版本为 2024.1，Ubuntu 为 22.04.3 LTS</p><p><img src="PetaLinux安装需要.png" alt="PetaLinux安装需求"></p></li><li><p>在官网<a href="https://china.xilinx.com/support/download/index.html/content/xilinx/zh/downloadNav/embedded-design-tools.html">下载</a>安装和 Vivado 版本一致的 Petalinux，</p></li><li><p>将下载好的 <code>petalinux.run</code> 文件放置到想要安装到的目录下，为其添加执行权限，之后直接 <code>./petalinux.run</code> 运行安装程序。</p></li><li><p>安装程序会自动检测所需要的环境，如果不符合则会将缺失的环境提示出来，只需要对其一个个 <code>apt insntall</code> 即可。</p></li><li><p>安装完成后每次使用 Petalinux 前需要进入安装目录，手动 <code>source settings.sh</code> 来添加环境变量，嫌麻烦将该命令加入到 <code>~/.bashrc</code>中，每次运行终端将自动运行该语句。</p><p><img src="source.png" alt="source"></p></li><li><p>创建 PetaLinux 工程 <code>petalinux-create --t project --template &lt;PLATFORM&gt; --name &lt;PROJECT_NAME&gt;</code></p><p>可选的 Platform 有：versal、zynqMP（我们要用的）、zynq、microblaze </p><p>Project_name 将会作为文件夹名字出现。</p><p><img src="create.png" alt="Create"></p></li><li><p>将 .xsa 文件 和 .bit 文件复制到 <code>工程目录/project-spec/hw-description/</code> 下，将 .xsa 改名为 system.xsa，之后直接运行 <code>petalinux-config</code> 进行工程配置，当然也可以运行 <code>petalinux-config --get-hw-description &lt;PATH-TO-XSA-FILE&gt;</code>来手动指定 .xsa 文件位置。</p><p><img src="Config.png" alt="Config"></p></li><li><p>之后进入 menuconfig 界面配置 Linux、U-boot、设备树等，这里可以不配置，直接两次 ESC 退出配置界面。</p><p><strong>如果是笔记本键盘，可能会遇到按键不灵的情况，最好换一个外接键盘试试</strong> </p><p><img src="menuconfig.png" alt="menuconfig.png"></p></li><li><p>config 完成后运行 <code>petalinux-build</code> 来编译工程，完成之后，工程目录下将出现 images 文件夹，里面存放了诸如 linux.ub、u-boot.elf、fsbl.elf、rootfs 等产物。</p><p><img src="build.png" alt="build"></p></li><li><p>运行 <code>petalinux-package --boot --fsbl --fpga --u-boot --force</code> 将 fsbl、bit流、u-boot打包为 BOOT.bin。</p><p>这里没有明确指定，将会在工作目录内自动查找对应后缀。</p><p><img src="package.png" alt="package"></p></li></ul><h2 id="SD卡配置"><a href="#SD卡配置" class="headerlink" title="SD卡配置"></a>SD卡配置</h2><p>这里使用的 SD卡是真正的 SD卡、即大卡而非小卡，参照 <a href="https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842385/How+to+format+SD+card+for+SD+boot">How to format SD card for SD boot</a> 进行格式化，下文也会介绍</p><h3 id="SD-卡格式化"><a href="#SD-卡格式化" class="headerlink" title="SD 卡格式化"></a>SD 卡格式化</h3><p>将 SD 卡格式化为两个分区，一个是 较小的 BOOT 分区，分区类型为 FAT32、另一个是 较大的文件系统分区，分区类型为 EXT4。工具可以使用 <a href="https://www.diskgenius.cn/">DiskGenius</a></p><h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><ul><li><p>将 Boot.bin、Boot.scr、images.ul 拷贝到 BOOT 分区</p></li><li><p>将文件系统拷贝到文件系统分区，即使用 Images/rootfs.tar.gz。<code>dd if=rootfs.ext4 of=/dev/sd卡的文件系统分区名</code></p><p>例如 <code>dd if=rootfs.ext4 of=/dev/mmcblk0p2</code></p></li></ul><h2 id="上板验证"><a href="#上板验证" class="headerlink" title="上板验证"></a>上板验证</h2><p>参考这个网站，<a href="https://blog.csdn.net/linggan5you/article/details/115343477">zcu102启动方式配置</a></p><p>要想从sd卡启动，需要将拨码开关 1-4 设置为 <code>On off off off</code>。</p><p><img src="sd.png" alt="sd.png"></p><p>和 Helloworld 中提到的一样连接串口，插入 SD 卡。启动观察是否能够启动 Linux。</p><p>登录账户为 petalinux，密码会在第一次登录时进行设置。</p><h2 id="网卡添加"><a href="#网卡添加" class="headerlink" title="网卡添加"></a>网卡添加</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这里值得单写一下，是因为这里有一些坑点。</p><h3 id="Vivado"><a href="#Vivado" class="headerlink" title="Vivado"></a>Vivado</h3><p>双击 MPsoc 芯片，添加 GEM3 MIO 配置 64…75 </p><p>  <img src="GEM3.png" alt="GEM"></p><h3 id="Petalinux"><a href="#Petalinux" class="headerlink" title="Petalinux"></a>Petalinux</h3><ul><li><p>如果已经进行过编译，就调用 <code>petalinux-build -x mrproper</code> 删除编译目录和产物来清理工程</p></li><li><p>重新使用 <code>petalinux-config</code>，在 menuconfig 界面修改 <code>machine name</code> 从默认的 <code>Template</code> 改为 <code>zcu102-revb</code>，之后正常编译即可</p><p><img src="zcu102-revb.png" alt="zcu102-revb.png"></p><p>这个解决方案来源于 <a href="https://adaptivesupport.amd.com/s/question/0D52E00006hpsuISAQ/macb-ff0e0000ethernet-eth0-could-not-attach-to-phy?language=en_US">AMD论坛</a></p><p>也可以采用这个贴子里面加设备树的方式解决，但笔者用此方法编译会报错，所以还是用上一种比较好。</p><p>至于为什么改个名字就能解决，笔者只能将其归功于特定的名字会触发一些额外的设备树编译内容吧，从编译产物来看是这样。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZCU102 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZCU102初步-HelloWorld</title>
      <link href="/posts/62713/"/>
      <url>/posts/62713/</url>
      
        <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><p>本文讲述了 Xilinx Zynq UltraScale+ MPSoc ZCU102 从开箱到运行第一个程序-HelloWorld 的全部过程。</p><h2 id="机器自检"><a href="#机器自检" class="headerlink" title="机器自检"></a>机器自检</h2><p>如果是初次拿到 ZCU102 这块板子，个人非常建议在使用之前按照随箱附带的手册进行自检。因为对 ZCU102 的 QSPI Flash 进行烧写后，这段位于 QSPI Flash 自检程序将会被删除。</p><p>具体操作参看手册。</p><h2 id="Vivado-硬件设计"><a href="#Vivado-硬件设计" class="headerlink" title="Vivado 硬件设计"></a>Vivado 硬件设计</h2><p>以截止文章发表时最新的 Vivado 2024.1 为例</p><h3 id="安装注意事项"><a href="#安装注意事项" class="headerlink" title="安装注意事项"></a>安装注意事项</h3><p>由于涉及到了后续的软件开发，所以需要安装 Vivado SDK 该工具在 Vivado 2019.2 后合并到了 Vitis 中，所以需要安装 Vitis Embedded Development。</p><p>其次，由于基于 ZCU102 开发，所以 Production Devices 中需要使用 SoCs 和 UltraScale+</p><p>笔者使用的安装如下：</p><p><img src="Vivado安装图示.jpg" alt="Vivado安装图示"></p><h3 id="创建硬件工程"><a href="#创建硬件工程" class="headerlink" title="创建硬件工程"></a>创建硬件工程</h3><ol><li><p>打开 Vivado -&gt; Create Project</p><p><img src="CreateProject.jpg" alt="CreateProject"></p></li><li><p>Project Name 自行拟定</p><p><img src="ProjectName.jpg" alt="ProjectName"></p></li><li><p>Project Type 选择 RTL Project，勾选 Do not specify sources at this time。</p><p>因为我们不会用到 .v .sv 这样的 RTL 文件。</p><p><img src="RTL.jpg" alt="RTL"></p></li><li><p>Default Part 切换到 Boards，找到并选择 ZCU102 板卡</p><p><img src="ZCU102板卡选择.png" alt="ZCU102板卡选择"></p></li><li><p>最后配置如图，点击 Finish</p><p><img src="配置总结.png" alt="配置总结"></p></li></ol><h3 id="创建-MPSOC"><a href="#创建-MPSOC" class="headerlink" title="创建 MPSOC"></a>创建 MPSOC</h3><ol><li><p>由于 UltraScale+ MPSOC 都是已经配置好的，所以在 IP INTEGRATOR 下直接 Create Block Design 即可。 该选项将创建.bd文件</p><p><img src="BlockDesign.png" alt="BlockDesign"></p></li><li><p>Create Block Design 名字自选。</p><p><img src="CreateBlockDesign.png" alt="CreateBlockDesign"></p></li><li><p>开始进行作图式硬件设计，点击 ‘+’ 号。</p><p><img src="AddIP.png" alt="AddIP"></p></li><li><p>搜索 Zynq 选择如图所示的 IP 核。</p><p><img src="Zynq.png" alt="IP"></p></li><li><p>最终如图所示</p><p><img src="ZYNQ-MPSOC.png" alt="ZYNQ-MPSOC"></p></li></ol><h3 id="配置-MPSOC"><a href="#配置-MPSOC" class="headerlink" title="配置 MPSOC"></a>配置 MPSOC</h3><ol><li><p>双击 MPSOC 图标打开 MPSOC 配置界面。</p></li><li><p>配置 UART，由于创建的 MPSOC 只是 UltraScale+ 的，而不是针对 ZCU102 的，所以 MIO 的配置需要参考 ZCU102 的原理图，如下：</p><p>这里放一个 ZCU102 原理图<a href="https://bhpan.buaa.edu.cn/link/AA0BD2564A0DBF460B99519BEC24FEED21">下载链接</a>，需要可以自取。</p><p><img src="UART-MIO配置.jpg" alt="UART-MIO配置"><br><img src="配置UART.png" alt="配置UART"></p></li><li><p>其余配置如图，也可以参考 ZCU102 用户手册自行配置。</p><p><img src="其他配置.png" alt="其他配置"></p></li><li><p>DDR 配置需要注意一点，新版的 ZCU102 如果是镁光的话，可能会是 16bit 位宽的 DDR。所以不再能使用默认配置，需要进行修改。</p><p><img src="新版DDR.jpg" alt="新版DDR"></p><ul><li>首先点击默认的镁光 DDR，选择 YES<br><img src="默认镁光.png" alt="默认镁光.png"></li><li>修改 DRAM Device Capacity 为 8192，Row Address Count 为 16。剩下不变，点击 OK 完成所有配置。</li></ul></li><li><p>最后连接时钟线，防止报错</p><p><img src="时钟线.png" alt="时钟线"></p></li></ol><h2 id="生成-bit-流文件"><a href="#生成-bit-流文件" class="headerlink" title="生成 bit 流文件"></a>生成 bit 流文件</h2><ol><li><p>验证设计的正确性</p><p><img src="ValidateDesign.png" alt="ValidateDesign.png"></p><p>出现如下图所示，即为设计正确。</p><p><img src="ValidationSucceed.png" alt="ValidationSucceed"></p></li><li><p>verilog 化 bd 文件<br>切换到 Source 试图，点开 Design Sources 文件夹，右键 .bd 顶层文件，点击 Generate Output Products 生成输出产物，该选项会以 .v 的形式生成 .bd 的下一层，里面包含了该 .bd 使用的所有核。</p><p><img src="生成产物.jpg" alt="生成产物.jpg"></p><p>综合选项如下：</p><p><img src="综合选项.png" alt="综合选项.png"></p><p>其中，Global 代表全部综合，Out of context per IP 代表综合改变的 IP 核，Out of context per Block Design 代表综合改变的 bd 文件。</p></li><li><p>让 bd 可综合实现</p><p>和上一步类似，右键 .bd 顶层文件，点击 Create HDL Warpper，选择 Let vivado manage warpper and auto-update。前者将 .bd 用一个 .v 形式的 warpper 包裹起来，使其可以综合实现。后者决定了该 warpper 的生成是 vivado 自动生成的。</p><p><img src="Warpper选项.png" alt="Warpper选项.png"></p></li><li><p>生成 bit 流</p><p>到这一步，即可和一般开发流程一样直接点击 Generate Bitstream. vivado 会自动完成 综合、实现、生成比特流。</p><p><img src="生成比特流.png" alt="生成比特流.png"></p><p>耐心等待一会，可以查看右上角来看自己进行到了哪一步，出现下图即为生成成功</p><p><img src="比特流生成成功.png" alt="比特流生成成功"></p><p>此时已经在工程目录下生成了bit文件：xx/xx.runs/imple_1/xxx_wapper.bit</p></li></ol><h2 id="生成-xsa-文件"><a href="#生成-xsa-文件" class="headerlink" title="生成 xsa 文件"></a>生成 xsa 文件</h2><p>因为涉及到了 FPGA 上的软件开发，所以需要使用 vitis，而在 vivado 中对板子的配置就记录在了 xsa 文件中，有了 xsa 文件，在编写软件时就可以忽略硬件。具体生成方式如图：</p><p><img src="xsa操作路径.png" alt="xsa操作路径"></p><p><img src="ExportHardware.png" alt="ExportHardware"></p><p>是否勾选 bit 流则取决于是否用到了 PL，由于本文尝试烧写 Flash，也算是进行了修改所以勾选上，之前生成的 bit 流将会被复制到所选的目录。</p><h2 id="Vitis-软件设计"><a href="#Vitis-软件设计" class="headerlink" title="Vitis 软件设计"></a>Vitis 软件设计</h2><p>有了硬件描述的 xsa 文件，可以在此基础上进行软件开发。</p><h3 id="创建-platform-组件"><a href="#创建-platform-组件" class="headerlink" title="创建 platform 组件"></a>创建 platform 组件</h3><ol><li><p>首先利用 xsa 文件，因此要先将工作空间创建到我们之前保存 xsa 文件的位置。</p><p><img src="OpenWorkSpace.png" alt="OpenWorkSpace"></p></li><li><p>打开后，就要使用 xsa 文件来创建 Platform Component，此为 Vitis 使用 xsa 文件的方法。</p><p><img src="Platform-1.png" alt="Platform-1"></p><ul><li><p>Name and Location 中，Location 就是工作目录，名字随意。</p></li><li><p>在 Flow 中，选择 Hardware Design，点击 browse 来选择 xsa 文件</p></li></ul><p><img src="Platform-2.png" alt="Platform-2"></p><ul><li>之后在 OS and Processor 中，Vitis 会自动读取 xsa 配置，提供出可选项，我们只是开发一个程序，所以选择 standalone + cortexa53_0，即使用 ps 的 0 核，并且勾选 FSBL （理解为 bootloader）</li></ul><p><img src="OS.png" alt="OS"></p><ul><li><p>一路确定即可。</p></li><li><p>创建好后 点击一下 build 将构建出板子对应的 fsbl.elf,出现对号此步骤即完成，在 Output - plaform - sw - boot 下将看到产物。</p></li></ul><p><img src="BuildFSBL.png" alt="BuildFSBL"></p></li></ol><h3 id="创建-helloworld-示例"><a href="#创建-helloworld-示例" class="headerlink" title="创建 helloworld 示例"></a>创建 helloworld 示例</h3><ol><li><p>回到欢迎页，点击 Examples </p><p><img src="HWexample.png" alt="HWexample"></p></li><li><p>选择 Hello World ，点击 + 号，之后的 Name and Location 和前面类似，Hardware 选择刚才创建好的 Platform, domain 选择刚才创建好的 Platform 里面的 CPU（a53_0），完成即可。</p><p><img src="HelloWorld.png" alt="HelloWorld"></p></li><li><p>Build 一下 创建好的 Hello world，此时，所有的编写工作就都完成了，接下来就是烧写和启动。</p><p><img src="BuildHW.png" alt="BuildHW"></p></li></ol><h3 id="创建-Boot-bin"><a href="#创建-Boot-bin" class="headerlink" title="创建 Boot.bin"></a>创建 Boot.bin</h3><p>直接点击 Hello world 下的，Create Boot Image，该选项直接按照顺序将 fsbl + wrapper.bit + hello_world.elf 合在一起生成 Boot.bin，只需要指定输出目录即可。</p><p>  <img src="CBootImage.png" alt="CBootImage"></p><h2 id="烧写和启动"><a href="#烧写和启动" class="headerlink" title="烧写和启动"></a>烧写和启动</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><img src="ZCU102示意图.png" alt="ZCU102示意图"></p><ol><li><p>首先按照图示连接 uart、jtag 线，jtag 用于烧写 QSPI Flash，uart 用于串口通信，连接后打开电脑的设备管理器，理应出现下面的设备：</p><p><img src="COM示意.png" alt="COM示意"></p><p>其中，COM1通信端口对于 jtag，其余四个对应 uart。如果只有通信端口，那么则可能是本机没有安装 usb 转 uart 的驱动，可以到这里来安装 <a href="https://www.silabs.com/developers/usb-to-uart-bridge-vcp-drivers"><br>CP210x USB to UART Bridge VCP Drivers</a>. 安装完即可正常显示。</p></li></ol><ol><li><p>下载一个与串口交互的软件，这里使用 <a href="https://mobaxterm.mobatek.net">MobaXterm</a>，连接到 uart0 串口，即上图中的 Interface 0</p><p><img src="MobaXterm.png" alt="MobaXterm"></p></li></ol><h3 id="烧写"><a href="#烧写" class="headerlink" title="烧写"></a>烧写</h3><ol><li><p>回到 Vitis，查看是否 Vitis 识别到了 Jtag，点击导航栏的 Vitis - Target Connections。</p><p><img src="TargetConnection-1.png" alt="TargetConnection-1"></p></li><li><p>双击 Local，打开配置界面，点开 Advance，观察是否有设备出现，如果有，则说明 Vitis 成功识别到了该 FPGA 板子</p><p><img src="TargetConnection-2.png" alt="TargetConnection-2"> </p><p><img src="TargetConnection-3.png" alt="TargetConnection-3"></p></li><li><p>同样的，点击导航栏的 Vitis - Program Flash，选择好刚才要启动的 Boot.bin，Flash 模式写为很早之前在硬件配置的 Dual Para。Flash Density 可以随意。</p><p><img src="ProgramFlashMemory.png" alt="ProgramFlashMemory"></p></li></ol><ol><li><p>Progarm 启动后可能会遇到报错，如果遇到这样的报错：</p><p><img src="乱码报错.png" alt="乱码报错"></p><p>则一般实际上的报错是：</p><p><img src="实际报错.png" alt="实际报错"></p><p>这个问题比较抽象，解决方法是右键桌面图标 Vitis Console，以记事本编辑，删掉下图中的两个空格：</p><p><img src="解决方法.png" alt="解决方法"></p></li><li><p>等待烧写，可以在界面看到烧写进度，出现如下图类似的输出即为烧写成功。</p><p><img src="烧写成功.png" alt="烧写成功"></p></li></ol><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>  关掉 ZCU102 板子，将 MobaXterm 打开，连接到 UART0 ，启动 ZCU102 观察是否有下图输出，有则证明全过程正确，本文结束。</p><p>  <img src="结果展示.png" alt="结果展示"></p>]]></content>
      
      
      <categories>
          
          <category> FPGA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZCU102 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hyper-V HCN 配置端口映射</title>
      <link href="/posts/1054/"/>
      <url>/posts/1054/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>windows 开启 Hyper-V 后，会创建一个如图所示的默认虚拟 Switch 用于向虚拟机提供网络：<br><img src="Default-Switch.png" alt="DefaultSwitch"></p><p>上图是 Hyper-V 管理器的界面，如图所示，它指示这个默认网络使用 NAT 向虚拟机提供网络，事实上，它使用的是 NAT 的丐版 —— ICS。</p><div class="note purple no-icon flat"><p>究竟两者有什么区别呢？在 Windows 2000 的帮助文件中 ICS 和 NAT 分别叫做 Internet 的转换连接和路由连接，其实说白了 ICS 就是 NAT 的简化版，使用 ICS 无需理解 IP 地址和路由方面的一些知识，并且提供一种局域网中使用 Windows 2000 路由器共享 Internet 的简化配置，不过 ICS 可能不允许局域网和 Internet 主机之间所有的 IP 通信，如《暗黑破坏神》一类的多玩家游戏、实时通讯及其他对等服务，如果在公用 Internet上使用专用地址或同时使用同一端口号，这些应用程序就会中止。而 NAT 的配置需要有关于IP地址和路由配置方面的知识，它的配置比 ICS 要复杂，它允许在局域网和 Internet 主机间所有的IP通信。此外，ICS 只能使用一个合法的公用IP地址，而 NAT 可以通过配置地址池的方式使用ISP提供的多个合法的公用IP地址供客户机共享。</p></div><p>此外，Hyper-V HCN 配置端口映射，要求 Switch 的类型为真正的 NAT 类型，这就带出了这篇文章 —— 如何利用 Hyper-V HCN 成功配置端口映射。</p><h1 id="创建-Switch"><a href="#创建-Switch" class="headerlink" title="创建 Switch"></a>创建 Switch</h1><p>因为默认的网络的类型为 ICS，因此直接在现有网络上进行配置成为了奢望，需要为此重新创建一个网络。参考<a href="https://learn.microsoft.com/en-us/virtualization/api/hcn/hns_schema">HCN-JSON-Guide</a>进行配置。</p><p>一个可用的示例配置如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;SchemaVersion&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Major&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Minor&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;NATTest&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Type&quot;</span>  <span class="punctuation">:</span> <span class="string">&quot;NAT&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Ipams&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Dhcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Subnets&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;IpAddressPrefix&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;192.168.100.0/24&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;Routes&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;NextHop&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;192.168.100.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;DestinationPrefix&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;0.0.0.0/0&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;MacPool&quot;</span><span class="punctuation">:</span>  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Ranges&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;EndMacAddress&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;00-15-5D-52-CF-FF&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;StartMacAddress&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;00-15-5D-52-C0-00&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure> <ol><li>SchemaVersion 为 JSON SchemaVersion 版本</li><li>Name 为将要创建的虚拟 Switch 名字。</li><li>Type 为将要创建的虚拟 Switch 类型，这里要写为 NAT。才能让下文的 EndPoint 成功生效。</li><li>Ipams 配置子网参数。</li><li>MacPool 配置该虚拟 Switch 可为连接到其的 EndPoint 的 MacAddress。</li></ol><h1 id="配置-EndPoint"><a href="#配置-EndPoint" class="headerlink" title="配置 EndPoint"></a>配置 EndPoint</h1><p>创建好 NAT 类型的 Switch 后，就可以创建 EndPoint 连接到该 Switch，虚拟机则连接到该 EndPoint。同样参考<a href="https://learn.microsoft.com/en-us/virtualization/api/hcn/hns_schema">HCN-JSON-Guide</a>进行配置。</p><p>一个可用的示例配置如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;SchemaVersion&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;Major&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;Minor&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Sample&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;HostComputeNetwork&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AD7CE019-F3DB-463F-9E57-9164583F6C03&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;MacAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;00-15-5D-52-C1-89&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;Policies&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;Type&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;PortMapping&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;Settings&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;Protocol&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;InternalPort&quot;</span> <span class="punctuation">:</span> <span class="number">22</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;ExternalPort&quot;</span> <span class="punctuation">:</span> <span class="number">22</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span>   </span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure> <ol><li>HostComputeNetwork 填写 NAT Switch 的 GUID</li><li>MacAddress 填写为 NAT Switch 提供的 MacPool 中的任意一个 MacAddress</li><li>通过 Policies 的 PortMapping 配置端口映射</li><li>Protocol 指定端口映射在哪个协议上进行，这里的 6 为 TCP</li><li>InternalPort 指定虚拟机暴露的端口</li><li>ExternalPort 指定Host暴露的端口</li></ol><p>效果是，虚拟机 22 端口被转换到了 Host 的 22 端口上。</p><h1 id="组装这些配置"><a href="#组装这些配置" class="headerlink" title="组装这些配置"></a>组装这些配置</h1><p>这里利用微软 HCN 的 API 即可完成</p><ol><li>HcnCreateNetwork 创建该 NAT 网络并启动。</li><li>HcnCreateEndpoint 创建该 EndPoint 并连接到参数所传入的网络上，并启动。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">unique_hcn_network virtual_net_work;</span><br><span class="line">  wil::unique_cotaskmem_string result;</span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(S_OK, <span class="built_in">HcnCreateNetwork</span>(network_guid, kNetworkSettings.<span class="built_in">c_str</span>(), virtual_net_work.<span class="built_in">put</span>(), result.<span class="built_in">put</span>()));</span><br><span class="line">  <span class="comment">// Transform GUID format EndpointId</span></span><br><span class="line">  GUID endpoint_id_guid;</span><br><span class="line">  <span class="built_in">StringToGuid</span>(endpoint_id, endpoint_id_guid);</span><br><span class="line">  <span class="comment">// Configure endPoint</span></span><br><span class="line">  unique_hcn_endpoint virtual_end_point;</span><br><span class="line">  <span class="comment">// Create endPoint in network</span></span><br><span class="line">  <span class="built_in">EXPECT_EQ</span>(S_OK, <span class="built_in">HcnCreateEndpoint</span>(virtual_net_work.<span class="built_in">get</span>(), endpoint_id_guid,</span><br><span class="line">      end_point_setting.<span class="built_in">c_str</span>(), virtual_end_point.<span class="built_in">put</span>(),</span><br><span class="line">                                    result.<span class="built_in">put</span>()));</span><br></pre></td></tr></table></figure> <p>具体可以参考，<a href="https://learn.microsoft.com/en-us/windows-server/networking/technologies/hcn/hcn-top">HCN-API-Sample</a>学习。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>最近在学习 Hyper-V 的 HCN 、HCS、HDV，个人认为这是一个比较有潜力的虚拟化实现方案，至少在 API 封装上微软将其做到了简单易用，简单组装一些 API，学习其 JSON Schema 即可用 Hyper-V 启用虚拟机。</p><p>这里有一些参考实现：</p><ol><li><a href="https://github.com/microsoft/hcsshim#:~:text=Windows%20-%20Host%20Compute%20Service%20Shim.%20Contribute%20to">Hcsshim</a>,GO 语言实现，较完备。</li><li><a href="https://github.com/M2Team/NanaBox">Nanabox</a>,C++ 实现。简单易用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 腾讯 PCG 实习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyper-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译总结感想</title>
      <link href="/posts/6663/"/>
      <url>/posts/6663/</url>
      
        <content type="html"><![CDATA[<p>编译总结</p><h2 id="课程收获"><a href="#课程收获" class="headerlink" title="课程收获"></a>课程收获</h2><p><img src="提交次数.jpg" alt="161"><br>161次提交记录…….在大二的时候久闻编译强度之大，终于在这一学期也是让我真正的亲身体会了一把，但回首这几个月，除了De不出Bug时那绝望的心情，我更多的时候收获的是每一次提交时的自豪与满足。每一次De出Bug、实现功能的成就感。对编译器的理解也是从一开始抓着别人问我该做什么，变成了我知道我该做什么，我写的哪里还有不足等等。这些提升都是实打实的提升。我对编译器的理解也是随着我实践的深入逐渐清晰，原来大一大二时在我眼里十分神秘的编译器也逐渐变得明朗。这种成长的感觉非常棒，足以抵消强度之大的流言。</p><p>而且，我认为大家都说编译强度大，我现在更多的倾向是他们没有合理安排自己的时间所导致的，因为我虽然提交次数很多，但我在一学期中并没有特别明显的感受到编译实验带来的时间上的压力，这是因为我对此在开学就有一定的规划，我听取了学长们的建议，结合自己的实际下定决心从开学开始开发，到国庆就完成了不带优化的编译器的实现。这让我后面的时间极其宽松，我甚至可以放着编译实验一周而去做更为急迫的事情。也因此虽然在最后我的时间也不是很充足，但我也不像很多人一样完全缺乏时间进行优化。让我得以取得了一个较好的竞速成绩——竞速第六。也正因为此，我觉得编译原理这门课也在教导我们要学会时间管理，强度大或许只是我们的时间管理不够到位，导致在学期末没有时间而已。</p><p><img src="基本功能完成.jpg" alt="161"><br>其次我想在编译课程的末尾结合我的编译器谈谈编译的五大过程——词法分析、语法分析、语义分析、中间代码生成及优化、目标代码生成及优化。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析建立了编译器与输入文件之间的桥梁，将其转换为了编译器能够识别的单词。在我的实现中，我采用正则表达式去匹配单词。完成了这一部分的工作。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>利用前面生成的单词作为输入，结合文法生成语法树。我实现的是理论所讲的递归下降分析法，对每个非终结符都建立一个类并实现解析方法，这些非终结符之间互相调用完成语法树建立。在我的实现中，我不仅对每个非终结符建立了类，为了实现优雅，对于一些较复杂的产生式，我也生成了一些新的非终结符对其进行处理：<br>并对这一阶段会产生的语义错误进行了处理。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>在这里我单独进行了符号表的建立，而不是边建立符号表边生成中间代码，我这么做是为了中间代码生成的顺畅进行，让其可以不考虑错误的执行。同样的，我从递归下降中学到了递归相互调用的思路，调用每个非终结符下的RunSymbolBuilder来建立符号表管理并找到语义错误。</p><h3 id="中间代码生成及优化"><a href="#中间代码生成及优化" class="headerlink" title="中间代码生成及优化"></a>中间代码生成及优化</h3><p>生成我同样在语法树上进行，对每一个非终结符都实现了中间代码生成的方法。也是一种递归互相调用。我没有使用LLVM作为我的中间表达，我的中间表达设计参考了Yu-Ge编译器，使用了更接近Mips目标代码的中间表达，也是为了生成目标代码时的方便。这里我收获最大的是优化部分，如果说前面的设计包括后续的目标代码生成还有一点固定的思路在里面，那么代码优化就是天高任鸟飞的局面，只要有了点优化的想象力，都可以通过代码实现。我是非常喜欢这种事情的，而且在优化的过程中我也参考了很多前人的优化方法，阅读了许多英文论文，虽然读起来吃力，但我确实惊叹于他们的思路之巧妙，也给了我很多优化的启示。最终我完成了如下的优化：</p><p>更多的细节由于和优化文档重合，详情可以见我的优化文档。</p><h3 id="目标代码生成及优化"><a href="#目标代码生成及优化" class="headerlink" title="目标代码生成及优化"></a>目标代码生成及优化</h3><p>这里就是根据目标平台的指令集进行指令选择，将自己的中间代码转换为目标平台可以执行的汇编程序。在我的实现中，我的目标平台是Mips，对Mips指令进行了选择和优化，并做了乘除和图着色、OPT分配优化。</p><p>除此之外，我继续发扬了我在CO、OO的习惯，继续写了对编译器进行自动化测试的程序。实现了自动用gcc编译运行文件得到结果与我的编译器运行结果进行对比的功能。搜集了今年和去年两年的测试库一共141例作为了测试程序，由于去年的测试库为while语句，我还对我的测试程序集成了自动处理while为for的功能：</p><p><img src="自动处理.png" alt="自动处理"></p><p>这个测试程序帮助了我很多，大大节约了我测试的时间并极大的提高了我测试的强度。</p><p>总而言之，通过实验实打实的加深了我对理论的理解，感谢编译原理这门课提供的机会。</p>]]></content>
      
      
      <categories>
          
          <category> 北航编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mips-编译优化总结</title>
      <link href="/posts/31035/"/>
      <url>/posts/31035/</url>
      
        <content type="html"><![CDATA[<h2 id="优化实现概览"><a href="#优化实现概览" class="headerlink" title="优化实现概览"></a>优化实现概览</h2><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h3><ul><li>函数内联<h3 id="中端"><a href="#中端" class="headerlink" title="中端"></a>中端</h3></li><li>单赋值形式</li><li>全局代码移动</li><li>全局值编号<ul><li>全局常量折叠</li><li>代数恒等变换 </li><li>等价指令变换</li></ul></li><li>激进死代码删除</li><li>基本块合并<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3></li><li>全局寄存器图着色分配</li><li>局部寄存器OPT分配</li><li>立即数乘除优化</li><li>指令选择优化</li><li>寄存器选择优化<h2 id="具体优化实现"><a href="#具体优化实现" class="headerlink" title="具体优化实现"></a>具体优化实现</h2><h3 id="函数内联"><a href="#函数内联" class="headerlink" title="函数内联"></a>函数内联</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4>函数内联有两种实现方式：</li></ul><ol><li>写在中端，将函数基本块插入<code>Call</code>的位置，删除<code>Call</code>语句，处理<code>Return</code>，变量重命名。</li><li>写在前端，在生成中间代码时如果遇到了<code>Call</code>节点，直接生成一遍该<code>Call</code>调用函数的中间代码。<h4 id="难点与解决方案"><a href="#难点与解决方案" class="headerlink" title="难点与解决方案"></a>难点与解决方案</h4>第一种是最开始想到的方案，好处是可以插入优化后的函数，但比较大的问题是变量的重命名，处理起来比较麻烦，稍有不慎就会出错。</li></ol><p>因此我们选择第二种方案作为解决方案，由于中间代码生成的过程本来就是在不断的创建变量、使用变量，将内联做到此处可以让其和正常的代码归一处理，只需要考虑该函数是否适合内联即可。</p><p><img src="函数内联.jpg" alt="函数内联"></p><p>如图，<code>ToIntermediate</code>即为我在语法树生成中间代码的方法，在这里展示的是<code>CallNode</code>中的<code>ToIntermediate</code>，在这里我调用了<code>FuncDefNode</code>的<code>ToIntermediate</code>将其内联到了代码中。</p><p>需要注意的一点是，第二种方法<strong>同样</strong>有着缺陷，做在了前端意味着我们做在了优化之前，而我们编译的语言中，函数传递为值传递，内联进去后我们仍然要保持这个特性，即在内联函数中，我们对参数的修改不能最终被优化为对传参变量的修改。这需要特殊判断，因此我引入了图中的<code>OptWhiteList</code>，将实参赋值给形参这种语句加入白名单，使其不被优化，这样会导致后续对形参的所有赋值均不会被优化到直接对原变量赋值。</p><h3 id="单赋值形式"><a href="#单赋值形式" class="headerlink" title="单赋值形式"></a>单赋值形式</h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><p>我参考了课程设计网站的<code>MemToReg</code>，和虎书的<code>dominate</code>计算。</p><h4 id="难点和解决方案"><a href="#难点和解决方案" class="headerlink" title="难点和解决方案"></a>难点和解决方案</h4><p>由于前人在此做了太多的努力与积累，这里几乎不存在什么难点，按照给定的伪代码理解然后实现即可，主要就是时间投入的问题。</p><p>不过如果想要理解这些这些伪代码背后的原理和作用，可能需要结合编译理论的学习和参考虎书。</p><h3 id="全局值编号"><a href="#全局值编号" class="headerlink" title="全局值编号"></a>全局值编号</h3><h4 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h4><p>我参考了<code>Cliff Click</code>的<code>Global Code Motion Global Value Numbering</code>这篇论文，按照其给出的伪代码进行实现。</p><h4 id="难点和解决方案-1"><a href="#难点和解决方案-1" class="headerlink" title="难点和解决方案"></a>难点和解决方案</h4><h5 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h5><p>全局值编号的实现<code>Cliff Click</code>没有给予具体的实现伪代码，需要我们自行设计实现。且单全局值编号并不会给我们的代码起到什么优化作用，我们一般要同时实现在此情景下的常量折叠、代数恒等变换、等价指令变换。</p><p>其次，并不是每一条中间代码、每一种变量都适合进行三种优化，例如对刚才内联中提到的白名单内的中间代码，我们就只适合对其进行常量折叠。再比如我们不适合对全局变量进行优化，否则会导致值错误。</p><p>然后，访问块的顺序也是需要考量的，访问顺序不当会出现诸如用后面的变量替换前面的变量导致段错误等诸多问题。</p><p>最后，我们需要防止优化陷入循环，导致优化不能正常退出的问题产生。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><p><img src="全局值编号.jpg" alt="全局值编号"></p><p>这是我将三种优化结合到一起的函数，先尝试折叠，再尝试代数恒等变换，最后再尝试等价指令变换。</p><p>同样，这里的<code>if else</code>也展示了我对于不同指令的处理方式有所不同，解决第二个问题的指令选择性优化，之后在具体优化的方法中检测变量类型，如果是全局就不进行优化，解决变量选择性优化问题。</p><p><img src="逆后序遍历.jpg" alt="DFS_WALK"></p><p>其次是访问顺序问题，RPO（逆后序遍历）其实就是对树进行后序遍历的反向输出。我们只需用<code>DFS</code>来后序遍历树，最后反向输出即可得到<code>RPO</code>序列，采用这种方式进行的遍历我们可以保证访问子节点时父节点一定先被访问过。</p><p>最后的陷入循环主要通过两方面解决：</p><ol><li>指定我们期望的优化结果：常量为先/变换为先。这样不会出现常量和变换干扰互相死循环转化的问题。</li><li>下一个优化使用上一个优化的结果进行优化，即图中展示的<code>element</code>。</li></ol><h3 id="全局代码移动"><a href="#全局代码移动" class="headerlink" title="全局代码移动"></a>全局代码移动</h3><h4 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h4><p>我参考了<code>Cliff Click</code>的<code>Global Code Motion Global Value Numbering</code>这篇论文，按照其给出的伪代码进行实现。</p><h4 id="难点和解决方案-2"><a href="#难点和解决方案-2" class="headerlink" title="难点和解决方案"></a>难点和解决方案</h4><h5 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h5><p><code>Cliff Click</code>在论文中给出的伪代码有误，需要结合其语言描述进行正确化。不能盲目实现其伪代码。这就需要一定的英文阅读能力+理解能力。</p><p>全局代码移动需要极其严苛的正确性，这是因为对代码的移动本来就是一个高危行为，且全局值编号的优化几乎100%会破坏程序的正确性，需要全局代码移动来修复正确性，所以全局代码移动的正确实现就极为关键。</p><p>全局代码移动依然要考虑某种指令能否移动的问题。这需要小心操作。</p><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p><img src="Find_LCA.jpg" alt="Find_LCA"></p><p><code>Cliff Click</code>这里给出的伪代码有误，注释强调<code>a is deeper than b</code>，但是代码却是<code>a.dom_depth &lt; b.dom_depth</code>，需要理解并修改。（当然可能是我能力不够）</p><p>为保证正确实现，至少需要保证理解全局代码移动的原理和正确性。此可以通过慢慢阅读论文，慢慢理解来最终达到。</p><p>指令是否移动，我最终设计了如下不能移动的指令类：</p><ul><li>jump和返回指令不可移动</li><li>phi指令不可移动</li><li>branch指令不可移动</li><li>call和push指令不可移动</li><li>返回值赋值语句不可移动</li><li>输入语句不可移动</li><li>store语句不可移动</li><li>load语句不可移动</li><li>Global赋值语句不可移动</li><li>Global使用语句不可移动</li></ul><p>简要说明一下不太好理解的：</p><ol><li>call和push因为涉及其他函数，我们不能保证在不同位置执行外部指令流会不会出现差异，所以不移动。</li><li>由于<code>$v0</code>的不可靠性，我在函数每次返回后都会立刻将返回值存到一个临时变量里，这个指令显然不能移动，必须时刻跟在<code>call</code>后。</li><li>store和load涉及内存读写，同样的，我们不能保证在不同位置对内存读写会不会和原指令流产生差异，所以不移动。</li><li>Global因为在别的函数中同样使用，所以也不能保证在不同位置执行外部指令流会不会出现差异。</li></ol><h3 id="激进死代码删除"><a href="#激进死代码删除" class="headerlink" title="激进死代码删除"></a>激进死代码删除</h3><h4 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h4><p>参考了课程网站思路和<a href="https://www.cnblogs.com/lixingyang/p/17728846.html">激进死代码删除</a>这篇文章。</p><h4 id="难点-2"><a href="#难点-2" class="headerlink" title="难点"></a>难点</h4><p>控制依赖的引入：要实现激进的死代码删除，需要我们实现控制依赖的计算，这又引入了新的复杂度。</p><p>控制流的改变：在我的实现中，我会对无用的控制流语句进行删除，改变了控制结构，这显然也是十分危险的动作，且每次修改都会导致已经建立好的流图失效，但一次优化中会多次利用到流图的信息。如何保证改变前后的控制结构等价且维护流图是一个问题。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>学习控制依赖，有一篇文章很生动形象：<a href="https://zhuanlan.zhihu.com/p/658705992">零基础入门控制依赖图构建的理论与实践</a>，通过这个我彻底理解了控制依赖的作用。</p><p><img src="处理失效的控制和跳转.jpg" alt="处理失效的控制和跳转"></p><p>如图，对于一个基本块经过死代码分析后失效的控制流语句，会赋予一个新的跳转，跳到它的后继中第一个活跃的块上。需要在反支配树上寻找（反支配树就是根据CFG的反图建出的支配树）。</p><p>对流图的维护我采取了双重保险的形式：</p><ol><li>改变控制流时维护当前流图的前驱后继关系。</li><li>退出激进死代码优化时重新构建新的流图，舍去旧流图。</li></ol><p>这样一定可以保证流图的正确性，虽然会引入一定的冗余。</p><h3 id="基本块合并"><a href="#基本块合并" class="headerlink" title="基本块合并"></a>基本块合并</h3><h4 id="实现方式-5"><a href="#实现方式-5" class="headerlink" title="实现方式"></a>实现方式</h4><ol><li>相邻块跳转，一定可以删去跳转语句。</li><li>检查该块（记为A）跳转指向的块的前驱是否只有一个（A），如果只有一个，那么可以合并这两个块。</li></ol><h4 id="难点-3"><a href="#难点-3" class="headerlink" title="难点"></a>难点</h4><p>难点就是要想到上述的实现方式，特别是合并的条件，过度合并会导致问题的出现。</p><h3 id="全局寄存器图着色"><a href="#全局寄存器图着色" class="headerlink" title="全局寄存器图着色"></a>全局寄存器图着色</h3><h4 id="实现方式-6"><a href="#实现方式-6" class="headerlink" title="实现方式"></a>实现方式</h4><p>虎书有更为精细复杂的图着色实现方式，可以减轻<code>Move</code>指令带来的负向优化。</p><p>时间原因，我采用了理论所学的图着色实现方式：</p><ol><li>def-use分析</li><li>in-out分析</li><li>构建冲突图</li><li>启发式着色</li></ol><h4 id="难点-4"><a href="#难点-4" class="headerlink" title="难点"></a>难点</h4><ol><li>需要考虑着色的变量范围。</li><li>冲突的识别。</li></ol><h4 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>全局变量不能参与图着色，最主要的问题是，图着色是不写回的，而全局寄存器显然需要写回，因为要在多个函数中用到。这从一开始就已经产生了冲突。</li><li>不跨块活跃的不参与图着色，对其的分配无意义。</li><li>冲突的识别<strong>不能仅仅参考<code>In-Out</code></strong>，需要用比较精细的分配方式——在a的定义点b活跃。这里就是一个仅仅参考<code>In-Out</code>导致分配错误的例子：</li></ul><p><img src="In-Out.jpg" alt="In-Out"></p><p>如果仅仅从In集分析，<code>Variable_6_2</code>一定与<code>Variable_8_7</code>不冲突，可以共用一个寄存器，图中的分配也是这么做的，但显然是错误的，这就是因为<code>Variable_6_2</code>和<code>Variable_8_7</code>其实是冲突的，这需要使用上述提到的精细的分析才能找出冲突。</p><h3 id="局部寄存器OPT分配"><a href="#局部寄存器OPT分配" class="headerlink" title="局部寄存器OPT分配"></a>局部寄存器OPT分配</h3><h4 id="实现方式-7"><a href="#实现方式-7" class="headerlink" title="实现方式"></a>实现方式</h4><p>寄存器可以用<code>Cache</code>去理解，那么我们就可以参考<code>Cache</code>的分配方式。<code>Cache</code>有一个理想的分配方式——OPT分配，所有的分配算法都是为了接近这种分配，但是这种分配是不可能达到的，因为<code>Cache</code>不可能知道未来的信息。</p><p>但在编译的寄存器分配中，我们是可以知道的。因此我们可以实现<code>Cache</code>分配的极限——Opt优化。</p><p>替换寄存器时，我们可以向后查看该基本块对于变量的使用情况，替换掉最晚使用的寄存器。</p><h4 id="难点-5"><a href="#难点-5" class="headerlink" title="难点"></a>难点</h4><p>本身没有什么难度，难度来源于如果想让全局变量加入局部寄存器的分配，会引入很多的问题：</p><ol><li>在原来的设计中，局部寄存器也不需要在退出基本块前写回，全局变量显然需要。</li><li>也正是由于有（1）的区别所在，所以在OPT分配的时候全局变量控制的局部寄存器和其他变量控制的局部寄存器是有区别的。引入了复杂度。<h4 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h4></li><li>添加写回逻辑，只针对寄存器分配的对线是全局寄存器时。</li><li>OPT逻辑设计如下图(参考注释)<br><img src="OPT调度.jpg" alt="Opt调度"></li></ol><h3 id="立即数乘除优化"><a href="#立即数乘除优化" class="headerlink" title="立即数乘除优化"></a>立即数乘除优化</h3><h4 id="实现方式-8"><a href="#实现方式-8" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>参考<code>Division by Invariant Integers using Multiplication</code></li><li>参考课程网站教程</li><li>参考Yu-Ge编译器</li></ul><h4 id="难点-6"><a href="#难点-6" class="headerlink" title="难点"></a>难点</h4><p>如果想要理解此优化，确实是极其消耗时间的事情。</p><h4 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h4><p>时间太过仓促，我也只是草草理解了一下就按照伪代码和参考Yu-Ge编译器进行了实现。</p><h3 id="指令选择优化"><a href="#指令选择优化" class="headerlink" title="指令选择优化"></a>指令选择优化</h3><h4 id="实现方式-9"><a href="#实现方式-9" class="headerlink" title="实现方式"></a>实现方式</h4><p>对mars需要展开的指令进行优化，尽量减轻展开量。</p><h4 id="难点-7"><a href="#难点-7" class="headerlink" title="难点"></a>难点</h4><p>如何寻找到更优秀的展开是一个问题。</p><h4 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h4><p>这和Mips指令强相关，今年我参加了龙芯Mips赛道，对此也有一定的理解，手动写了一些。</p><p>这和Mips指令强相关，因此我参考了前高阶计组助教——陈昊学长对此的优化。</p><p><img src="加载常数.jpg" alt="加载常数"></p><p>例如对于常数的加载，就可以根据范围选择不同的加载方式。这里就涉及了<code>Mips</code>指令集中<code>Offset=16</code>等的知识。</p><h3 id="寄存器选择优化"><a href="#寄存器选择优化" class="headerlink" title="寄存器选择优化"></a>寄存器选择优化</h3><h4 id="实现方式-10"><a href="#实现方式-10" class="headerlink" title="实现方式"></a>实现方式</h4><p>主要是将加载0值到寄存器的操作直接使用<code>$0</code>替换。</p><h4 id="难点-8"><a href="#难点-8" class="headerlink" title="难点"></a>难点</h4><p>注意细心即可。</p><h4 id="解决方案-7"><a href="#解决方案-7" class="headerlink" title="解决方案"></a>解决方案</h4><p>多进行测试，避免写出问题。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在竞速排名中，我的排名是第六。</p><p>说这个不是一个好的成绩有些过分，但实话说我还是对此有一定的遗憾，因为很多很棒的优化我因为时间的关系都没有实现，例如对于公开的测试用例，如果我做了循环优化，对那个用例的数组的运算完全可以优化到直接赋值的地步。又比如对于全局变量的初始化，完全可以借助<code>.space</code>进行初始化，这些都因为时间关系，在我的编译器中没有实现。</p><p>很多人说做优化性价比不高，因此大多都摆烂了，但对我来说，做优化是完全的出于兴趣，我觉得看着自己的目标代码逐渐瘦身，<del>逐渐变得我都看不明白但就是正确的</del>，是一件很酷的事情。但就是时间太过于紧张只能让我做出取舍。这让我感到遗憾。</p><p>不过，这也不是结束，这更像是一个开始。竞速第六便是一个很好的开始，希望以后还有机会，有更多的时间做这种类似的事情吧！</p><p>感谢一学期所有编译助教的辛苦付出，申哥的挽大厦之将倾，陈昊学长的分享与帮助。</p>]]></content>
      
      
      <categories>
          
          <category> 北航编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARMv8 学习</title>
      <link href="/posts/50082/"/>
      <url>/posts/50082/</url>
      
        <content type="html"><![CDATA[<h2 id="ARMv8-初步"><a href="#ARMv8-初步" class="headerlink" title="ARMv8 初步"></a>ARMv8 初步</h2><ul><li>ARMv8 定义了两种执行状态，AArch64 和 AArch 32</li><li>AArch64 最多可以在寄存器中传递 8 个参数</li><li>AArch32 最多可以在寄存器中传递 4 个参数  </li><li>ARMv8 中，执行发生在 4 个异常级别之一，异常级别决定了特权级别。</li></ul><div class="table-container"><table><thead><tr><th>异常级别</th><th>解释</th></tr></thead><tbody><tr><td>EL0</td><td>普通用户的用户程序</td></tr><tr><td>EL1</td><td>操作系统内核，通常说是有特权的</td></tr><tr><td>EL2</td><td>Hypervisor(虚拟机管理程序)</td></tr><tr><td>EL3</td><td>底层固件，包括安全监视器</td></tr></tbody></table></div><ul><li>ARMv8 也提供了两种安全状态：安全状态和非安全状态，这种保护使得普通操作系统和受信操作系统可以安全的同时运行在同一操作系统上。</li><li><p>ARMv8 中 EL3 的安全监视器充当普通和安全世界之间切换的网关</p></li><li><p>AArch 64 异常级别和安全状态组织形式如下</p></li></ul><p><img src="AArch64 异常组织形式.png" alt="AArch64 异常组织形式.png"></p><ul><li>AArch 32 异常级别和安全状态组织形式如下</li></ul><p><img src="AArch32 异常组织形式.png" alt="AArch32 异常组织形式.png"></p><ul><li>只能通过改变异常级别来改变执行状态。对异常的处理可能从AArch32更改为AArch64，从异常返回可能从AArch64更改为AArch32。</li></ul><div class="note purple no-icon flat"><p>不能反着来是因为一个AArch32操作系统不能承载64位的应用程序，或者说一个AArch32Hypervisor不能承载64位的系统。</p></div><p><img src="执行状态切换.png" alt="执行状态切换.png"></p><h2 id="ARMv8-寄存器"><a href="#ARMv8-寄存器" class="headerlink" title="ARMv8 寄存器"></a>ARMv8 寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><ul><li>AArch 64 执行状态提供了 31 x 64 位的通用寄存器，可以在任何时间和所有异常级别访问。每个寄存器是64位宽，它们通常被称为X0-X30寄存器。</li></ul><p><img src="ARMv8通用寄存器.png" alt="ARMv8通用寄存器.png"></p><ul><li>每个AArch64 64位通用寄存器(X0-X30)也有一个32位(W0-W30)形式</li></ul><p><img src="Wn和Xn.png" alt="Wn和Xn.png"></p><ul><li>W寄存器读取时忽略相应X寄存器的高32位,写入W寄存器则将其余高位设置为0.</li></ul><h3 id="专用寄存器"><a href="#专用寄存器" class="headerlink" title="专用寄存器"></a>专用寄存器</h3><p><img src="特殊寄存器.png" alt="特殊寄存器.png"></p><ul><li><p>没有真正意义上的 31 号寄存器，很多时候都代表零寄存器，在某些特殊指令中也代表 SP 寄存器。</p></li><li><p>访问零寄存器时，所有读操作都返回 0 ，所有写操作无效，这点和 MIPS 很像。</p></li><li><p>当在AArch64中处于非EL0异常级别时，处理器可以使用以下两种寄存器：与异常级别关联的专用64位堆栈指针(SP_ELn)，或者 EL0 的堆栈指针（SP_EL0）</p></li><li><p>ELR 保存异常返回地址，和 MIPS 中的 EPC 很像</p></li><li><p>SPSR 当捕获一个异常时，处理器状态存储在相关的Saved Program Status register(SPSR)中，类似于ARMv7中的CPSR。SPSR在捕获异常之前保存ch（处理器状态）的值，并用于在执行异常返回时恢复PSTATE（处理器状态）的值。</p></li></ul><p><img src="SPSR.png" alt="SPSR.png"></p><p><img src="SPSR解释.png" alt="SPSR解释.png"></p><ul><li>在ARMv8中，对SPSR的写入依赖于异常级别。如果在EL1中发生异常，则使用SPSR_EL1。如果在EL2中发生异常，则使用SPSR_EL2，如果在EL3中发生异常，则使用SPSR_EL3。当发生异常时，核心要填充SPSR。</li></ul><h3 id="系统寄存器"><a href="#系统寄存器" class="headerlink" title="系统寄存器"></a>系统寄存器</h3><ul><li><p>在AArch64中，系统配置通过系统寄存器进行控制，并使用MSR和MRS指令来获取、更改系统寄存器的值。</p></li><li><p>寄存器的名字告诉你可以访问它的最低的异常级别，这点与专用寄存器有所差别</p></li></ul><p><img src="系统寄存器-1.png" alt="系统寄存器-1.png"></p><p><img src="系统寄存器-2.png" alt="系统寄存器-2.png"></p><p><img src="系统寄存器-3.png" alt="系统寄存器-3.png"></p><p><img src="系统寄存器-4.png" alt="系统寄存器-4.png"></p><p><img src="系统寄存器-5.png" alt="系统寄存器-5.png"></p><h4 id="系统控制寄存器"><a href="#系统控制寄存器" class="headerlink" title="系统控制寄存器"></a>系统控制寄存器</h4><p><img src="SCTLR.png" alt="SCTLR.png"></p><ul><li>并非所有位在EL1以上都可用。每个位代表以下内容</li></ul><p><img src="SCTLR字段-1.png" alt="SCTLR字段-1.png"></p><p><img src="SCTLR字段-2.png" alt="SCTLR字段-2.png"></p><h2 id="浮点寄存器"><a href="#浮点寄存器" class="headerlink" title="浮点寄存器"></a>浮点寄存器</h2><ul><li>除了通用寄存器外，ARMv8还有32个128位浮点寄存器，标记为V0-V31。32个寄存器用于保存标量浮点指令的浮点操作数，以及NEON操作的标量和向量操作数。</li></ul><h2 id="ARMv8-处理器状态"><a href="#ARMv8-处理器状态" class="headerlink" title="ARMv8 处理器状态"></a>ARMv8 处理器状态</h2><ul><li><p>处理器状态作为字段提供</p></li><li><p>定义如下</p></li></ul><p><img src="PSR.png" alt="PSR.png"></p><div class="note purple no-icon flat"><p>细心的话会发现这个字段定义和 SPSR 的字段高度类似，正如前面所说，异常时处理器状态就是被保存在 SPSR 中的。</p></div><h2 id="ARMv8-指令集"><a href="#ARMv8-指令集" class="headerlink" title="ARMv8 指令集"></a>ARMv8 指令集</h2><ul><li>指令集中的指令仍然是 32 位长</li></ul><h3 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h3><p><code>Instruction Rd, Rn, Operand2</code></p><ul><li>R 代表这里可以是X寄存器，也可以是W寄存器</li><li>D 代表这里是目标寄存器</li></ul><h4 id="算术和逻辑运算"><a href="#算术和逻辑运算" class="headerlink" title="算术和逻辑运算"></a>算术和逻辑运算</h4><p><img src="算术和逻辑运算.png" alt="算术和逻辑运算.png"></p><ul><li><p>有些指令还带有S后缀，表示该指令设置了标志。表6-1中的说明包括:ADDS、SUBS、ADCS、SBCS、ANDS和BICS。还有其他的标志设置指令，特别是CMP、CMN和TST，但它们没有S后缀，因为它们必然会设置标志。</p></li><li><p>ADD 加法，SUB 减法，ADC 带进位加法，SBC 带进位减法，NEG 求补</p></li><li>AND 与运算，BIC 对 Rn 中的值 和 Operand2 值的反码按位进行逻辑“与”运算，ORR 或运算，ORN 对第二个操作数的按位取反后执行或，EOR 异或运算，EON 对第二个操作数的按位取反后执行异或。</li><li>CMP 的比较方式：<code>op1 - (op2)</code>，CMN 的比较方式： <code>op1 - (-op2)</code>，TST 用来测试某一位或某几位是 0 还是 1。</li><li>MOV 移动值，MON 用它赋值的时候，先按位取反。</li></ul><h4 id="乘和除指令"><a href="#乘和除指令" class="headerlink" title="乘和除指令"></a>乘和除指令</h4><div class="table-container"><table><thead><tr><th>指令名</th><th>解释</th></tr></thead><tbody><tr><td>MADD</td><td>乘后加</td></tr><tr><td>MNEG</td><td>乘后取相反数</td></tr><tr><td>MSUB</td><td>乘后减</td></tr><tr><td>NUL</td><td>乘</td></tr><tr><td>SMADDL</td><td>对 Long 型做有符号的乘加运算</td></tr><tr><td>SMNEGL</td><td>对 Long 型做有符号的乘再取相反数运算</td></tr><tr><td>SMSUBL</td><td>对 Long 型做有符号的乘减运算</td></tr><tr><td>SMULH</td><td>返回高半部分的有符号乘</td></tr><tr><td>SMULL</td><td>对 Long 型做有符号的乘运算</td></tr><tr><td>UMADDL</td><td>对 Long 型做无符号的乘加运算</td></tr><tr><td>UMNEGL</td><td>对 Long 型做无符号的乘再取相反数运算</td></tr><tr><td>UMSUBL</td><td>对 Long 型做无符号的乘减运算</td></tr><tr><td>UMULH</td><td>返回高半部分的无符号乘</td></tr><tr><td>UMULL</td><td>对 Long 型 做无符号的乘运算</td></tr><tr><td>SDIV</td><td>有符号的除法</td></tr><tr><td>UDIV</td><td>无符号的除法</td></tr></tbody></table></div><div class="note green no-icon flat"><p>强调这么多的 Long 型乘法目的是在于强调 ARMv8 采用 64 位寄存器后的优越所在。一条指令即可完成 64 位的运算。</p></div><h4 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h4><div class="table-container"><table><thead><tr><th>指令名</th><th>解释</th></tr></thead><tbody><tr><td>LSL</td><td>逻辑左移</td></tr><tr><td>LSR</td><td>逻辑右移</td></tr><tr><td>ASR</td><td>算术右移</td></tr><tr><td>ROR</td><td>旋转右移</td></tr></tbody></table></div><p><img src="位运算图解.png" alt="位运算图解.png"></p><h4 id="位域和字节操作指令"><a href="#位域和字节操作指令" class="headerlink" title="位域和字节操作指令"></a>位域和字节操作指令</h4><div class="table-container"><table><thead><tr><th>指令名</th><th>解释</th></tr></thead><tbody><tr><td>SXTB</td><td>复制最高位将 8 位扩展到 64 位</td></tr><tr><td>CLZ</td><td>计算在寄存器中前导零的个数</td></tr><tr><td>RBIT</td><td>反转所有位</td></tr><tr><td>REV</td><td>反转寄存器的字节顺序</td></tr><tr><td>REV16</td><td>反转寄存器中每个半字的字节顺序</td></tr><tr><td>REV32</td><td>反转寄存器中每个字的字节顺序</td></tr></tbody></table></div><p>REV16图解：</p><p><img src="REV16.png" alt="REV16.png"></p><p>REV32图解：</p><p><img src="REV32.png" alt="REV32.png"></p><div class="note green no-icon flat"><p>这个可用来切换大小端序。</p></div>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM 体系结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox 系统盘无损扩容</title>
      <link href="/posts/17528/"/>
      <url>/posts/17528/</url>
      
        <content type="html"><![CDATA[<p>使用 Linux 虚拟机的过程中出现了系统盘空间不足的问题，挂载了新的空间也不行，这是由于实际上并没有扩容系统盘的原因。现总结无损扩容系统盘的方法：</p><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p>在 VBox 里面扩容磁盘</p><p><img src="虚拟介质.png" alt="虚拟介质.png"></p><p>此时打开虚拟机会发现仍然空间不足，因为新增的这部分磁盘仍然不可用。</p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p>查看系统盘是哪一个，输入 <code>df -h</code> 查看，挂载点为根目录，即<code>\</code>的即为系统盘，记住它的名字</p><p><img src="查看系统盘.png" alt="查看系统盘.png"></p><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><ul><li><p>扩容分区，管理员权限下输入<code>parted</code></p></li><li><p>输入<code>print /dev/sda</code>查看磁盘分区信息和扩容目标分区的编号</p></li></ul><p><img src="查看分区信息.png" alt="查看分区信息.png"></p><p>对照一下之前记住的名字和大小，就知道要扩容哪一个编号。</p><ul><li>输入<code>resize 对应编号</code>，输入结束点（就是在现有结束点上加上你扩容的大小）</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(parted)resizepart <span class="number">4</span></span><br><span class="line">警告<span class="punctuation">:</span> 分区 /dev/sda4 正被使用。你确定要继续吗?</span><br><span class="line">是/Yes/否/No? yes                                                         </span><br><span class="line">结束点？  <span class="punctuation">[</span><span class="number">21</span>GB<span class="punctuation">]</span>? <span class="number">30</span>GB</span><br></pre></td></tr></table></figure><div class="note purple no-icon flat"><p>此时只是扩展了分区大小，但这部分仍然没有被文件系统管理，所以仍然无法使用</p></div><h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><ul><li>扩展文件系统，输入：<code>resize2fs 系统盘的名字</code>，会把文件系统扩容到增加的空间上。</li></ul><h1 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h1><p>重启使用 <code>df -h</code> 查看是否扩容成功。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><img src="https://zhuanlan.zhihu.com/p/510655363" alt="linux下无损扩容分区方法"></p>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QEMU + GDB + VSCode 图形化调试</title>
      <link href="/posts/54660/"/>
      <url>/posts/54660/</url>
      
        <content type="html"><![CDATA[<p>本篇以调试 <a href="https://gitee.com/openeuler/rust_shyper#https://gitee.com/link?target=https%3A%2F%2Fdeveloper.arm.com%2Fdownloads%2F-%2Fgnu-a">rust_shyper</a> 为例：</p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>阅读本篇前假定您目前已有正确配置如下：</p><ul><li>Qemu</li><li>aarch64-none-elf 交叉工具链（特别是aarch64-none-elf-gdb）</li><li>VSCode</li></ul><p>阅读本篇前假定您目前可以正确做到如下：</p><ul><li>make debug 无报错</li><li>make gdb 无报错</li></ul><p>即您可以到达这个界面：</p><p><img src="原有调试环境.png" alt="原有调试环境.png"></p><div class="note green no-icon flat"><p>左为 make debug<br>右为 make gdb</p></div><h1 id="配置-VsCode-调试"><a href="#配置-VsCode-调试" class="headerlink" title="配置 VsCode 调试"></a>配置 VsCode 调试</h1><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><ul><li>运行 VsCode，安装扩展 GDB Debug</li></ul><p><img src="GDB Debug.png" alt="GDB Debug.png"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><ul><li>配置 <code>.vscode/launch.json</code> 或者点击调试下的齿轮打开 <code>.vscode/launch.json</code></li></ul><p><img src="launch.png" alt="launch.png"></p><ul><li>内容填写格式如下</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kernel debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> rust_shyper 目录<span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span>aarch64-none-elf-gdb 目录<span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ol><li>program 是要 debug 的可执行文件目录</li><li>miDebuggerPath 是 gdb 的目录</li><li>miDebuggerServerAddress 是调试程序服务器的网络地址</li></ol><div class="note orange no-icon flat"><p>一定要注意 miDebuggerPath 的路径是交叉编译 gdb（aarch64-none-elf-gdb） 的位置，而不是普通 gdb 的位置<br>否则就会报错：truncated register 37 in remote g packet 是架构不支持的报错<br>详见：<a href="https://blog.csdn.net/xjh1303678317/article/details/117527456">qemu-gdb debug</a></p></div><ul><li>例如我的格式如下</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kernel debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/target/aarch64/release/rust_shyper&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span><span class="string">&quot;/usr/local/arm/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf/bin/aarch64-none-elf-gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><font color = "red">如果 cppdbg 报错，安装 C/C++ Runner 插件 和 C/C++ Extension Pack</font> <p><img src="C++ Runner.png" alt="C++ Runner.png"></p><p><img src="C++ Extension.png" alt="C++ Extension.png"></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>打开工作目录，在任意位置设置断点。</p><p>在 rust-shyper 目录下打开 shell，输入 <code>make debug</code>打开 qemu</p><p>尝试在 VSCode 运行调试，如果运行正确就会跳到断点</p><p><img src="调试界面.png" alt="调试界面.png"></p><p>如图，左边可以查看 变量，寄存器，堆栈，断点。</p><p>可以单步执行，逐过程等等，做到如同写简单代码一样的调试。</p><h1 id="debug-时自动启动-qemu"><a href="#debug-时自动启动-qemu" class="headerlink" title="debug 时自动启动 qemu"></a>debug 时自动启动 qemu</h1><p>如果觉得每次需要手动在 shell 输入 make debug 打开 qemu 觉得麻烦，可以做到运行调试时自动打开 qemu。</p><h2 id="第一步-1"><a href="#第一步-1" class="headerlink" title="第一步"></a>第一步</h2><ul><li>配置 <code>.vscode/tasks.json</code> 或者在 VSCode 界面选择终端——运行任务——使用模板创建 <code>tasks.json</code> 文件——Ohters</li></ul><p><img src="配置任务-1.png" alt="配置任务-1"></p><p><img src="配置任务-2.png" alt="配置任务-2"></p><ul><li>配置写入如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;make debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;echo&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;clear&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;isBackground&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="第二步-1"><a href="#第二步-1" class="headerlink" title="第二步"></a>第二步</h2><p>在<code>.vscode/launch.json</code>下添加一项新属性：<code>&quot;preLaunchTask&quot;: &quot;qemu&quot;</code></p><p>即最终的 <code>launch.json</code> 内容为</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;kernel debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/target/aarch64/release/rust_shyper&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span><span class="string">&quot;/usr/local/arm/gcc-arm-11.2-2022.02-x86_64-aarch64-none-elf/bin/aarch64-none-elf-gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;miDebuggerServerAddress&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:1234&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><font color = "blue">之后点击 debug 就会自动运行该任务，自动启动 qemu。</font><h3 id="可能问题"><a href="#可能问题" class="headerlink" title="可能问题"></a>可能问题</h3><font color = "red">如果设置后运行调试提示如下内容，则点击仍然调试即可，此问题不致命、不影响调试</font><p><img src="无法跟踪.png" alt="无法跟踪.png"></p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p><img src="最终效果.png" alt="最终效果.png"></p><ul><li>点击调试自动执行 make debug 和 make gdb</li><li>qemu 的输出在 VSCode 的终端即可查看</li><li>调试在 VSCode 进行</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><font color = "purple" size = "5px">提供另一种可视化调试的方法，可以方便的查看汇编，安装也十分简单方便，效果如下：</font> <p><img src="board-1.png" alt="board-1.png"></p><p>一个 shell 显示所有寄存器。</p><p><img src="board-2.png" alt="board-2.png"></p><p>一个 shell 显示堆栈、当前汇编、执行语句。</p><font color = "blue">原汁原味的 gdb 调试命令，但可视化寄存器、汇编指令、执行语句</font> <p>资料参考：<a href="https://zhuanlan.zhihu.com/p/435918702">神仙GDB调试工具 gdb-dashboard</a></p><h2 id="第一步-2"><a href="#第一步-2" class="headerlink" title="第一步"></a>第一步</h2><p>在工作目录下（Rust-Shyper）下下载脚本</p><p><code>wget -P ~ https://git.io/.gdbinit</code></p><div class="note green no-icon flat"><p>如果超时、挂梯子自己去下载一下，然后复制进工作目录即可。</p></div><h2 id="第二步-2"><a href="#第二步-2" class="headerlink" title="第二步"></a>第二步</h2><p>在 <code>~/.gdbinit.d/</code> 目录创建配置文件 <code>~/.gdbinit.d/init</code>,写入内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set breakpoint pending on</span><br><span class="line">set confirm off</span><br><span class="line">dashboard -layout registers assembly source !variables stack</span><br></pre></td></tr></table></figure><h2 id="第三步-1"><a href="#第三步-1" class="headerlink" title="第三步"></a>第三步</h2><p>正常执行 make debug 和 make gdb 即可。</p><h2 id="多窗口调试"><a href="#多窗口调试" class="headerlink" title="多窗口调试"></a>多窗口调试</h2><p>参考前述：<a href="https://zhuanlan.zhihu.com/p/435918702">神仙GDB调试工具 gdb-dashboard</a></p>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进阶调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习（三）</title>
      <link href="/posts/12235/"/>
      <url>/posts/12235/</url>
      
        <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li>提高代码复用能力</li><li>泛型是具体类型或其他属性的抽象代替</li><li>编写的代码不是最终的代码、而是一种模板，里面有一些“占位符”</li><li>编译器在编译时将“占位符”替换为具体的类型。</li></ul><h2 id="函数泛型"><a href="#函数泛型" class="headerlink" title="函数泛型"></a>函数泛型</h2><p>例如：<code>fn largest&lt;T&gt;(list:&amp;[T]) -&gt; T&#123; ... &#125;</code></p><h2 id="结构体泛型"><a href="#结构体泛型" class="headerlink" title="结构体泛型"></a>结构体泛型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>&lt;T&gt;&#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Users</span>&lt;T, U&gt;&#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">integer</span> = User &#123;x: <span class="number">5</span>, y: <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">double</span> = User &#123;x: <span class="number">1.0</span>, y: <span class="number">2.0</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">mix</span> = User &#123;x: <span class="number">5</span>, y: <span class="number">10.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="枚举泛型"><a href="#枚举泛型" class="headerlink" title="枚举泛型"></a>枚举泛型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Result</span>&lt;T, E&gt;&#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: E,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="方法泛型"><a href="#方法泛型" class="headerlink" title="方法泛型"></a>方法泛型</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//针对所有的类型实现方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x1</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">i32</span> &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//针对具体的 i32 实现方法</span></span><br></pre></td></tr></table></figure> <div class="note purple no-icon flat"><p>泛型的运行速度和普通代码运行速度一致，这是由于 Rust 在编译时将这些泛型单态化。即将他们的类型根据代码确定下来。</p></div><h1 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li>Trait 告诉 Rust 编译器，某种类型具有哪些并且可以与其他类型共享的功能。</li><li>Trait：抽象的定义共享行为。</li><li>Trait bounds(约束)：泛型类型参数指定为实现了特定行为的类型。</li><li>类似于其他语言的接口</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>把方法签名放在一起，来定义实现某种目的所必须的一组行为。</p><ul><li>关键字：trait</li><li>只有方法签名，没有具体实现</li><li>trait 可以有多个方法：每个方法签名占一行，以<code>;</code>结尾</li><li>实现该 trait 的类型必须提供具体的方法实现</li></ul><h2 id="在类型上实现-trait"><a href="#在类型上实现-trait" class="headerlink" title="在类型上实现 trait"></a>在类型上实现 trait</h2><ul><li>关键字：`impl tarit_name for struct_name { … }</li><li>在 impl 的块里面，需要对 Trait 里的方法签名进行具体的实现。 </li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div class="note green no-icon flat"><p>可以在某个类型上实现某个 trait 的前提条件是：这个类型或这个 trait 是在本地 crate 里定义的。<br>无法为外部类型来实现外部的 trait</p></div><h2 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h2><ul><li>默认实现的方法可以调用 trait 中的其他方法，即使这些方法没有默认实现。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;(Read more...)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="comment">//空,采用默认实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </li></ul><div class="note green no-icon flat"><p>默认实现是区别于接口的重要区分，我们可以在 Trait 的定义中实现默认实现，结构体可以是用这个默认实现。</p></div><h2 id="Trait-作为参数"><a href="#Trait-作为参数" class="headerlink" title="Trait 作为参数"></a>Trait 作为参数</h2><ul><li>使用<code>impl trait</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123; <span class="comment">//这样声明，只要类型实现了该trait 就可以传入。</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <ul><li>使用<code>trait bound</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: T) &#123; <span class="comment">//这样声明，只要类型实现了该trait 就可以传入。</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <ul><li>实现多个<code>trait</code>,使用<code>+</code>号</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display&gt;(item: T) &#123; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: <span class="keyword">impl</span> <span class="title class_">Summary</span> + Display) &#123; </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>简化 trait 约束，使用 <code>where</code>,避免函数签名紊乱</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary + Display, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(a: T, b: U) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T, U&gt;(a: T, b: U) <span class="punctuation">-&gt;</span> <span class="type">String</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Summary + Display,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trait-作为返回类型"><a href="#Trait-作为返回类型" class="headerlink" title="Trait 作为返回类型"></a>Trait 作为返回类型</h2><ul><li>impl Trait 只能返回确定的同一种类型，返回可能不同类型的代码会报错。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify1</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    NewsArticle &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>在使用泛型类型参数的 impl 块上使用 Trait bound,我们可以有条件的为实现了特定 Trait 的类型来实现方法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        ..</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">//只有实现了Display + PartialOrd的泛型才有这个方法</span></span><br></pre></td></tr></table></figure><ul><li>可以为实现了其他 Tarit 的任意类型有条件的实现某个 Trait.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: fmt::Display&gt; <span class="built_in">ToString</span> <span class="keyword">for</span> <span class="title class_">T</span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125; <span class="comment">//为任何实现了 Dispaly Tarit 的类型都实现 ToString.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级语言 </tag>
            
            <tag> 语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习（二）</title>
      <link href="/posts/9138/"/>
      <url>/posts/9138/</url>
      
        <content type="html"><![CDATA[<h1 id="Rust-语法学习"><a href="#Rust-语法学习" class="headerlink" title="Rust 语法学习"></a>Rust 语法学习</h1><h2 id="一般-Struct"><a href="#一般-Struct" class="headerlink" title="一般 Struct"></a>一般 Struct</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>和 C 语言一样，是一种自定义的数据类型</li><li>和 C 语言一样，为相关联的值命名，打包成有意义的组合</li></ul><h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><ul><li>使用 struct 关键字，并为整个 struct 命名。</li><li>在花括号内，为所有字段（Filed）定义名称和类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username:<span class="type">String</span>,</span><br><span class="line">    email:<span class="type">String</span>,</span><br><span class="line">    sign_in_count:<span class="type">u64</span>,</span><br><span class="line">    active:<span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><ul><li>想要使用 struct, 需要创建 struct 的实例；</li></ul><ol><li>为每个字段指定具体值</li><li>无需按声明的顺序指定</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;acb@123.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">556</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <h3 id="访问与赋值"><a href="#访问与赋值" class="headerlink" title="访问与赋值"></a>访问与赋值</h3><ul><li>使用点标记法</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123; <span class="comment">//声明为可变</span></span><br><span class="line">    email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;acb@123.com&quot;</span>),</span><br><span class="line">    username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Nikky&quot;</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">556</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">username1 = use1.username; <span class="comment">//访问</span></span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>); <span class="comment">//赋值</span></span><br></pre></td></tr></table></figure> <div class="note purple no-icon flat"><p>一旦 struct 的实例是可变的，那么实例中所有的字段都是可变的。</p></div><h3 id="作为函数返回值"><a href="#作为函数返回值" class="headerlink" title="作为函数返回值"></a>作为函数返回值</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email:<span class="type">String</span>,username:<span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User&#123;</span><br><span class="line">        email:email,</span><br><span class="line">        username:username,</span><br><span class="line">        active:<span class="literal">true</span>,</span><br><span class="line">        sign_in_count:<span class="number">1</span>,</span><br><span class="line">    &#125; <span class="comment">//记住没‘；’，有；就是语句了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="字段初始化简写"><a href="#字段初始化简写" class="headerlink" title="字段初始化简写"></a>字段初始化简写</h3><ul><li>当字段名与字段值对应变量名相同时，就可以使用字段初始化简写的方式：</li></ul><p>改造上一个例子：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email:<span class="type">String</span>,username:<span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">    User&#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active:<span class="literal">true</span>,</span><br><span class="line">        sign_in_count:<span class="number">1</span>,</span><br><span class="line">    &#125; <span class="comment">//记住没‘；’，有；就是语句了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><h3 id="struct-更新语法"><a href="#struct-更新语法" class="headerlink" title="struct 更新语法"></a>struct 更新语法</h3><ul><li>当你想基于某个 struct 实例来创建一个新实例的时候，可以使用 struct 更新语法。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@123.com&quot;</span>),</span><br><span class="line">    username:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;123&quot;</span>),</span><br><span class="line">    active:user1.active,</span><br><span class="line">    sign_in_count:user1.sign_in_count,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">就可以简写为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User &#123;</span><br><span class="line">    email:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;another@123.com&quot;</span>),</span><br><span class="line">    username:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;123&quot;</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <h2 id="Tuple-struct"><a href="#Tuple-struct" class="headerlink" title="Tuple struct"></a>Tuple struct</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>可定义类似 tuple 的 struct，叫做 tuple struct.</li></ul><ol><li>Tuple struct 整体有名字，其中的元素没有名字</li><li>适用于：想给整个 Tuple 起名，并让它不同于其他 Tuple, 而且又不需要给每个元素起名。</li></ol><h3 id="建立-1"><a href="#建立-1" class="headerlink" title="建立"></a>建立</h3><ul><li>使用 struct 关键字，后面是名字，以及里面元素的类型。</li></ul><h3 id="访问与修改"><a href="#访问与修改" class="headerlink" title="访问与修改"></a>访问与修改</h3><ul><li>和 Tuple 一样的点标记法。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">black</span> =  <span class="title function_ invoke__">Color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">black1</span> = black.<span class="number">1</span>; <span class="comment">//访问</span></span><br><span class="line">black.<span class="number">1</span> = <span class="number">1</span>; <span class="comment">//修改</span></span><br></pre></td></tr></table></figure> <h2 id="Unit-Like-Struct"><a href="#Unit-Like-Struct" class="headerlink" title="Unit-Like Struct"></a>Unit-Like Struct</h2><ul><li>可以定义没有任何字段的 struct，叫做 Unit-Like struct.</li><li>适用于需要在某个类型上实现某个 trait,但是在里面又没有想要存储的数据。</li></ul><div class="note purple no-icon flat"><p>tarit 可以理解为接口。</p></div><h2 id="struct-所有权"><a href="#struct-所有权" class="headerlink" title="struct 所有权"></a>struct 所有权</h2><p>对于这样的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    username:<span class="type">String</span>,</span><br><span class="line">    email:<span class="type">String</span>,</span><br><span class="line">    sign_in_count:<span class="type">u64</span>,</span><br><span class="line">    active:<span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <ul><li>这里的字段使用了 String 而不是 &amp;str，表明：</li></ul><ol><li>该 struct 实例拥有其所有的数据。</li><li>只要 struct 实例是有效的，那么里面的字段数据也是有效的。</li></ol><ul><li>struct 里面可以存放引用，但需要使用生命周期（后续内容）</li></ul><div class="note green no-icon flat"><p>这样做的目的是保证只要 struct 实例有效，里面的所有数据都是有效的。</p></div><h2 id="struct-方法"><a href="#struct-方法" class="headerlink" title="struct 方法"></a>struct 方法</h2><ul><li>Rust 没有 <code>-&gt;</code> 引用符号</li><li>Rust 会自动引用或解引用，所以无脑 <code>.</code> 即可</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    length: <span class="type">u32</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">iml Rectangle &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> &#123; <span class="comment">//这里可借用，可获得所有权，可可变借用</span></span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect</span> = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        length: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,rect.<span class="title function_ invoke__">area</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>,rect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="struct-关联函数"><a href="#struct-关联函数" class="headerlink" title="struct 关联函数"></a>struct 关联函数</h2><ul><li>可以在 impl 块里定义不把 self 作为第一个参数的函数，它们叫关联函数（不是方法）</li><li>例如 <code>String::from()</code></li></ul><div class="note orange no-icon flat"><p>结合引入时的猜数游戏例子，有没有豁然开朗？</p></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">iml Rectangle &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">square</span>(size: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle &#123; </span><br><span class="line">        Rectangle &#123;</span><br><span class="line">            width: size,</span><br><span class="line">            length: size</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = Rectangle::<span class="title function_ invoke__">square</span>(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    v4,</span><br><span class="line">    v6,</span><br><span class="line">&#125; <span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::v4; <span class="comment">//创建</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::v6; <span class="comment">//创建</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">route</span>(four); <span class="comment">//传参</span></span><br><span class="line"><span class="title function_ invoke__">route</span>(six); <span class="comment">//传参</span></span><br><span class="line"><span class="title function_ invoke__">route</span>(IpAddrKind::v6); <span class="comment">//传参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">route</span>(ip_addr:IpAddrKind) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="将数据附加到枚举的变体中"><a href="#将数据附加到枚举的变体中" class="headerlink" title="将数据附加到枚举的变体中"></a>将数据附加到枚举的变体中</h3><ul><li>附加的数据类型可以是任意</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">v4</span>(<span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>, <span class="type">u8</span>),</span><br><span class="line">    <span class="title function_ invoke__">v6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123;</span><br><span class="line">        x:<span class="type">i32</span>,</span><br><span class="line">        y:<span class="type">i32</span>,</span><br><span class="line">    &#125;, <span class="comment">//匿名结构体</span></span><br><span class="line">    <span class="title function_ invoke__">Write</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">ChangeColor</span>(<span class="type">i32</span>, <span class="type">i32</span>, <span class="type">i32</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">home</span> = IpAddrKind::<span class="title function_ invoke__">V4</span>(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">loopback</span> = IpAddrKind::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="枚举方法"><a href="#枚举方法" class="headerlink" title="枚举方法"></a>枚举方法</h3><p>和 struct 一样。</p><h2 id="Option-枚举"><a href="#Option-枚举" class="headerlink" title="Option 枚举"></a>Option 枚举</h2><ul><li>标准库中的定义：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <ul><li>它包含在 Prelude (预导入模块) 中。可直接使用：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Option</span>&lt;T&gt;</span><br><span class="line"><span class="title function_ invoke__">Some</span>(T)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_number</span> = <span class="title function_ invoke__">Some</span>(<span class="number">5</span>); <span class="comment">//自动推断类型</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="title function_ invoke__">Some</span>(<span class="string">&quot;A String&quot;</span>); <span class="comment">//自动推断类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">absent_number</span>: <span class="type">Option</span>&lt;<span class="type">i32</span>&gt; = <span class="literal">None</span>; <span class="comment">//None 无法帮助推断类型，需要自己手动给出类型。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <div class="note green no-icon flat"><p>Option 主要是表示别的语言中的 Null, 这种表示避免了很多了 Null 值的错误使用带来的 panic.</p></div><h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><ul><li><p>强大的控制流运算符</p></li><li><p>普通使用</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin:Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure><div class="note red no-icon flat"><p>match 的返回值为匹配到分支的返回值。</p></div><ul><li>匹配的分支可以绑定到被匹配对象的部分值</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin:Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span>  <span class="comment">//返回值为1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = Coin::<span class="title function_ invoke__">Quarter</span>(UsState::Alaska);</span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,<span class="title function_ invoke__">value_in_cents</span>(c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <ul><li>Rust match 匹配必须穷举所有值。</li><li>可以用 <code>_</code> 通配符来替代其余没列出的值。</li></ul><h2 id="if-let"><a href="#if-let" class="headerlink" title="if let"></a>if let</h2><ul><li>简单的控制流语句</li><li>处理只关心一种匹配而忽略其他匹配的情况。</li><li>更少的代码，更少的缩进，更少的模板代码。</li><li>放弃了穷举的可能。</li><li>可搭配 else.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="number">3</span>) = v &#123; <span class="comment">//这里只有一个等号</span></span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;Three!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;others!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Rust-代码组织"><a href="#Rust-代码组织" class="headerlink" title="Rust 代码组织"></a>Rust 代码组织</h1><h2 id="代码组织主要包括"><a href="#代码组织主要包括" class="headerlink" title="代码组织主要包括"></a>代码组织主要包括</h2><ul><li>哪些细节可以暴露，哪些细节是私有的。</li><li>作用域内哪些名称有效</li></ul><h2 id="模块系统："><a href="#模块系统：" class="headerlink" title="模块系统："></a>模块系统：</h2><ul><li>Package（包）：Cargo 的特性，让你构建、测试、共享 crate.</li><li>Crate（单元包）：一个模块树，它可产生一个 Library 或可执行文件.</li><li>Module（模块）：use: 让你控制代码的组织、作用域、私有路径.</li><li>Path（路径）：为 struct、function 或 module 等项命名的方式.</li></ul><h2 id="Crate的类型"><a href="#Crate的类型" class="headerlink" title="Crate的类型"></a>Crate的类型</h2><ul><li>binary</li><li>library</li></ul><h2 id="Crate-Roof"><a href="#Crate-Roof" class="headerlink" title="Crate Roof"></a>Crate Roof</h2><ul><li>是源代码文件</li><li>Rust 编译器从这里开始，组成你的 Crate 的根 Module</li></ul><h2 id="一个-Package"><a href="#一个-Package" class="headerlink" title="一个 Package"></a>一个 Package</h2><ul><li>包含 1 个 Cargo.toml, 它描述了如何构建这些 Crates.</li><li>只能包含 0 - 1 个 Library crate.</li><li>可以包含任意数量的 binary crate.</li><li>但必须至少包含一个 crate (library 或 binary).</li></ul><h2 id="Cargo-的惯例"><a href="#Cargo-的惯例" class="headerlink" title="Cargo 的惯例"></a>Cargo 的惯例</h2><ul><li>src/main.rs:<ul><li>binary crate 的 crate root</li><li>crate 名与 package 名相同</li></ul></li><li>src/lib.rs:<ul><li>package 包含一个 library crate</li><li>library crate 的 crate root</li><li>crate 名与 package 名相同</li></ul></li><li>Cargo 把 crate root 文件交给 rustc 来构建 library 或 binary.</li><li>一个 Package 可以同时包含 src/main.rs 和 src/lib.rs<ul><li>一个 binary crate, 一个 library crate.</li><li>名称与 package 名相同</li></ul></li><li>一个 Package 可以有多个 binary crate.<ul><li>文件放在 src/bin 下。</li><li>一个文件就是一个 binary crate.</li></ul></li></ul><h2 id="Crate-的作用"><a href="#Crate-的作用" class="headerlink" title="Crate 的作用"></a>Crate 的作用</h2><ul><li>将相关功能组合到一个作用域内，便于在项目间进行共享，这样做防止冲突</li><li>例如 rand crate, 访问它的功能需要通过它的名字：rand.</li></ul><h2 id="定义-module-来控制作用域和私有性"><a href="#定义-module-来控制作用域和私有性" class="headerlink" title="定义 module 来控制作用域和私有性"></a>定义 module 来控制作用域和私有性</h2><ul><li>在一个 crate 内，将代码进行分组</li><li>增加可读性，易于复用</li><li>控制项目（item）私有性</li><li>使用 mod 关键字建立 module.</li><li>module 可以嵌套.</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">seat_at_table</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_order</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">take_payment</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="crate模块.png" alt="crate模块"></p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><ul><li>为了在 Rust 的模块中找到某个条目，需要使用路径</li><li>路径的两种形式：<ul><li>绝对路径：从 crate root 开始，使用 crate 名或字面值 crate.</li><li>相对路径：从当前模块开始，使用 self,super 或当前模块的标识符。</li></ul></li><li>路径至少由一个标识符组成，标识符之间使用 <code>::</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>(); <span class="comment">//绝对路径</span></span><br><span class="line"></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>(); <span class="comment">//相对路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="red">但这样是无法通过编译的，这是由于 Rust 中条目默认为 private</font><h2 id="私有边界"><a href="#私有边界" class="headerlink" title="私有边界"></a>私有边界</h2><ul><li>同级模块可以互相调用私有条目</li><li>子模块可以调用父模块私有条目</li><li>父模块不能调用子模块私有条目</li></ul><h2 id="pub-关键字"><a href="#pub-关键字" class="headerlink" title="pub 关键字"></a>pub 关键字</h2><ul><li>使用 pub 关键字可以将某些条目标记为公共的。</li></ul><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><ul><li>类似于文件系统中 <code>..\</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">serve_order</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fix_incorrect_order</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">cook_order</span>();</span><br><span class="line">        super::<span class="title function_ invoke__">serve_order</span>(); <span class="comment">//相对路径</span></span><br><span class="line">        crate::<span class="title function_ invoke__">serve_order</span>(); <span class="comment">//绝对路径</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cook_order</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pub-struct"><a href="#pub-struct" class="headerlink" title="pub struct"></a>pub struct</h2><ul><li>pub 放在 struct 前<ul><li>struct 变成公共</li><li>但 struct 中的字段仍然是私有的</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="type">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="type">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> <span class="title class_">Breakfast</span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">summer</span>(toast: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(toast),</span><br><span class="line">                seasonal_fruit: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;peaches&quot;</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">meal</span> = back_of_house::Breakfast::<span class="title function_ invoke__">summer</span>(<span class="string">&quot;Rye&quot;</span>);</span><br><span class="line">    meal.toast = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Wheat&quot;</span>); <span class="comment">//正确</span></span><br><span class="line">    meal.seasonal_fruit = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;apple&quot;</span>); <span class="comment">//报错，权限不足</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pub-enum"><a href="#pub-enum" class="headerlink" title="pub enum"></a>pub enum</h2><ul><li>pub 放在 enum 前：<ul><li>enum 变成公共</li><li>enum 变体全部变成公共</li></ul></li></ul><h2 id="use"><a href="#use" class="headerlink" title="use"></a>use</h2><p>可以使用 use 关键字将路径导入到作用域内</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting; <span class="comment">//绝对引入</span></span><br><span class="line"><span class="keyword">use</span> front_of_house::hosting; <span class="comment">//相对引入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">    hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="as-关键字"><a href="#as-关键字" class="headerlink" title="as 关键字"></a>as 关键字</h2><p>as 关键字可以为引入路径指定本地的别名<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="type">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="type">Result</span> <span class="keyword">as</span> IoResult;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f1</span> <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">f2</span> <span class="punctuation">-&gt;</span> IoResult &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="pub-use"><a href="#pub-use" class="headerlink" title="pub use"></a>pub use</h2><ul><li>使用 use 将路径导入到作用域内后，该名称在此作用域内是私有的</li><li>pub use: 重导出<ul><li>该条目引入作用域。</li><li>该条目可以被外部代码引入到它们的作用域。</li></ul></li></ul><h2 id="使用外部包（package）"><a href="#使用外部包（package）" class="headerlink" title="使用外部包（package）"></a>使用外部包（package）</h2><ol><li>Cargo.toml 添加依赖的包（package）</li><li>use 将特定条目引入作用域</li></ol><h2 id="嵌套路径"><a href="#嵌套路径" class="headerlink" title="嵌套路径"></a>嵌套路径</h2><ul><li>使用嵌套路径清理大量的 use 语句</li><li>如果使用同一个包或模块下多个条目</li><li>可使用嵌套路径在同一行内将上述条目进行引入</li><li>形式：<code>路径相同的部分::&#123;路径差异的部分&#125;</code></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;cmp::Ordering, io&#125; </span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, write&#125;;</span><br><span class="line">相当于</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::write;</span><br></pre></td></tr></table></figure><h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><ul><li>使用 <code>*</code> 可以把路径中所有的公共条目都引入到作用域。</li></ul><div class="note red no-icon flat"><p>use std::collections;<br>use std::collections::*；<br>有啥区别？<br>以创建 HashMap 为例：<br>let a = collections::HashMap 第一种<br>let a = HashMap 第二种</p></div><h2 id="将模块内容移动到其他文件"><a href="#将模块内容移动到其他文件" class="headerlink" title="将模块内容移动到其他文件"></a>将模块内容移动到其他文件</h2><ul><li>模块定义时，如果模块名后面是 <code>;</code> 而不是代码块<ul><li>Rust 会从与模块同名的文件中加载内容</li><li>模块树的结构不会发生变化</li></ul></li></ul><h1 id="Rust-常用的集合"><a href="#Rust-常用的集合" class="headerlink" title="Rust 常用的集合"></a>Rust 常用的集合</h1><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>Vec<T>,叫做 vector.</p><ul><li>由标准库提供</li><li>可存储多个值</li><li>只能存储相同类型的数据</li><li>值在内存中连续存放</li></ul><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ul><li>Vec::new 函数：<code>let v : Vec&lt;i32&gt; = Vec::new();</code> </li></ul><div class="note green no-icon flat"><p>如果下文可以推断出 Vector<T> 类型，则无需在定义变量时给出类型。</p></div><ul><li>使用初始值创建 <code>Vec&lt;T&gt;</code>, 使用 <code>vec!</code> 宏：<code>let v = vec![1, 2, 3];</code></li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul><li>向 Vector 添加元素，使用 push 方法：<code>v.push(1);</code></li><li>读取 Vector 元素：<ul><li>索引：<code>v[2]</code></li><li>get 方法：<code>v.get(2)</code></li></ul></li></ul><div class="note purple no-icon flat"><p>索引访问越界时会 panic<br>get访问越界时会返回 None</p></div><ul><li>遍历 Vector 元素：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">v</span> = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-enum-来存储多种数据类型"><a href="#使用-enum-来存储多种数据类型" class="headerlink" title="使用 enum 来存储多种数据类型"></a>使用 enum 来存储多种数据类型</h3><p>笔者看来这算是一种 trick, 用来打破 Vector 只能存一种类型的问题。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>UTF-8 编码</p><h3 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h3><ul><li>String::new() 函数</li><li>使用初始值来创建 String.<ul><li>to_string() <font color="red">方法</font>, 可用于实现了 Display trait 的类型，包括字符串字面值。</li><li>String::from() 函数，从字面值创建 String.</li></ul></li></ul><h3 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h3><ul><li>push_str() 方法： 把一个<font color="red">字符串切片</font>附加到 String.</li><li>push() 方法 ： 把单个<font color="red">字符</font>附加到 String.</li><li>拼接字符串： <code>+</code></li><li>格式化字符串： <code>format!</code>:<code>format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, s1, s2, s3);</code></li></ul><div class="note green no-icon flat"><p>这种格式化和 println! 的格式化输出一模一样，区别在于 format 返回字符串。<br>format 不会像 + 那样取得所有权。</p></div><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello,&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = s1 + &amp;s2;</span><br><span class="line">    <span class="comment">// &#x27;+&#x27; 相当于调用了 fn add(self,s: &amp;str) -&gt; String 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s3); <span class="comment">//有效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2); <span class="comment">//有效</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); <span class="comment">//失效</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p>字节、标量值、字形簇.这是 Rust 看待三种字符串的方式。</p></div><h3 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h3><ul><li>使用 <code>[]</code> 和 <code>一个范围</code> 来创建字符串的切片（例子）</li><li>必须沿着字符边界切割，否则会 panic.</li></ul><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li><code>HashMap&lt;K,V&gt;</code></li><li>键值对的形式存储数据，一个键值（key）对应一个值（value）<h3 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h3></li><li>创建空 HashMap: new 函数</li><li>使用 insert 方法添加数据。</li><li>在元素类型为 Tuple 的 Vector 上使用 Collect 方法，可以组建一个 HashMap:<ul><li>要求 Tuple 有两个值：一个作为 K，一个作为 V</li><li>Collect 方法可以把数据整合成很多种集合类型，包括 HashMap</li><li>返回值需要显式指明类型（理由是 Collect 可以返回很多数据结构）</li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">teams</span> = <span class="built_in">vec!</span>[<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>)];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">intial_scores</span> = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scores</span>:HashMap&lt;_,_&gt; = teams.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">zip</span>(intial_scores.<span class="title function_ invoke__">iter</span>()).<span class="title function_ invoke__">collect</span>();</span><br><span class="line">    <span class="comment">//先用 zip 生成 Tuple 的 Vector,之后用 collect 根据显式声明的类型将其转化为相应类型。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap-和所有权"><a href="#HashMap-和所有权" class="headerlink" title="HashMap 和所有权"></a>HashMap 和所有权</h3><ul><li>对于实现了 Copy trait 的类型（例如 i32），值会被复制到 HashMap 中。</li><li>对于拥有所有权的值（例如 String），值会被移动，所有权会转移给 HashMap。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">field_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Favorite color&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">field_value</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">map</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    map.<span class="title function_ invoke__">insert</span>(field_name, field_value);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>, field_name, field_value); <span class="comment">//错误，所有权已经被移动。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问-HashMap-中的值"><a href="#访问-HashMap-中的值" class="headerlink" title="访问 HashMap 中的值"></a>访问 HashMap 中的值</h3><ul><li>get 方法：<ul><li>参数：K</li><li>返回值：Option&lt;&amp;V&gt;</li></ul></li></ul><font color="red">所以要通过 Match 来匹配值</font><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>), <span class="number">10</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">team_name</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">score</span> = scores.<span class="title function_ invoke__">get</span>(&amp;team_name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> score &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(s) <span class="punctuation">-&gt;</span> <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s),</span><br><span class="line">        <span class="literal">None</span> <span class="punctuation">-&gt;</span> <span class="built_in">println!</span>(<span class="string">&quot;team not exist&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>for 循环</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">for</span> (k, v) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, k, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新-2"><a href="#更新-2" class="headerlink" title="更新"></a>更新</h3><ul><li>由于 HashMap 要求 K 唯一，所以在 HashMap 已经存在一对<code>&lt;K,V&gt;</code>的情景下，直接再插入<code>&lt;K,M&gt;</code>会替换原有的<code>&lt;K,V&gt;</code></li><li>一般情况下，我们需要保证只有 K 不对呀任何值的情况下，才插入 V。<ul><li>entry 方法： 检查指定的 K 是否对应一个 V<ul><li>参数为 K</li><li>返回 enum Entry: 代表值是否存在。</li></ul></li></ul></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">scores</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    scores.<span class="title function_ invoke__">insert</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>),<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">e</span> = scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Yellow&quot;</span>));</span><br><span class="line">    e.<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">    scores.<span class="title function_ invoke__">entry</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Blue&quot;</span>)).<span class="title function_ invoke__">or_insert</span>(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note green no-icon flat"><p>or_insert 就是枚举中的方法。<br>如果 K 存在，返回到对应 V 的一个可变引用。<br>如果 K 不存在，将方法参数作为 K 的新值插进去，返回到这个值的可变引用。</p></div><ul><li>当然，我们也可以基于已有的 V 来更新 V</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">text</span> = <span class="string">&quot;hello world wonderful world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ley <span class="keyword">mut</span> map = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">word</span> <span class="keyword">in</span> text.<span class="title function_ invoke__">split_whitespace</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">count</span> = map.<span class="title function_ invoke__">entry</span>(word).<span class="title function_ invoke__">or_insert</span>(<span class="number">0</span>);</span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h3><ul><li>通过指定不同的 hasher 来切换到另一个哈希函数。</li><li>默认函数为安全性较高的哈希函数，可抵抗 Dos 攻击。</li></ul><h3 id="Rust-错误处理"><a href="#Rust-错误处理" class="headerlink" title="Rust 错误处理"></a>Rust 错误处理</h3><h4 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h4><ul><li><p>Rust 的可靠性：错误处理</p><ul><li>大部分情况下：在编译时提示错误，并处理。</li></ul></li><li><p>错误的分类：</p><ul><li>可恢复：例如文件未找到，可再次尝试</li><li>不可恢复：bug，例如访问的索引超出范围</li></ul></li><li><p>Rust 没有类似异常的机制</p><ul><li>可恢复错误：<code>Result&lt;T,E&gt;</code></li><li>不可恢复：<code>panic!</code> 宏</li></ul></li></ul><h4 id="不可恢复错误"><a href="#不可恢复错误" class="headerlink" title="不可恢复错误"></a>不可恢复错误</h4><ul><li>当 panic! 宏执行：<ol><li>程序会打印一个错误信息</li><li>展开（unwind）、清理调用栈（Stack）</li><li>退出程序</li></ol></li></ul><div class="note orange no-icon flat"><p>何为展开调用栈？<br>是 Rust 沿着调用栈往回走，清理每个遇到的函数中的数据。</p></div><div class="note purple no-icon flat"><p>何为终止调用栈？<br>是 Rust 不进行清理，立刻停止程序。<br>内存需要 OS 进行清理。</p></div><ul><li>想让二进制文件更小，把设置从”展开”改为”终止”，在 Cargo.toml 中 profile 部分设置</li></ul><p><img src="abort.png" alt="abort"></p><h4 id="可恢复错误"><a href="#可恢复错误" class="headerlink" title="可恢复错误"></a>可恢复错误</h4><h5 id="Result-枚举"><a href="#Result-枚举" class="headerlink" title="Result 枚举"></a>Result 枚举</h5><ul><li>主要依靠 Result 枚举：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T,E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>T: 操作成功情况下，Ok 变体里返回的数据的类型</li><li><p>E：操作失败的情况下，Err 变体里返回的数据的类型</p></li><li><p>处理 Result 的方式依靠<code>match</code>表达式</p></li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>); <span class="comment">//返回 Result</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = <span class="keyword">match</span> f &#123; <span class="comment">//枚举 Result</span></span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) <span class="punctuation">-&gt;</span> file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) <span class="punctuation">-&gt;</span> &#123;</span><br><span class="line">            painc!(<span class="string">&quot;Error opening file &#123;:?&#125;&quot;</span>, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>处理 Result 的方式也可以依靠<code>unwarp</code>表达式<ul><li>如果 Result 结果是 Ok，返回 Ok 里面的值</li><li>如果 Result 结果是 Err，调用 panic！宏</li></ul></li></ul><font color="red">上述例子简写为</font><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwarp</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h5><font color="blue">1、传统形式</font><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">f</span> = <span class="keyword">match</span> f &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) <span class="punctuation">-&gt;</span> file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) <span class="punctuation">-&gt;</span> <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">Ok</span>(s),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) <span class="punctuation">-&gt;</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125; <span class="comment">//记得不要分号，加了就成为了语句而不是表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="blue">2. 以上也可以用 `?` 语法糖完成(`?`放在Result后面),作用是：</font><ul><li>如果 Result 是 Ok: Ok 中的值就是表达式的结果，然后继续执行程序。</li><li>如果 Result 是 Err：Err 就是整个函数的返回值，就像使用了 Return。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">f</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    f.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="note red no-icon flat"><p><code>?</code>语法糖会自动将错误类型转换为函数返回值需要的错误类型，实质上调用了 from 函数</p></div><font color="blue">3. 更进一步的链式调用</font><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> std::io::Read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> s)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级语言 </tag>
            
            <tag> 语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust学习（一）</title>
      <link href="/posts/38177/"/>
      <url>/posts/38177/</url>
      
        <content type="html"><![CDATA[<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="安装Rust"><a href="#安装Rust" class="headerlink" title="安装Rust"></a>安装Rust</h2><p>Rust官网：<a href="https://www.rust-lang.org/zh-CN/">官网</a><br>安装好后可以运行命令<code>cargo --version</code>检测，出现版本号则安装完毕</p><h2 id="VsCode配置"><a href="#VsCode配置" class="headerlink" title="VsCode配置"></a>VsCode配置</h2><div class="note blue no-icon flat"><p>习惯了使用专用编辑器的我对此感到十分痛苦。</p></div><p>我一共安装了三个：</p><ol><li>rust-analyzer：它会实时编译和分析你的 Rust 代码，提示代码中的错误，并对类型进行标注。</li><li>rust syntax：语法高亮</li><li>CodeLLDB：进行调试。</li></ol><div class="note green no-icon flat"><p>第一次调试时可能会出现报错，提示无法连接什么的，这时候需要挂一个梯子去官网下载vsix，然后在VsCode插件安装中选择通过vsix安装插件即可。</p></div><h1 id="通过cargo新建项目"><a href="#通过cargo新建项目" class="headerlink" title="通过cargo新建项目"></a>通过cargo新建项目</h1><p><code>cargo new 项目名称</code><br>例如，在一个空文件夹下执行该命令：<code>cargo new HelloWorld</code>，文件结构如下：<br><img src="文件结构.png" alt="文件结构"><br><code>/src/main.rs</code>为源代码<br><code>/Cargo.lock</code>为编译后生成的，负责追踪项目依赖的精确版本<br><code>/Cargo.toml</code>Cargo的配置格式，其中：</p><ul><li>pacakge 配置包的项目名，项目版本，项目作者，Rust版本</li><li>dependencies 列出项目的依赖项<div class="note pink no-icon flat"><p>在rust里面，代码的包称作crate.</p></div></li></ul><h1 id="cargo命令"><a href="#cargo命令" class="headerlink" title="cargo命令"></a>cargo命令</h1><p><code>cargo bulid</code> 构建项目<br><code>cargo run</code> 构建和运行项目<br><code>cargo check</code> 检查代码<br><code>cargo build --release</code> 为发布进行构建（编译时进行优化，时间更长但效果更好）</p><h1 id="cargo依赖-库"><a href="#cargo依赖-库" class="headerlink" title="cargo依赖(库)"></a>cargo依赖(库)</h1><h2 id="引入方法"><a href="#引入方法" class="headerlink" title="引入方法"></a>引入方法</h2><p><img src="cargo依赖.png" alt="cargo依赖"><br>如图，在Cargo.toml中的<code>[dependencies]</code>下写入需要的包即可，如果VSCode配置正确，将会自动启动服务器进行下载。</p><h2 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h2><p>需要注意的是，源crate.io的服务器全部部署在北美洲，国内访问过于缓慢，需要进行换源，具体操作是在<code>$HOME/.cargo/</code>下新建config文件，写入如下内容：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = <span class="string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span></span><br><span class="line"> </span><br><span class="line"># 替换成你偏好的镜像源</span><br><span class="line">replace-with = <span class="symbol">&#x27;tuna</span>&#x27;</span><br><span class="line"> </span><br><span class="line"># 清华大学</span><br><span class="line">[source.tuna]</span><br><span class="line">registry = <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span></span><br><span class="line"> </span><br><span class="line"># 中国科学技术大学</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = <span class="string">&quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span></span><br><span class="line"> </span><br><span class="line"># 上海交通大学</span><br><span class="line">[source.sjtu]</span><br><span class="line">registry = <span class="string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span></span><br><span class="line"> </span><br><span class="line"># rustcc社区</span><br><span class="line">[source.rustcc]</span><br><span class="line">registry = <span class="string">&quot;git://crates.rustcc.cn/crates.io-index&quot;</span></span><br></pre></td></tr></table></figure> <h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>在build后，cargo会生成Cargo.lock文件，此后的生成都将以Cargo.lock中的依赖版本进行构建，直到我们手动更新Cargo.toml后重新build，修改后的版本将被写入Cargo.lock并构建。这样保证了可重现的构建版本。</p><h1 id="Rust引入"><a href="#Rust引入" class="headerlink" title="Rust引入"></a>Rust引入</h1><p>接下来在实战中理解rust语言：</p><h2 id="猜数字-1"><a href="#猜数字-1" class="headerlink" title="猜数字-1"></a>猜数字-1</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;猜数！&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;猜测一个数！&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">fifo</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法读取行&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;你猜测的数是：&#123;&#125;&quot;</span>,guess);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>解释：</p><ol><li><code>use std::io</code> 导入库，<code>use + 库名字 + :: + 接口名字</code></li><li><code>fn</code> 代表声明一个函数，函数体依旧用花括号圈起来。</li><li><code>println!</code> Rust的输出，这是一个宏，<code>!</code>就是代表了这是一个宏</li><li><code>let fifo = 1</code> Rust的声明变量，Rust中认为变量默认都是不可变的，即一次声明不可更改。</li><li><code>mut</code> 同样是声明，其中的<code>mut</code>表示这个变量可变。</li><li><code>String::new()</code> String是Rust中的一个类型，<code>::</code>代表了后面的函数是该类型中的一个关联函数，关联函数是针对类型实现的，不是针对实例实现的，可以理解为Java中的静态方法。</li><li><code>let mut guess = String::new()</code> 代表了将可变变量guess绑定到了<code>String::new()</code>的返回值上，<code>=</code>有绑定的意思。</li><li><code>read_line(&amp;mut guess)</code> 传的是引用，这点和C++很像，为了改变guess的值，显然也要用<code>mut</code>表示这个变量可变。<div class="note pink no-icon flat"><p>Rust保证<code>&amp;</code>使用的安全性。</p></div></li><li><code>io::stdin().read_line(&amp;mut guess)</code> 其中的<code>.</code>代表了后面的函数是该实例中的一个函数。<div class="note purple no-icon flat"><p>.expect体现了Rust的安全性，这里不写这个expect编译会警告</p></div></li><li><code>println!(&quot;你猜测的数是：&#123;&#125;&quot;,guess);</code> 其中的<code>&#123;&#125;</code>为占位符，输出时会被替换为后面变量的值，多个<code>&#123;&#125;</code>按顺序进行替换。</li></ol><h2 id="猜数字-2"><a href="#猜数字-2" class="headerlink" title="猜数字-2"></a>猜数字-2</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;猜数！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secert_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;神秘数字是：&#123;&#125;&quot;</span>, secert_number);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;猜测一个数！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法读取行&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//shadow</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">guess</span>:<span class="type">u32</span> = guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Please type a number!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;你猜测的数是：&#123;&#125;&quot;</span>,guess);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secert_number) &#123;</span><br><span class="line">        Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">        Ordering::Equal =&gt; <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>),</span><br><span class="line">        Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>解释：</p><ol><li><code>use rand::Rng</code> 使用之前下载的crate.</li><li><code>let guess:u32 = guess.trim().parse().expect(&quot;Please type a number!&quot;);</code> 重复定义了guess,在Rust中，这不会报错，新定义的guess会将上文的guess掩盖，Rust一般自动推导类型，但可以通过<code>:+类型</code>显式定义类型。</li><li><code>match guess.cmp(&amp;secert_number)</code> <code>cmp</code>为比较器，比较guess和secert_number,之后在大括号中枚举返回类型所有情况的动作，程序会根据条件匹配进行执行，这是<code>match</code>的作用。</li></ol><div class="note purple no-icon flat"><p>Rust的自动推导十分强大，在这段代码中，secert_number 类型是由编译器自动推断的，一般为<code>i32</code>,但由于这里与已知为 <code>u32</code> 的 guess 进行了 cmp,所以编译器会将 secert_number 在一开始就推断为 <code>u32</code>。 </p></div><h2 id="猜数字-3"><a href="#猜数字-3" class="headerlink" title="猜数字-3"></a>猜数字-3</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;猜数！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secert_number</span> = rand::<span class="title function_ invoke__">thread_rng</span>().<span class="title function_ invoke__">gen_range</span>(<span class="number">1</span>, <span class="number">101</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;神秘数字是：&#123;&#125;&quot;</span>, secert_number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;猜测一个数！&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    </span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> guess).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;无法读取行&quot;</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//shadow</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">guess</span>:<span class="type">u32</span> = <span class="keyword">match</span> guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num) =&gt; num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Please input again!&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;你猜测的数是：&#123;&#125;&quot;</span>,guess);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">match</span> guess.<span class="title function_ invoke__">cmp</span>(&amp;secert_number) &#123;</span><br><span class="line">            Ordering::Less =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too small!&quot;</span>),</span><br><span class="line">            Ordering::Greater =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>解释：</p><ol><li>expect 会让程序 panic 后停止执行，如果我们既想要捕捉异常，也不想让程序崩溃，我们可以结合返回值类型和 match 来实现，如果返回是Ok，则说明正确执行，将值返回即可，如果返回是 Err , 那么我们就输出错误信息后 continue.</li><li>如果我们不关心例如 Err 的返回内容，只需要<code>_</code>表示即可。</li><li>Loop 是 Rust 中的无限循环。</li></ol><h1 id="Rust学习"><a href="#Rust学习" class="headerlink" title="Rust学习"></a>Rust学习</h1><h2 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h2><ul><li>声明变量使用 let 关键字</li><li>默认情况下，变量是不可变的。</li><li>声明变量时，在变量前面加上 mut ，就可以使变量可变。</li></ul><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><ul><li>常量： 常量在绑定值后不可变，与不可变的变量有区别：</li></ul><ol><li>不可以用 mut , 常量永远不可变。</li><li>声明常量使用 const 关键字，它的类型必须被标注。</li><li>常量可以在任何作用域内进行声明，包括全局作用域。</li><li>常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值。</li></ol><ul><li>在程序运行期间，常量在其声明的作用域内一直有效</li><li>命名规范： Rust 里常量使用全大写字母，每个单词之间用下划线分开。</li></ul><font color="purple">例子：const MAX_POINTS:u32 = 100_000</font><h2 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h2><ul><li>可以使用相同的名字声明新的变量，新的变量就会 shadow (隐藏) 之前声明的同名变量。</li><li>shadow 和把变量标记为 mut 是不一样的：</li></ul><ol><li>如果不使用 let 关键字，那么重新给非 mut 的变量赋值会导致编译时错误</li><li>而使用 let 声明的同名新变量 也是不可变的</li><li>使用 let 声明的同名新变量，它的类型可以与之前<font color="red">不同</font>。</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>Rust 是静态编译语言，在编译时必须知道所有变量的类型。</li></ul><ol><li>基于使用的值，编译器通常能够推断出它的具体类型。</li><li>但如果可能的类型比较多，就必须添加类型的标注，否则编译报错</li></ol><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><ul><li>一个标量类型代表一个单个的值</li><li>Rust 有四个主要的标量类型：</li></ul><ol><li>整数类型</li><li>浮点类型</li><li>布尔类型</li><li>字符类型</li></ol><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><ul><li>整数类型没有小数部分</li><li>无符号整数类型以 u 开头</li><li>有符号整数类型以 i 开头</li><li>整数类型列表：<img src="整数类型列表.png" alt="整数类型列表"><div class="note purple no-icon flat"><p>isize 和 usize 类型的位数由程序运行的计算机的架构所决定。例如如果是 64 位计算机，则位数为 64 位。</p></div></li><li>整数字面值：<img src="整数字面值.png" alt="整数字面值"></li><li>整数溢出： 在调试模式下编译出的程序，在溢出时会 panic。 但在发布模式下编译出的程序，在溢出时进行环绕操作（和C语言无符号整数一样），不会 panic。</li></ul><div class="note green no-icon flat"><p>i32 是默认类型，因为现代 CPU 上 i32 速度挺高。</p></div><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>Rust 有两种基础的浮点类型，也就是含有小数部分的类型。</p><ul><li>f32，32 位，单精度</li><li>f64，64 位，双精度</li></ul><div class="note green no-icon flat"><p>f64 是默认类型，因为现代CPU上 f64 和 f32 的速度差不多，而且精度更高。</p></div><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><ul><li>Rust 布尔类型也是两个值：true 和 false</li><li>一个字节大小</li><li>符号是 bool</li></ul><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ul><li>Rust 语言中 char 类型被用来描述语言中最基础的单个字符。</li><li>字符类型的字面值使用单引号</li><li>占用 4 字节大小 <font color="red">区别于C语言的 1 字节</font></li><li>是 Unicode 标量值，可以表示比 ASCII 多得多的字符内容：拼音、中日韩文、零长度空白字符、emoji 表情等</li></ul><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><ul><li>复合类型可以将多个值放在一个类型里</li><li>Rust 提供了两种基础的复合类型：元组（Tuple)、数组</li></ul><h4 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h4><ul><li>Tuple 可以将多个类型的多个值放在一个类型里</li><li>Tuple 的长度是固定的：一旦声明就无法改变</li><li>Tuple 创建</li></ul><ol><li>在小括号里，将值用逗号分开。</li><li>Tuple 中的每个位置都对应一个类型，Tuple 中各元素的类型不必相同。</li></ol><ul><li>Tuple 获取元素</li></ul><ol><li>可以使用模式匹配来解构一个 Tuple 来获取元素的值。</li></ol><ul><li>Tuple 访问元素</li></ul><ol><li>在 Tuple 变量使用点标记法。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>:(<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup; <span class="comment">//获取 Tuple 的元素</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, tup.<span class="number">0</span>, tup.<span class="number">1</span>, tup.<span class="number">2</span>); <span class="comment">//访问 Tuple 的元素</span></span><br></pre></td></tr></table></figure> <div class="note green no-icon flat"><p>笔者认为有点像 C 语言中的结构体。</p></div><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul><li>数组可以将多个值放在一个类型里。</li><li>数组中每个元素的类型必须相同</li><li>数组的长度也是固定的。</li><li>数组声明：在中括号里，各值用数组分开。</li><li>数组类型：用这种形式表示<code>[类型;长度]</code></li><li>如果数组中每个元素值相同，那么可以这样声明：<code>[值;长度]</code></li><li>数组访问和 C 语言一样，使用索引访问。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>:[<span class="type">i32</span>;<span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure> <h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>声明函数使用 fn 关键字</li><li>依照惯例，针对函数和变量名，Rust 使用 snake case 命名规范（所有字母小写，单词之间使用下划线分开）</li><li>函数签名里，必须声明类型。</li><li>在 -&gt; 符号后面声明函数返回值的类型，但是不可以为返回值命名</li><li>在 Rust 里面，返回值就是函数体里面最后一个表达式的值。</li><li>若想提前返回，需要使用 return 关键字，并指定一个值。</li></ul><div class="note orange no-icon flat"><p>大多数函数都以最后一个表达式的值作为返回值。</p></div> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x:<span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Another function&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>(x : <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> <ul><li>函数体由一系列语句组成，可选的由一个表达式结束。</li><li>Rust 是一个基于表达式的语言</li><li>语句是执行一些动作的指令</li><li>表达式会计算并产生一个值</li><li>函数的定义也是语句</li><li>语句不返回值，所以不可以用 let 将一个语句赋给一个变量，例如：<code>let y = (let y = 6);</code>是不正确的。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    x + <span class="number">3</span></span><br><span class="line">&#125; <span class="comment">//这是一个表达式</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    x + <span class="number">3</span>;</span><br><span class="line">&#125; <span class="comment">//这是一个语句</span></span><br><span class="line">块中最后一个表达式可以作为块值</span><br></pre></td></tr></table></figure> <div class="note red no-icon flat"><p>函数定义在后，使用在前在 Rust 中是被允许的。</p></div><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>和C大致相同。</p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><ul><li>if 表达式的条件必须是 bool 类型</li><li>if 表达式中，与条件相关联的代码块就叫做分支</li><li>写法：除了没括号之外，写法类 C</li><li>如果使用了多于一个 else if , 最好用 match 来重构代码</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;condition was true&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;condition was false&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li>Rust 提供了 3 种循环，分别是： loop , for , while</li></ul><h4 id="Loop"><a href="#Loop" class="headerlink" title="Loop"></a>Loop</h4><ul><li>Loop 关键字告诉 Rust 反复执行一块代码，直到喊停</li><li>可以在 Loop 循环中使用 break 关键字来告诉程序终止循环</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The result is:&#123;&#125;&quot;</span>, result)</span><br><span class="line"></span><br><span class="line">返回值为：<span class="number">20</span></span><br></pre></td></tr></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><ul><li>每次循环前判断一次条件，条件写法同 if</li></ul><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><ul><li>可使用 while 和 loop 来遍历集合，但效率低下且容易出错</li><li>遍历集合使用 for 循环更加简洁紧凑</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;the value is: &#123;&#125;&quot;</span>,element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历数组</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>,number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历range.rev为反向遍历</span></span><br></pre></td></tr></table></figure><h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><ul><li>Rust 的核心特性就是所有权</li><li>所有程序在运行时都必须管理他们使用计算机内存的方式</li></ul><ol><li>有些语言有垃圾收集机制，在程序运行时，他们会不断地寻找不再使用的内存。</li><li>在其它语言中，程序员必须显式的分配和释放内存。</li></ol><ul><li>Rust 采用了第三种方式：</li></ul><ol><li>内存是通过一个所有权系统来管理的，其中包含一组编译器在编译时检查的规则。</li><li>由于这种管理工作提前到编译时，所以所有权特性不会减慢程序的运行速度。</li></ol><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li>每个值都有一个变量，这个变量是该值的所有者。</li><li>每个值同时只有一个所有者</li><li>当所有者超出作用域时，该值将被删除</li><li>Scope 就是程序中一个项目的有效范围</li><li>Rust 中对于某个值来说，当拥有它的变量走出作用范围时，内存会立刻自动交还给操作系统。</li></ul><h3 id="变量和数据交互的方式：移动（Move）"><a href="#变量和数据交互的方式：移动（Move）" class="headerlink" title="变量和数据交互的方式：移动（Move）"></a>变量和数据交互的方式：移动（Move）</h3><h4 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h4><ul><li>多个变量可以与同一个数组使用一种独特的方式来交互</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>整数是已知且固定大小的值，这<font color="red">两个 5 </font>都被压到了 <font color="red">stack</font> 中，这叫<font color="red">复制</font></p><h4 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>:<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br></pre></td></tr></table></figure><p><img src="String1.png" alt="String"></p><p>在 Rust 中，只复制了栈上类似指针的内容，且为了避免由于上述规则带来二次内存释放的严重问题，所以 Rust 会复制 s1, 并且让 s1 失效，这一套操作被称为<font color="red">移动</font>。</p><div class="note red no-icon flat"><p>这样做也保证了规则中，只有一个所有者的规则。</p></div><h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><ul><li>将值传递给函数会发生移动或复制。</li><li>复制一般会是简单类型，实现 Copy 的类型</li><li>移动则是复杂类型</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">take_ownership</span>(s); <span class="comment">//s 被移动到函数里面，所有权由函数释放</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x); <span class="comment">// x 被复制了一份，复制品移动到了函数里面。</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x:&#123;&#125;&quot;</span>,x) <span class="comment">//这个是正确的，传递时为复制。</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;s:&#123;&#125;&quot;</span>,s) <span class="comment">//这个是不正确的，传递时为移动。</span></span><br><span class="line">&#125; <span class="comment">// x 被释放，s 已经被移动，这里不再释放。</span></span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><ul><li>返回值的所有权也会被移交给上层函数，由上层函数维护所有权。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2);</span><br><span class="line">&#125; 释放 s1,s3 至于 s2 已经发生移动，所有权被转移到了函数中</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    some_string</span><br><span class="line">&#125; <span class="comment">//转移some_string所有权到main中，进一步移动给s1，这是移动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    a_string</span><br><span class="line">&#125; <span class="comment">//转移a_string所有权到main中,进一步移动给s3，这是移动</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">function</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span>&#123;</span><br><span class="line">    i = <span class="number">32</span>;</span><br><span class="line">    i</span><br><span class="line">&#125; <span class="comment">//复制一份副本返回，i被释放，这是复制。</span></span><br></pre></td></tr></table></figure><h2 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h2><ul><li><code>&amp;</code>表示引用：允许引用某些值而不获取所有权。</li><li>我们把引用作为函数参数这个行为叫做借用。</li><li>和变量一样，引用默认也是不可变的。</li><li>要想让引用可变，和变量一样，在引用前加 mut 即可，例如：<code>&amp; mut s1</code></li><li>可变引用有一个重要的限制：在特定作用域内，对某一块数据，只能有一个可变的引用。（防止数据竞争）</li><li>不可以同时拥有一个可变引用和一个不变的引用，因为可变引用会让不变引用失效。</li><li>悬空引用：一个指针引用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了。</li><li>在 Rust 里，编译器可保证引用永远不是悬空引用。 </li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;&quot;</span>, s1, len);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul><li>Rust 另一种不持有所有权的数据类型：切片（Slice）</li></ul><h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><ul><li>字符串切片是指向字符串中一部分内容的<font color="red">引用</font></li><li>形式：<code>[开始索引...结束索引]</code> 左闭右开</li><li>字符串切片的范围索引必须发生在有效的 UTF-8 字符边界内，如果尝试从一个多字节的字符中创建字符串切片，就会 panic.</li><li>字符串字面值就是字符串切片。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="comment">//let hello = &amp;s[..5]; 语法糖</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br><span class="line"><span class="comment">//let world = &amp;s[..11]; 语法糖</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">whole</span> = &amp;s[<span class="number">0</span>..<span class="number">11</span>];</span><br><span class="line"><span class="comment">//let whole = &amp;s[..] 语法糖</span></span><br></pre></td></tr></table></figure><p>一个例子：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">wordIndex</span> = <span class="title function_ invoke__">first_world</span>(&amp;my_string[..]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">my_string_literal</span> = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//字符串字面值</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">worldIndex</span> = <span class="title function_ invoke__">first_world</span>(my_string_literal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">first_world</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bytes</span> = s.<span class="title function_ invoke__">as_bytes</span>(); <span class="comment">//将s生成为字符数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, &amp;item) <span class="keyword">in</span> bytes.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">b&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;s[..i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="其他类型切片"><a href="#其他类型切片" class="headerlink" title="其他类型切片"></a>其他类型切片</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hypervisor 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级语言 </tag>
            
            <tag> 语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统文件系统复习</title>
      <link href="/posts/63874/"/>
      <url>/posts/63874/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘有效化"><a href="#磁盘有效化" class="headerlink" title="磁盘有效化"></a>磁盘有效化</h1><p>一个磁盘要想真正变得有用，一般要按顺序经历以下的过程</p><ul><li>物理格式化（低级格式化）：一般在磁盘出厂时进行，主要是给磁道划分扇区，排查错误扇区。</li><li>分区：由软件进行，比如FDISK</li><li>逻辑格式化（高级格式化）：建立文件系统</li><li>安装操作系统。</li></ul><h1 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是指一组带标识（标识即为文件名）的、在逻辑上有完整意义的信息项的序列。<br><div class="note orange no-icon flat"><p>信息项：构成文件内容的基本单位（单个字节，或多个字节），各信息项之间具有顺序关系。<br>也就是说，文件内容是由信息项组成的。</p></div></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>文件体、文件说明</p><h3 id="文件体"><a href="#文件体" class="headerlink" title="文件体"></a>文件体</h3><p>文件内容</p><h3 id="文件说明"><a href="#文件说明" class="headerlink" title="文件说明"></a>文件说明</h3><p>文件存储和管理的相关信息，比如文件名、文件内部标识、文件存储地址、访问权限、访问时间。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="文件控制块-FCB"><a href="#文件控制块-FCB" class="headerlink" title="文件控制块(FCB)"></a>文件控制块(FCB)</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>保存管理文件所需的所有有关信息（文件属性或元数据）</p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><ul><li>基本信息：文件名、物理位置、文件逻辑结构、文件物理结构</li><li>访问控制信息：文件所有者、访问权限</li><li>使用信息：创建时间、上一次修改时间、当前使用信息。</li></ul><h2 id="文件逻辑结构"><a href="#文件逻辑结构" class="headerlink" title="文件逻辑结构"></a>文件逻辑结构</h2><p>我们用户看到的文件表面上的行文结构，举一个这样的例子：<br><div class="note pink no-icon flat"><p>程序员在写代码时其实考虑的都是文件的逻辑结构，比如顺序文件，索引文件（什么一级索引，多级索引，B树索引，Hash索引都是文件的逻辑结构），也就是程序在写代码时思考如何从文件中读数据时，脑袋里面装的都是文件的逻辑，把文件视为一个整体，一整块的。</p><p>比如对于逻辑结构包含索引的文件，程序员写代码时首先会使用c语言的read系统调用读文件中的索引，传入的参数是索引在哪个文件、相对于文件开头多少偏移、多少字节的数据，这些都是在根据文件的逻辑在思考数据的位置。</p><p>然后从用户态切换到内核态，操作系统开始根据文件的物理结构来读数据的。</p></div></p><h2 id="文件物理结构"><a href="#文件物理结构" class="headerlink" title="文件物理结构"></a>文件物理结构</h2><h3 id="连续结构"><a href="#连续结构" class="headerlink" title="连续结构"></a>连续结构</h3><h4 id="存放图示"><a href="#存放图示" class="headerlink" title="存放图示"></a>存放图示</h4><p><img src="连续结构.png" alt="连续结构"></p><h4 id="存取图示"><a href="#存取图示" class="headerlink" title="存取图示"></a>存取图示</h4><p><img src="顺序存取方式.png" alt="顺序存取方式"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>结构简单，开销小</li><li>支持随机读取，速度快</li><li>连续存时速度快</li><li>文件长度不易改变<div class="note orange no-icon flat"><p>所以只适用于文件长度不怎么改变的系统中。<br>这种排序使作业访问磁盘时需要的寻道数和寻道时间减少，读取时间可就不见得了。</p></div><h3 id="串联-链接文件结构"><a href="#串联-链接文件结构" class="headerlink" title="串联/链接文件结构"></a>串联/链接文件结构</h3><h4 id="存放图示-1"><a href="#存放图示-1" class="headerlink" title="存放图示"></a>存放图示</h4><img src="存放图示.png" alt="存放图示"><h4 id="存取图示-1"><a href="#存取图示-1" class="headerlink" title="存取图示"></a>存取图示</h4><img src="串联链接文件图示.png" alt="串联链接文件图示"><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3></li><li>空间利用率高、较好利用辅存空间</li><li>文件动态扩充和修改容易</li><li>顺序存取效率高</li><li>不能随机访问</li><li>可靠性较差</li><li>指针本身占用空间<div class="note orange no-icon flat"><p>也分为显式链接和隐式链接两种，前面的是隐式链接。显式链接就是FAT表。</p></div><h3 id="索引文件结构"><a href="#索引文件结构" class="headerlink" title="索引文件结构"></a>索引文件结构</h3><h4 id="存放图示-2"><a href="#存放图示-2" class="headerlink" title="存放图示"></a>存放图示</h4><img src="索引存放图示.png" alt="存放图示"><h4 id="存取图示-2"><a href="#存取图示-2" class="headerlink" title="存取图示"></a>存取图示</h4><img src="索引文件图示.png" alt="索引文件图示"><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4>查索引文件需要访问内存两次，一次是查索引表、一次是查文件。<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4></li><li>集中了链接文件和顺序文件的优点</li><li>本身带来了更大的系统开销（时间上、内存上）</li></ul><h4 id="组织形式"><a href="#组织形式" class="headerlink" title="组织形式"></a>组织形式</h4><ul><li>链接模式：一个盘块一个索引表、多个索引表链接起来</li><li>多级索引：将一个大文件的所有索引表（二级索引）的地址放在另一个索引表（一级索引）中</li><li>综合模式：直接索引方式与间接索引方式结合<br><img src="综合模式.png" alt="综合模式"></li></ul><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h3><p>目录项＝文件名＋FCB<br><img src="直接法.png" alt="直接法"></p><h3 id="间接法"><a href="#间接法" class="headerlink" title="间接法"></a>间接法</h3><p>目录项＝文件名＋FCB的地址<br><img src="间接法.png" alt="间接法"><br>在这里，FCB的地址叫法也不太合适，因为FCB包含文件名，但显然文件名已经在目录项里了，这里准确的说法是i节点的地址。<br><div class="note blue no-icon flat"><p>直接法会让目录项变得庞大，那么在检索的时候，一个块里面能容纳的目录项就会变少，会导致多次访问磁盘，造成速度下降。<br>间接法会让目录项变得很小，只有文件名和一个指针，那么在检索的时候，一个块里面能容纳的目录项就会很多，访问一次磁盘就能拿到很多的目录项，提高了性能。</p></div></p><h2 id="文件名处理"><a href="#文件名处理" class="headerlink" title="文件名处理"></a>文件名处理</h2><p>由于实际需要，常常需要支持长文件名。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>在目录项中，将文件名的长度固定为255字符（但显然是不合理的，造成了大量的空间浪费）</li><li>目录项长度可变：目录项的长度不再固定，随具体存放内容而定。（回收时造成困难）</li><li>目录项长度固定，把长度不定的文件名统一放在目录文件的末尾<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><img src="长文件名.png" alt="长文件名"></li></ul><h1 id="软-硬连接"><a href="#软-硬连接" class="headerlink" title="软/硬连接"></a>软/硬连接</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><img src="软硬链接.png" alt="软硬链接"></p><h2 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h2><p><img src="硬链接.png" alt="硬链接"></p><h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h2><p><img src="软连接.png" alt="软连接"><br><div class="note blue no-icon flat"><p>硬连接可以保证只要仍然有链接，该文件就不会被真正删除。<br>软连接在真正指向i节点的目录项被删除后（即文件主被删除后），连接都会失效。</p></div></p><h1 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>目录项（FCB）分解、当前目录、磁盘碎片整理、块高速缓存、磁盘调度、提前读取、合理分配磁盘空间、信息的优化分布、RAID技术等。</p><h2 id="块高速缓存"><a href="#块高速缓存" class="headerlink" title="块高速缓存"></a>块高速缓存</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>在内存中为磁盘块设置的一个缓冲区，保存了磁盘中某些块的副本。当对文件系统进行操作的时候，如果块在内存内可以直接访问，否则调入后再访问。</p><h3 id="组织形式-1"><a href="#组织形式-1" class="headerlink" title="组织形式"></a>组织形式</h3><p><img src="块高速缓存组织形式.png" alt="块高速缓存组织形式"><br><div class="note orange no-icon flat"><p>总结就是一个双向链表，一个哈希表加速访问。<br>访问一次挂到最后。<br>替换时记得考虑脏位（是否需要写回）</p></div></p><h2 id="FCB分解法"><a href="#FCB分解法" class="headerlink" title="FCB分解法"></a>FCB分解法</h2><p>适用于直接法存储目录项，将FCB割成两块，小块继续存在远处，大块由小块指针索引。<br>在这种情况下，如果要访问完整的FCB，需要在找到页目录项后再次访问一次磁盘把剩下的大块找全。<br><div class="note orange no-icon flat"><p>感觉就是间接法的思路，但是不彻底。       </p></div></p><h1 id="FAT12"><a href="#FAT12" class="headerlink" title="FAT12"></a>FAT12</h1><h2 id="FAT表项解析簇号"><a href="#FAT表项解析簇号" class="headerlink" title="FAT表项解析簇号"></a>FAT表项解析簇号</h2><p><img src="解析簇号.png" alt="解析簇号"><br><div class="note orange no-icon flat"><p>簇号是12位，FAT表是一个整数数组，也就是32位，那么如何对应是一个问题：<br>3个字节一循环，前8位黏在一起分配，拆开中间8位为两个四位，后四位与前面的8位拼接，后面的8位与前四位拼接。依次循坏……</p></div></p><h1 id="虚拟文件系统VFS"><a href="#虚拟文件系统VFS" class="headerlink" title="虚拟文件系统VFS"></a>虚拟文件系统VFS</h1><h2 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h2><p><img src="VFS.png" alt="VFS"><br><div class="note blue no-icon flat"><p>个人理解，VFS实现了在一个设备上挂载多个文件系统，对外呈现统一的接口。</p></div></p>]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统磁盘复习</title>
      <link href="/posts/22605/"/>
      <url>/posts/22605/</url>
      
        <content type="html"><![CDATA[<h1 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>硬盘的0柱面、0磁头、1扇区称为主引导扇区。<br><div class="note orange no-icon flat"><p>主引导扇区是在硬盘分区时由分区软件写入的（FDISK），因而不属于任何操作系统，所以分区时不进行操作系统引导扇区的写入。</p></div></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>前446字节为启动代码（BootLoader）<br>后面64字节是分区表（DPT），一共可以记录4个分区。<br>最后有2个字节是幻数，标识这是一个被分区的硬盘<br><div class="note purple no-icon flat"><p>硬盘分区有三种，主磁盘分区、扩展磁盘分区、逻辑分区。<br>主分区只能有一个是激活（活动）的，其余是未激活。<br>分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，也可以不全分，剩下的部分就浪费了。<br>扩展分区不能直接使用，必须分成若干逻辑分区。所有的逻辑分区都是扩展分区的一部分。</p></div></p><h2 id="DPT表项"><a href="#DPT表项" class="headerlink" title="DPT表项"></a>DPT表项</h2><p><img src="DPT表项.png" alt="DPT表项"></p><h1 id="磁盘分类"><a href="#磁盘分类" class="headerlink" title="磁盘分类"></a>磁盘分类</h1><h2 id="固定头磁盘"><a href="#固定头磁盘" class="headerlink" title="固定头磁盘"></a>固定头磁盘</h2><p>磁头相对于盘片径向方向固定的，称为固定头磁盘，每个磁道一个磁头。</p><h2 id="活动头磁盘"><a href="#活动头磁盘" class="headerlink" title="活动头磁盘"></a>活动头磁盘</h2><p>磁头可移动的、可以来回伸缩定位磁道的，称为活动头磁盘</p><h2 id="固定盘磁盘"><a href="#固定盘磁盘" class="headerlink" title="固定盘磁盘"></a>固定盘磁盘</h2><p>磁盘永久固定在磁盘驱动器内，称为固定盘磁盘。</p><h2 id="可换盘磁盘"><a href="#可换盘磁盘" class="headerlink" title="可换盘磁盘"></a>可换盘磁盘</h2><p>磁盘可移动和替换的，称为可换盘磁盘。</p><h1 id="磁盘地址与块号的转换"><a href="#磁盘地址与块号的转换" class="headerlink" title="磁盘地址与块号的转换"></a>磁盘地址与块号的转换</h1><p>先记忆一个知识，一个逻辑块号的大小为一个扇区的大小。<br>一般情况下、先填满扇区、再填满磁道、再填满柱面。<br>在此基础上。可进行如下转换</p><h2 id="已知块号"><a href="#已知块号" class="headerlink" title="已知块号"></a>已知块号</h2><p><code>柱面号 = 块号 / （磁头数 * 扇区数）</code><br><code>磁头号 = （块号 % （磁头数 * 扇区数）） / 扇区数</code><br><code>扇区号 = （块号 % （磁头数 * 扇区数）） % 扇区数</code></p><h2 id="已知磁盘地址"><a href="#已知磁盘地址" class="headerlink" title="已知磁盘地址"></a>已知磁盘地址</h2><p><code>块号 = 柱面号 * 磁头数 * 扇区数 + 磁头号 * 扇区数 + 扇区号</code><br><div class="note orange no-icon flat"><p>磁头数是一个让人迷惑的说法，但确实是正确的，更通俗的说法是一个柱面里面有多少磁道，但一个盘面对应一个磁头，所以说磁头数也没毛病。<br>当然，有些题会直接告诉你一个柱面里面有多少磁道，这就是公式中磁头数。<br>显然，这里认为它是活动头磁盘。</p></div></p><h3 id="已知块号-1"><a href="#已知块号-1" class="headerlink" title="已知块号"></a>已知块号</h3><p><code>柱面号 = 块号 / （磁头数 * 扇区数）</code><br><code>磁头号 = （块号 % （磁头数 * 扇区数）） / 扇区数</code><br><code>扇区号 = （块号 % （磁头数 * 扇区数）） % 扇区数</code></p><h1 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h1><ul><li>寻道时间：把磁头从当前位置移动到指定磁道上所经历的时间。$${T_S} = m \times n + s$$</li><li>旋转延迟时间：盘面转到指定扇区所需要的时间$${T_r} = 1/(2r)$$</li><li>传输时间：把数据从磁盘写入或读出所经历的时间$${T_t} = b/(rN)$$大小与所读/写的字节数b,旋转速度r以及磁道上的字节数N有关。</li><li>访问时间<br>访问时间 = 寻道时间 + 旋转延迟时间 + 传输时间</li></ul><div class="note blue no-icon flat"><p>表示存储容量、文件大小时K等于1024（通常用大写的K）<br>表示传输速率时k等于1000（通常用小写的k）<br>当然，这是通常，笔者也遇到过KB/S表示的单位是1000的，也遇到过单位是1024的。所以还是得看题目而定。<br>但留个心眼知道可以表示1000即可。</p></div><h1 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h1><h2 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>按访问请求到达的先后次序服务。</p><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="先来先服务.png" alt="先来先服务"></p><h2 id="最短寻道时间优先算法（SSTF）"><a href="#最短寻道时间优先算法（SSTF）" class="headerlink" title="最短寻道时间优先算法（SSTF）"></a>最短寻道时间优先算法（SSTF）</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>优先选择距离当前磁头最近的访问请求进行服务。</p><h3 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h3><p><img src="SSTF.png" alt="SSTF"></p><h2 id="扫描算法（SCAN）"><a href="#扫描算法（SCAN）" class="headerlink" title="扫描算法（SCAN）"></a>扫描算法（SCAN）</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。<br><div class="note orange no-icon flat"><p>准确的说，会一直保持一个方向走到尽头，再转向。</p></div></p><h3 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h3><p><img src="SCAN.png" alt="SCAN"></p><h2 id="循环扫描算法（CSCAN）"><a href="#循环扫描算法（CSCAN）" class="headerlink" title="循环扫描算法（CSCAN）"></a>循环扫描算法（CSCAN）</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>在扫描算法的基础上加一条，返回时不处理任何请求，快速返回后再次扫描。</p><h3 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h3><p><img src="CSCAN.png" alt="CSCAN"></p><h2 id="LOOK算法"><a href="#LOOK算法" class="headerlink" title="LOOK算法"></a>LOOK算法</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>SCAN的改进，当前方向没有请求就立刻转向。</p><h2 id="CLOOK算法"><a href="#CLOOK算法" class="headerlink" title="CLOOK算法"></a>CLOOK算法</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>CSCAN的改进，当前方向没有请求就转向快速返回。<br><div class="note green no-icon flat"><p>一般意义下，不强调的话，认为SCAN就是LOOK,CSCAN就是CLOOK。</p></div></p><h2 id="调度算法比较"><a href="#调度算法比较" class="headerlink" title="调度算法比较"></a>调度算法比较</h2><p><img src="算法比较.png" alt="算法比较"></p><h1 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h1><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p><img src="位图法.png" alt="位图法"></p><h2 id="空闲表"><a href="#空闲表" class="headerlink" title="空闲表"></a>空闲表</h2><p><img src="空闲表.png" alt="空闲表"></p><h2 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h2><p>原来管理空白页面的链表法在这里不太适用，因为块实在太多了，所以引入成组链接法。<br><div class="note blue no-icon flat"><p>笔者认为是链表和空闲表的杂交。</p></div></p><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>把空白物理块分成组，在通过指针把组与组之间链接起来，这种管理空白块的方法称为成组链接法。</p><h3 id="图示-4"><a href="#图示-4" class="headerlink" title="图示"></a>图示</h3><p><img src="成组链接法.png" alt="成组链接法"><br>解释：专用块代表这一块是专门记录哪些块是空闲块，第一个表项是专门记录下一个专用块的位置，其余是真正的空闲块位置。</p><h2 id="其余方法"><a href="#其余方法" class="headerlink" title="其余方法"></a>其余方法</h2><p><img src="UFS.png" alt="UFS"><br><img src="类页表法.png" alt="类页表法"></p><h1 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h1><p>廉价冗余磁盘阵列</p><h2 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h2><p><img src="RAID0.png" alt="RAID0"></p><h2 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h2><p><img src="RAID1.png" alt="RAID1"></p><h2 id="RAID2"><a href="#RAID2" class="headerlink" title="RAID2"></a>RAID2</h2><p><img src="RAID2.png" alt="RAID2"></p><h2 id="RAID3"><a href="#RAID3" class="headerlink" title="RAID3"></a>RAID3</h2><p><img src="RAID3.png" alt="RAID3"></p><h2 id="RAID4"><a href="#RAID4" class="headerlink" title="RAID4"></a>RAID4</h2><p><img src="RAID4.png" alt="RAID4"></p><h2 id="RAID5"><a href="#RAID5" class="headerlink" title="RAID5"></a>RAID5</h2><p><img src="RAID5.png" alt="RAID5"></p><h2 id="RAID6"><a href="#RAID6" class="headerlink" title="RAID6"></a>RAID6</h2><p><img src="RAID6.png" alt="RAID6"></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><img src="RAID比较.png" alt="RAID比较"><br><div class="note blue no-icon flat"><p>一句话总结，RAID0实现了并行访问，RAID1镜像保存，RAID2海明码，RAID3字节存储，单独盘奇偶校验；RAID4块存储，单独盘奇偶校验；RAID5，奇偶校验块错开融入数据盘；RIAD6，RAID5的基础上double校验块。</p></div></p><h2 id="提高I-O速度"><a href="#提高I-O速度" class="headerlink" title="提高I/O速度"></a>提高I/O速度</h2><ul><li>氪金买好磁盘</li><li>并行化处理（RAID0)</li><li>采用适当的调度算法</li><li>设置高速缓冲区</li></ul>]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统外设管理复习</title>
      <link href="/posts/42377/"/>
      <url>/posts/42377/</url>
      
        <content type="html"><![CDATA[<h1 id="外设管理"><a href="#外设管理" class="headerlink" title="外设管理"></a>外设管理</h1><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><ul><li>提高效率：通过缓存等机制，匹配CPU的速度</li><li>方便用户：统一了繁多的外设，提供了统一的访问方法</li><li>方便控制：方便OS对外设的控制</li></ul><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li>提供接口</li><li>设备的分配、释放</li><li>设备的访问、控制</li><li>I/O缓存和调度<div class="note pink no-icon flat"><p>设备的分配和释放是逻辑I/O,实际上与设备无关<br>设备的访问和控制通过设备驱动程序完成，是真正的I/O</p></div></li></ul><h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><p>对外设的控制是通过外设提供的控制器进行的，包括控制寄存器、状态寄存器、以及一些数据的寄存器。<br>通过读写这些寄存器我们就实现了对外设的控制</p><h2 id="I-O分类"><a href="#I-O分类" class="headerlink" title="I/O分类"></a>I/O分类</h2><h1 id="数据组织"><a href="#数据组织" class="headerlink" title="数据组织"></a>数据组织</h1><ul><li>块设备：以数据块为单位存储、传输信息。传输速率高，可随机读写</li><li>字符设备：以字符为单位存储、传输信息。传输速率低，不可随机读写</li></ul><h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><ul><li>存储设备</li><li>传输设备</li><li>人机交互设备</li></ul><h1 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h1><ul><li>独占设备：同时只能由一个设备访问</li><li>共享设备：同时允许多个设备访问</li><li>虚设备：在一类设备上模拟另一类设备</li></ul><h1 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="设备控制器.png" alt="设备控制器"></p><h2 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h2><ul><li>接受和识别CPU指令</li><li>数据交换：CPU与控制器、控制器与设备</li><li>设备状态的了解和报告</li><li>设备地址识别</li><li>缓冲区</li><li>对设备传来的数据进行差错检测</li></ul><h2 id="I-O硬件组成"><a href="#I-O硬件组成" class="headerlink" title="I/O硬件组成"></a>I/O硬件组成</h2><ul><li>控制器与CPU接口：数据寄存器、控制寄存器、状态寄存器</li><li>控制器与设备接口：数据信号、控制信号、状态信号</li><li>I/O逻辑：用于实现CPU对I/O设备的控制</li></ul><p><img src="设备控制器组成.png" alt="设备控制器组成"><br><div class="note green no-icon flat"><p>设备控制器是一个硬件</p></div></p><h2 id="I-O地址映射方式"><a href="#I-O地址映射方式" class="headerlink" title="I/O地址映射方式"></a>I/O地址映射方式</h2><ul><li>内存映像编址：控制器的内存/寄存器作为物理内存空间的一部分</li><li>I/O独立编址：I/O的地址为新的空间的一部分<div class="note pink no-icon flat"><p>内存映像编址让其可以通过正常的所有指令访问I/O设备，因为地位相同<br>I/O独立编址让其只能通过特殊的访问指令来访问I/O设备，因为地位不同</p></div></li></ul><h2 id="I-O控制方式"><a href="#I-O控制方式" class="headerlink" title="I/O控制方式"></a>I/O控制方式</h2><ul><li>程序控制：缺乏硬件支持的程序只能通过不断询问外设状态的忙等方式来等待I/O结束<br><img src="软件控制.png" alt="软件控制"></li><li>中断驱动：当I/O操作结束后由设备控制器主动地来通知设备驱动程序说这次结束，以中断的方式<br><img src="中断驱动.png" alt="中断驱动"></li><li>DMA: 直接存储器访问方式，通俗的说就是由专门的控制器来完成内存和外设之间的数据传输工作<br><img src="DMA.png" alt="DMA"></li><li>通道：极其类似于DMA，虽然叫通道，但是一种处理器，来完成内存和外设之间的数据传输工作，接管CPU的部分权限更多一点<br><img src="IO通道.png" alt="IO通道"><h3 id="通道分类"><a href="#通道分类" class="headerlink" title="通道分类"></a>通道分类</h3></li><li>字节多路通道：以字节为单位在多个设备之间交叉工作，这边取一个字节，换个设备再取一个</li><li>数组选择通道：每次针对一个设备传送一批数据，只能一个个处理设备的传输请求。</li><li>数组多路通道：前两者的聚合。<div class="note purple no-icon flat"><p>通道强于DMA的一点就是，一个DMA配一个设备，而一个通道可以同时服务好几个设备。</p></div></li></ul><h2 id="I-O软件设计"><a href="#I-O软件设计" class="headerlink" title="I/O软件设计"></a>I/O软件设计</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="分层设计"><a href="#分层设计" class="headerlink" title="分层设计"></a>分层设计</h4><p>分层设计，上层注重提供统一接口，下层注重与硬件的对接</p><h4 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h4><p>上层请求设备逻辑设备名字，由软件对应物理设备名字。</p><h5 id="实现结构"><a href="#实现结构" class="headerlink" title="实现结构"></a>实现结构</h5><p>设备逻辑表：为了实现设备的独立性，系统必须设置一张逻辑设备表LUT(Logical Unit Table)，用于将应用程序中所使用的逻辑设备名映射为物理设备名。<br>该表的每个表目中包含了三项，逻辑设备名、物理设备名、设备驱动程序的入口地址。通过逻辑设备名，系统可以查找LUT，便可找到物理设备和驱动程序。<br><img src="LUT.png" alt="LUT"><br><div class="note orange no-icon flat"><p>这里很像物理和逻辑地址之间的映射，但比较简单，通过LUT就可以完成。</p></div></p><h4 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h4><h4 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h4><ul><li>与设备密切相关的代码放在设备驱动程序中，每个设备驱动程序处理一种设备类型。</li><li>设备驱动程序的任务是接收来自与设备无关的上层软件的抽象请求，并执行这个请求。</li><li>每一个控制器都设有一个或多个设备寄存器，用来存放向设备发送的命令和参数。设备驱动程序负责释放这些命令，并监督它们正确执行<div class="note green no-icon flat"><p>由于密切相关，所以驱动程序只能由设备生产商维护，不能由通用性的操作系统来维护。<br>除此之外，控制器不是设备自带的，是主板上内置的，驱动程序通过按照规律通过控制器发射信号来与设备交互。</p></div><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><h5 id="程序层"><a href="#程序层" class="headerlink" title="程序层"></a>程序层</h5></li><li>自动配置和初始化子程序。</li><li>I/O操作子程序</li><li>中断服务子程序<h5 id="函数层"><a href="#函数层" class="headerlink" title="函数层"></a>函数层</h5></li><li>驱动程序初始化函数、驱动函数卸载函数、申请设备函数、卸载设备函数</li><li>I/O操作函数</li><li>中断处理函数<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4></li><li>动态可加载：内核对驱动程序召之即来，挥之即去。</li><li>无害性：即使这个驱动程序不服务于任何外设，也对系统无害</li></ul><h2 id="I-O缓冲管理"><a href="#I-O缓冲管理" class="headerlink" title="I/O缓冲管理"></a>I/O缓冲管理</h2><h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><p>只有一个缓冲区，只有缓冲区内的数据被读取完毕后，I/O设备才能继续向缓冲区放入数据，<em>所以CPU从缓冲区读出数据和I/O设备向缓冲区写入数据不能并行。</em><br><img src="单缓冲.png" alt="单缓冲"></p><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><p>有两个缓冲区，I/O设备塞满一个缓冲区后，可以切换到下一个缓冲区继续塞，此时CPU可以从原来的缓冲区读出数据，<em>实现了CPU从缓冲区读出数据和I/O设备向缓冲区写入数据并行。</em><br><img src="双缓冲.png" alt="双缓冲"><br><div class="note green no-icon flat"><p>仔细思考一下这里，只有读出和读入速度差不多，两个缓冲区才刚刚好。</p></div></p><h3 id="多缓冲"><a href="#多缓冲" class="headerlink" title="多缓冲"></a>多缓冲</h3><p>有很多缓冲区，为了切换方便组成了环形。<br>一般有三个指针，第一个指向下一个空缓冲，第二个指向下一个满的缓冲，第三个指向目前CPU正在读出的缓冲区。<br><img src="环形缓冲.png" alt="环形缓冲"></p><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>前面的听起来都很好，但是是对于某一个进程的，如果进程很多，开很多的循环缓冲的话，会很占用空间，这就引入了缓冲池，在池中设置了多个可供若干个进程共享的缓冲区。</p><h4 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h4><p>将相同状态的缓冲区链接成队列。<br><img src="缓冲池.png" alt="缓冲池"></p><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p><img src="工作模式.png" alt="工作模式"></p><ul><li>收容输入</li><li>提取输入</li><li>收容输出</li><li>提取输出</li></ul><h2 id="I-O设备分配"><a href="#I-O设备分配" class="headerlink" title="I/O设备分配"></a>I/O设备分配</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>面对很多的进程，I/O设备总是有限的，同样需要进行分配。</p><h3 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h3><ul><li>进程轮流使用外设：键盘、鼠标<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5></li></ul><ol><li>设备控制表：一个设备一张，描述设备的特性和状态<br><img src="DCT.png" alt="设备控制表"></li><li>控制器控制表：一个控制器一张，描述I/O控制器的配置和状态。<br><img src="COCT.png" alt="控制器控制表"></li><li>通道控制表：一个通道一张，描述通道工作状态。<br><img src="CHCT.png" alt="通道控制表"></li><li>系统设备表：一个系统一张，反映设备资源的状态及其设备控制表的入口。<br><img src="SDT.png" alt="系统设备表"><h5 id="分配方法"><a href="#分配方法" class="headerlink" title="分配方法"></a>分配方法</h5><img src="设备分配方法.png" alt="设备分配方法"></li></ol><ul><li>通过一个虚拟设备来将外设与应用进程隔开、只由虚拟设备来使用设备<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4>SPOOLing技术：应用程序进行I/O操作时，只是和SPOOLing程序交换数据，可以称为“虚拟I/O”。应用程序实际上是从SPOOLing程序的缓冲池中读出数据或把数据送入缓冲池，而不是跟实际的外设进行I/O操作。<br><img src="Spooling.png" alt="Spooling"></li></ul><h2 id="I-O操作"><a href="#I-O操作" class="headerlink" title="I/O操作"></a>I/O操作</h2><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ol><li>磁盘把数据装载进内核的内存空间</li><li>内核的内存空间的数据copy到用户的内存空间<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><img src="五模型.png" alt="五模型.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统调度复习</title>
      <link href="/posts/30118/"/>
      <url>/posts/30118/</url>
      
        <content type="html"><![CDATA[<h1 id="调度类型"><a href="#调度类型" class="headerlink" title="调度类型"></a>调度类型</h1><h2 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h2><p><img src="调度分类.png" alt="调度类型"></p><h2 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h2><ul><li>高级调度：作业之间的调度，调度执行哪个作业，不执行哪个作业</li><li>中级调度：调度页面的换入换出</li><li>低级调度：调度进程<h1 id="概念积累"><a href="#概念积累" class="headerlink" title="概念积累"></a>概念积累</h1><h2 id="周转时间"><a href="#周转时间" class="headerlink" title="周转时间"></a>周转时间</h2>作业从提交到完成（得到结果）所经历的时间<div class="note green no-icon flat"><p>放进去就开始计时，什么时候吐出来什么时候停止计时，至于它在里面是在被执行还是被阻塞，不管。</p></div><h2 id="带权周转时间"><a href="#带权周转时间" class="headerlink" title="带权周转时间"></a>带权周转时间</h2>周转时间/执行时间<h2 id="平均周转时间"><a href="#平均周转时间" class="headerlink" title="平均周转时间"></a>平均周转时间</h2>作业周转总时间/作业数<h2 id="平均带权周转时间"><a href="#平均带权周转时间" class="headerlink" title="平均带权周转时间"></a>平均带权周转时间</h2>带权周转总时间/作业数<h2 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h2>发出请求到系统首次给出响应的时间。<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2>单位时间内所完成的作业数<div class="note green no-icon flat"><p>这里注意吞吐量不是平均周转时间的倒数，这是由于并发执行的作业在时间上可以重叠。</p></div><img src="概念总结.png" alt="概念总结"><h1 id="进程占用CPU的方式"><a href="#进程占用CPU的方式" class="headerlink" title="进程占用CPU的方式"></a>进程占用CPU的方式</h1><h2 id="不可抢占式"><a href="#不可抢占式" class="headerlink" title="不可抢占式"></a>不可抢占式</h2>一旦处理器分配给一个进程，它就一直占用处理器，直到该进程自己因调用原语操作或等待I/O等原因而进入阻塞状态，或时间片用完时才让出<br>处理器，重新进行。<div class="note blue no-icon flat"><p>注意描述，不可抢占并不代表它会从头执行到尾，只是说不会被其他进程抢占，自己作那没办法。</p></div><h2 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h2>就绪队列中一旦有优先级高于当前运行进程优先级的进程存在时，便立即进行进程调度，把处理器转给优先级高的进程。</li></ul><h1 id="批处理系统调度算法"><a href="#批处理系统调度算法" class="headerlink" title="批处理系统调度算法"></a>批处理系统调度算法</h1><h2 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h2><h3 id="调度对象"><a href="#调度对象" class="headerlink" title="调度对象"></a>调度对象</h3><p>作业、进程</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>顾名思义，谁先来拷打谁，按照来的顺序执行。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>非抢占式</li><li>利于长作业，不利于短作业<div class="note purple no-icon flat"><p>（长作业一次执行到爽，短作业跟在后面早饿死了）</p></div></li><li>有利于CPU繁忙的作业，不利于I/O繁忙的作业。<div class="note green no-icon flat"><p>因为I/O一次进程就被切走了，很久才能回来，早饿死了</p></div><h2 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h2><h3 id="调度对象-1"><a href="#调度对象-1" class="headerlink" title="调度对象"></a>调度对象</h3>作业、进程<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3>顾名思义，现在有一堆进程，先选择短的执行。<h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3></li><li>改善平均周转时间</li><li>非抢占式</li><li>改善带权平均周转时间</li><li>提高吞吐量</li><li>利于短作业，不利于长作业</li><li>未能依据作业的紧迫程度来划分执行的优先级</li><li>实际上作业的执行时间是很难估计的，这样做可能会由于错误的估计而影响调度</li></ul><h2 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h2><h3 id="调度对象-2"><a href="#调度对象-2" class="headerlink" title="调度对象"></a>调度对象</h3><p>作业、进程</p><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将短作业优先进行改进，改进为抢占式，这就是最短剩余时间优先算法了，即一个新就绪的进程比当前运行进程具有更短的完成时间，系统抢占当前进程，选择新就绪的进程执行。<br><div class="note green no-icon flat"><p>这里的就绪包括由于新增而就绪、也包括I/O结束后就绪</p></div></p><h3 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h3><p>继承短作业优先的特性，饿死的还是长作业。</p><h2 id="最高相应比优先"><a href="#最高相应比优先" class="headerlink" title="最高相应比优先"></a>最高相应比优先</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>HRRF（最高响应比）算法实际上是FCFS（先来先服务）算法和SJF（短作业优先）算法的折衷。</p><h3 id="特性-3"><a href="#特性-3" class="headerlink" title="特性"></a>特性</h3><ul><li>排序依据是RP（响应比），公式如下<br><img src="RP.png" alt="RP"></li><li>都饿不死，挺好</li><li>每次调度时都要计算一次，性能开销增大</li></ul><h1 id="交互式系统调度算法"><a href="#交互式系统调度算法" class="headerlink" title="交互式系统调度算法"></a>交互式系统调度算法</h1><h2 id="时间片轮转"><a href="#时间片轮转" class="headerlink" title="时间片轮转"></a>时间片轮转</h2><h3 id="调度对象-3"><a href="#调度对象-3" class="headerlink" title="调度对象"></a>调度对象</h3><p>进程</p><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>将系统中所有的就绪进程按照FCFS原则，排成一个队列<br>每次调度时将CPU分派给队首进程，让其执行一/多个时间片。时间片的长度从几个ms到几百ms。<br>在一个时间片结束时，发生时钟中断，暂停当前进程的运行，根据剩余时间片决定是切换还是继续执行。<br>切换的话就将当前进程送到队尾，从队首取新的进程执行<br><div class="note green no-icon flat"><p>当然，如果时间片中间被阻塞了，也是会发生进程切换的。</p></div></p><h3 id="特性-4"><a href="#特性-4" class="headerlink" title="特性"></a>特性</h3><ul><li>响应时间：<br><img src="响应时间.png" alt="响应时间"></li><li>时间片过长，退化为先来先服务，过短，切的太快，反而效果欠佳。</li></ul><h2 id="优先级算法"><a href="#优先级算法" class="headerlink" title="优先级算法"></a>优先级算法</h2><h3 id="调度对象-4"><a href="#调度对象-4" class="headerlink" title="调度对象"></a>调度对象</h3><p>作业、进程</p><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>本算法是平衡各进程对响应时间的要求，根据优先级安排队列进行调度。<br><img src="优先级.png" alt="优先级"></p><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><ul><li>静态优先级：创建进程时就确定，直到进程终止前都不改变。通常是一个整数</li><li>动态优先级：在创建进程时赋予的优先级，在进程运行过程中可以自动改变。<div class="note green no-icon flat"><p>比如等久了优先级提高，执行久了优先级降低。</p></div><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li><li>可分为抢占式和非抢占式。</li><li>兼顾长短作业<div class="note purple no-icon flat"><p>区分抢占式和非抢占式：中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，可以马上进行进程调度与切换，为抢占式。只能在进程自己进入阻塞或者执行结束后进行调度与切换，为非抢占式。</p></div></li></ul><h2 id="多级队列调度算法"><a href="#多级队列调度算法" class="headerlink" title="多级队列调度算法"></a>多级队列调度算法</h2><h3 id="调度对象-5"><a href="#调度对象-5" class="headerlink" title="调度对象"></a>调度对象</h3><p>进程</p><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>引入多个就绪队列，通过各队列的区别对待，达到一个综合的调度目标<br><img src="多级队列.png" alt="多级队列"></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>每个队列可以有不同的调度算法，设置不同的优先级。</li><li>每个作业固定归入一个队列<div class="note blue no-icon flat"><p>这一条是与多级反馈队列区分之处。</p></div></li></ul><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><h3 id="调度对象-6"><a href="#调度对象-6" class="headerlink" title="调度对象"></a>调度对象</h3><p>进程</p><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><ul><li>设置多个就绪队列，分别赋予不同的优先级（如逐级降低），队列1的优先级最高。每个队列执行时间片的长度也不同，规定优先级越低则时间片越长（如逐级加倍）。</li><li>新进程进入内存后，先投入队列1的末尾，按FCFS算法调度；若按队列1一个时间片未能执行完，则降低投入到队列2的末尾，同样按FCFS算法调度；如此下去，降低到最后的队列，则按“时间片轮转”算法调度直到完成。</li><li>仅当较高优先级的队列为空，才调度较低优先级的队列中的进程执行。如果进程执行时有新进程进入较高优先级的队列，则抢先执行新进程，并把被抢先的进程投入原队列的末尾。<br><img src="反馈队列.png" alt="反馈队列"><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3></li><li>兼顾I/O型、计算型进程<div class="note blue no-icon flat"><ul><li>如果因阻塞而不被执行，恢复后回到原来的队列</li><li>如果因时间片而不被执行，降一级队列</li></ul><p>所以I/O的会很舒服，计算型也会在后期得到大量的计算时间。</p></div></li></ul><h1 id="实时系统调度算法"><a href="#实时系统调度算法" class="headerlink" title="实时系统调度算法"></a>实时系统调度算法</h1><h2 id="静态表调度"><a href="#静态表调度" class="headerlink" title="静态表调度"></a>静态表调度</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>通过对所有周期性任务的分析预测（到达时间、运行时间、结束时间、任务间的优先关系），事先确定一个固定的调度方案。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><ul><li>无任何计算，方案已经给定，开销最小。</li><li>无灵活性、只适用于完全固定的任务场景。</li></ul><h2 id="单调速率调度RMS"><a href="#单调速率调度RMS" class="headerlink" title="单调速率调度RMS"></a>单调速率调度RMS</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>任务的周期越小，其优先级越高，优先级最高的任务最先被调度，且可以抢占<br><img src="单调速率调度.png" alt="单调速率调度"></p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ul><li>任务集可以调度当且仅当：$$\eqalign{  & \sum\limits_{i = 1}^n {{{{C_i}} \over {{T_i}}}}  \le n(\root n \of 2  - 1)  \cr   & \mathop {\lim }\limits_{n \to \infty } n(\root n \of 2  - 1) = \ln 2 \approx 0.693147 \cr} $$<code>Ci</code>是某任务执行时间，<code>Ti</code>是某任务的周期，<code>n</code>是一共有几个任务。<h2 id="最早截止期优先EDF"><a href="#最早截止期优先EDF" class="headerlink" title="最早截止期优先EDF"></a>最早截止期优先EDF</h2><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3>任务的绝对截止时间越早，其优先级越高，优先级最高的任务最先被调度<br><img src="最早截止期优先.png" alt="截止期"><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a>特点</h3></li><li>任务集可以调度当且仅当：$$\sum\limits_{i = 1}^n {{{{C_i}} \over {{T_i}}}}  \le 1$$<div class="note pink no-icon flat"><p>可见，EDF比RMS可调度的任务集大。</p></div></li></ul><h1 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h1><h2 id="非对称式多处理系统（AMP）"><a href="#非对称式多处理系统（AMP）" class="headerlink" title="非对称式多处理系统（AMP）"></a>非对称式多处理系统（AMP）</h2><h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>主处理机管理就绪队列，由主处理机分配任务给从处理机执行</p><h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a>特点</h3><ul><li>有潜在的不可靠性，主机坏了都GG</li></ul><h2 id="对称式多处理系统（SMP）"><a href="#对称式多处理系统（SMP）" class="headerlink" title="对称式多处理系统（SMP）"></a>对称式多处理系统（SMP）</h2><h3 id="集中控制"><a href="#集中控制" class="headerlink" title="集中控制"></a>集中控制</h3><h4 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h4><h5 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h5><p>每个CPU设立一个就绪队列，进程一辈子都在一个CPU上。</p><h5 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a>特点</h5><ul><li>算法简单开销小</li><li>容易忙闲不均</li></ul><h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><h5 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h5><p>每个CPU共享一个就绪队列，队首进程每次分配给空闲的CPU</p><h5 id="特点-8"><a href="#特点-8" class="headerlink" title="特点"></a>特点</h5><ul><li>不存在忙闲不均</li><li>开销相对而言比较大</li></ul><h3 id="分散控制"><a href="#分散控制" class="headerlink" title="分散控制"></a>分散控制</h3><h4 id="自调度"><a href="#自调度" class="headerlink" title="自调度"></a>自调度</h4><h5 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h5><p>每个CPU共享一个就绪队列，由CPU自己选择心仪的对象执行。</p><h5 id="特点-9"><a href="#特点-9" class="headerlink" title="特点"></a>特点</h5><ul><li>无需专门的处理机来分配进程，自己管自己</li><li>处理机较多时，互斥访问较慢，成为瓶颈</li></ul><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="成组调度"><a href="#成组调度" class="headerlink" title="成组调度"></a>成组调度</h3><h4 id="定义-15"><a href="#定义-15" class="headerlink" title="定义"></a>定义</h4><p>将一个进程中的一组线程，每次分派时同时到一组处理机上执行，剥夺时也同时进行</p><h4 id="特点-10"><a href="#特点-10" class="headerlink" title="特点"></a>特点</h4><ul><li>批量调度减少调度次数，提高效率</li><li>线程调度提高并行度，提高吞吐量</li></ul><h3 id="专用处理机调度"><a href="#专用处理机调度" class="headerlink" title="专用处理机调度"></a>专用处理机调度</h3><h4 id="定义-16"><a href="#定义-16" class="headerlink" title="定义"></a>定义</h4><p>为进程中的每个线程都固定分配一个CPU，直到该线程执行完成。</p><h4 id="特点-11"><a href="#特点-11" class="headerlink" title="特点"></a>特点</h4><ul><li>线程阻塞造成CPU闲置</li><li>无需切换，减少开销<div class="note pink no-icon flat"><p>它得以实现的前提是，CPU数量众多的高度并行系统，单个CPU利用率已经不重要了。</p></div></li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="四大必要条件"><a href="#四大必要条件" class="headerlink" title="四大必要条件"></a>四大必要条件</h2><ul><li>互斥条件：一个资源只能同时由一个进程使用</li><li>请求和保持条件：已经占有了部分资源，又发出了新的资源请求，新资源请求得不到满足也占着旧资源不放</li><li>不剥夺条件：占着的资源不能被别人剥夺，只能用完自己释放</li><li>环路等待条件：发生死锁时必然存在进程——资源的环形链。<div class="note green no-icon flat"><p>不剥夺条件时别人不能抢你的资源，保持条件是你自己抓着不放，主体对象不同，作用对象相同。</p></div><div class="note purple no-icon flat"><p>如果当前系统刚刚完成对一个进程资源的分配后，已经一个资源也没有了，每个进程的最大资源还一个都没有满足，我们不能说这个系统就已经死锁了，虽然这是可以预见的事实，但此时由于进程都还没有提出新的请求，还在自己运行，我们因此不能说已经发生了死锁，当进程提出任意请求时，死锁才会真正发生。</p></div><h2 id="处理死锁"><a href="#处理死锁" class="headerlink" title="处理死锁"></a>处理死锁</h2><h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><h4 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h4></li><li>打破互斥：允许进程同时访问某些资源。</li><li>打破保持条件：一次性分配所有用到的资源，而不是占有一部分再去请求另一部分</li><li>打破不剥夺条件：允许进程从别的进程那里夺取资源</li><li>打破循环等待：给资源排号，申请时只能按顺序申请，让循环不可能产生</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>打破互斥：不是所有的资源都能支持共享访问</li><li>打破保持条件：首先资源难以预测，其次资源并不会全程使用，却全程占有，利用率大大降低，导致了并发度的下降</li><li>打破不剥夺条件：实现起来很复杂，开销大</li><li>打破循环等待：合理编号开销大，其次，先申请的不一定先用，也造成了资源利用率的下降</li></ul><h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><h5 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h5><p><img src="银行家算法.png" alt="银行家"></p><h5 id="安全算法"><a href="#安全算法" class="headerlink" title="安全算法"></a>安全算法</h5><p><img src="安全性算法.png" alt="安全性"></p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><h4 id="资源图"><a href="#资源图" class="headerlink" title="资源图"></a>资源图</h4><p><img src="资源分配图.png" alt="资源分配图"></p><h4 id="检测方法"><a href="#检测方法" class="headerlink" title="检测方法"></a>检测方法</h4><h5 id="资源图检测"><a href="#资源图检测" class="headerlink" title="资源图检测"></a>资源图检测</h5><ul><li>初步判断：有无环路，有的话就存在死掉的可能</li><li>精细判断：化简资源图<br><img src="资源图化简.png" alt="资源分配图化简"><div class="note green no-icon flat"><p>资源图化简个人感觉就是安全算法在图上的体现，思路都是一样的。</p></div><h5 id="资源向量算法"><a href="#资源向量算法" class="headerlink" title="资源向量算法"></a>资源向量算法</h5></li><li>E：存在资源向量：表示各类资源存在的总量</li><li>A：可用资源向量：表示当前未分配的资源量</li><li>C：当前分配矩阵：第i个行向量对应第i个进程已经分配到的资源向量</li><li>R：请求资源矩阵：第i个行向量对应第i个进程所需要的资源数量<br>存在恒等式：$$\sum\limits_{i = 1}^n {{C_{ij}}}  + {A_j} = {E_j}$$<img src="资源向量算法.png" alt="资源向量"><div class="note green no-icon flat"><p>资源图化简个人感觉就是安全算法在矩阵上的体现，思路都是一样的。麻</p></div><h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><h4 id="回滚法"><a href="#回滚法" class="headerlink" title="回滚法"></a>回滚法</h4>为每个进程定期建立CheckPoint，发生死锁时通过回滚某个进程让其占有的资源得到释放，从而消除其他进程的死锁。<div class="note purple no-icon flat"><p>牺牲自己，成全他人（合十）</p></div></li></ul><h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>是指任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。<br><div class="note orange no-icon flat"><p>死锁是大家都被阻塞了，已经不运行了。</p></div></p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>是指任务长期得不到执行，不是它不想，而是处理机资源不给他，一旦给它，它是可以执行的，它处于就绪态，或者未被装入。</p>]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统进程线程复习</title>
      <link href="/posts/32094/"/>
      <url>/posts/32094/</url>
      
        <content type="html"><![CDATA[<h1 id="程序顺序执行特征"><a href="#程序顺序执行特征" class="headerlink" title="程序顺序执行特征"></a>程序顺序执行特征</h1><ul><li>顺序性：按照程序结构所指定的次序执行</li><li>封闭性：独享计算机所有资源</li><li>可再现性：初始条件相同则结果相同</li></ul><h1 id="程序并发执行特征"><a href="#程序并发执行特征" class="headerlink" title="程序并发执行特征"></a>程序并发执行特征</h1><ul><li>间断性：并发程序具有“执行—-暂停——执行”这种间断性的活动规律。</li><li>非封闭性：多个程序共享资源</li><li>不可再现性：在初始条件相同的情况下，程序执行结果取决于执行次序</li></ul><h1 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>多个程序在读写一个共享数据时结果依赖顺序。<br><div class="note green no-icon flat"><p>所以如果不依赖顺序，只是读写共享数据也不能说它是竞争。</p></div></p><h2 id="判断——Bernstein条件"><a href="#判断——Bernstein条件" class="headerlink" title="判断——Bernstein条件"></a>判断——Bernstein条件</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3>$$R(SI)$$<p>SI的读子集，代表着进程SI需要读的资源<br>$$W(SI)$$<br>SI的写子集，代表着进程SI需要写的资源</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>两个进程S1和S2可并发，当且仅当下列条件同时成立：<br>$$\eqalign{  & R(S1) \cap W(S2) = \emptyset   \cr   & W(S1) \cap R(S2) = \emptyset   \cr   & W(S1) \cap W(S2) = \emptyset  \cr} $$<br>不然就会发生竞争，运行结果将不确定。</p><h2 id="其他定义"><a href="#其他定义" class="headerlink" title="其他定义"></a>其他定义</h2><ul><li>临界资源：一次只能允许一个进程访问的资源叫临界资源</li><li>临界区：进程中访问临界资源的那一段代码<div class="note pink no-icon flat"><p>临界区管理需满足：空闲让进，忙则等待，有限等待，让权等待。</p></div></li></ul><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li>动态性：是程序的执行过程，可生可死可睡觉</li><li>异步性：各自独立以不可预知的速度执行</li><li>并发性：和其他进程一起并发执行</li><li>独立性：是传统OS中独立运行的基本单位</li></ul><h2 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h2><p>可以由Fork产生<br><div class="note purple no-icon flat"><p>fork有三种返回值，正数，0和负数。<br>不要只记住正数和0.</p></div></p><h2 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h2><p>进程有以下三种基本执行状态。<br><img src="进程状态.png" alt="执行状态"></p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>进程的可执行单元</p><h2 id="引入目的"><a href="#引入目的" class="headerlink" title="引入目的"></a>引入目的</h2><p>减少并发程序执行时所付出的时空开销，使得并发粒度更细、并发性更好<br><div class="note pink no-icon flat"><p>每个线程都有自己的栈。</p></div></p><h2 id="与进程的关系"><a href="#与进程的关系" class="headerlink" title="与进程的关系"></a>与进程的关系</h2><ul><li>1:1 </li><li>1:M</li><li>M:M</li><li>M:1</li></ul><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>线程在用户空间,通过library模拟的thread,不需要或仅需要极少的kernel支持。<br><img src="用户级线程.png" alt="用户空间"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>优点：</p><ul><li>切换无需经过内核</li><li>调度由程序决定</li><li>可运行在任何系统上</li></ul><p>缺点：</p><ul><li>内核不知用户态下线程的状态，阻塞时只能全部阻塞</li><li>无法实现并行执行，因为内核对其的分配以进程为单位</li></ul><h3 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>内核级线程就是kernel有好几个分身,一个分身可以处理一件事<br><img src="内核线程.png" alt="内核线程"></p><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>优点：</p><ul><li>内核感知线程，可以将线程安排到多个处理器上并行执行</li><li>内核感知线程，可以实现精确阻塞</li><li>内核中的处理可通过多线程完成。</li></ul><p>缺点：</p><ul><li>线程切换经过内核，降低了效率</li></ul><h3 id="混合级线程"><a href="#混合级线程" class="headerlink" title="混合级线程"></a>混合级线程</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>线程在用户空间创建和管理，但需要实现从用户空间的线程到内核空间线程（轻量级进程）的映射<br><img src="混合级线程.png" alt="混合级线程"></p><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>折中了前面两种方法。</p><h1 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h1><p>互斥是由于访问临界资源而产生的关系，不是人为的，是为了保证正确性，且不保证顺序。<br>同步是人为设置的次序，为了合作完成某一任务，保证顺序。</p><h2 id="忙等待互斥算法"><a href="#忙等待互斥算法" class="headerlink" title="忙等待互斥算法"></a>忙等待互斥算法</h2><h3 id="面包店算法"><a href="#面包店算法" class="headerlink" title="面包店算法"></a>面包店算法</h3><p>设置一个发号器，按由小到大的次序发放号码。进程进入临界区前先抓取一个号码，然后按号码从小到大的次序依次进入临界区。若多个进程抓到相同的号码则按进程编号依次进入。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Entry <span class="title">Section</span> <span class="params">(i)</span> </span>&#123; <span class="comment">// i → process i</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Choosing[i] = <span class="number">1</span>;</span><br><span class="line">        Number[i] = <span class="number">1</span> + <span class="built_in">max</span>(Number[<span class="number">1</span>],...,Number[N]);</span><br><span class="line">        Choosing [i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>; j＜=N; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Choosing[j] != <span class="number">0</span>) &#123; &#125;</span><br><span class="line">            <span class="comment">// wait until process j receives its number,等待所有进程抓号完毕</span></span><br><span class="line">            <span class="keyword">while</span> ((Number[j]!=<span class="number">0</span>) &amp;&amp; ((Number[j],j) ＜(Number[i],i))) &#123; &#125;</span><br><span class="line">            <span class="comment">// wait until processes with smaller numbers, or with the </span></span><br><span class="line">            <span class="comment">// same number, but with higher priority, finish their work</span></span><br><span class="line">            <span class="comment">// 还有比该进程号小的，或者号相同但是编号大的没访问临界区，所以继续忙等</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// critical section... 临界区</span></span><br><span class="line">    Number[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// non-critical section... 非临界区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> </p><h3 id="TS指令"><a href="#TS指令" class="headerlink" title="TS指令"></a>TS指令</h3><p>是一种不可中断的基本原语（指令）。它会写值到某个内存位置并传回其旧值。</p><h4 id="语义"><a href="#语义" class="headerlink" title="语义"></a>语义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">TestAndSet</span>(boolean_ref lock) &#123; </span><br><span class="line">    boolean initial = lock; </span><br><span class="line">    lock = <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">return</span> initial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h4 id="可行的互斥实现"><a href="#可行的互斥实现" class="headerlink" title="可行的互斥实现"></a>可行的互斥实现</h4><p><img src="TS.png" alt="TS"><br>houselock的值为0，假如绿色进程先acquire，那么就会得到houselock的0值，并改houselock的值为1，由于不满足while条件，绿色进程进入了临界区。此时红色进程进行acquire，就会得到houselock的1值，并改houselock的值为1，满足while条件，触发忙等待。直到绿色进程将houselock的值改为0，破坏了红色进程的忙等。</p><h3 id="Swap指令"><a href="#Swap指令" class="headerlink" title="Swap指令"></a>Swap指令</h3><h4 id="语义-1"><a href="#语义-1" class="headerlink" title="语义"></a>语义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Swap</span>(boolean *a, Boolean *b)</span><br><span class="line">&#123;</span><br><span class="line">    Boolean temp;</span><br><span class="line">    Temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h4 id="可行的互斥实现-1"><a href="#可行的互斥实现-1" class="headerlink" title="可行的互斥实现"></a>可行的互斥实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Boolean k = <span class="literal">true</span>; <span class="comment">// 初始化为1，局部变量</span></span><br><span class="line">Boolean use = <span class="literal">false</span>; <span class="comment">// 初始资源空闲，全局变量</span></span><br><span class="line"><span class="keyword">while</span>（k != <span class="number">0</span>）&#123;</span><br><span class="line">    Swap（&amp;use, &amp;k）; <span class="comment">//进入区</span></span><br><span class="line">&#125;</span><br><span class="line">Critial_region（）; <span class="comment">//临界区</span></span><br><span class="line">Swap（&amp;use, &amp;k）; <span class="comment">//退出区</span></span><br><span class="line">Other_region（）; </span><br></pre></td></tr></table></figure> <p>第一个进程进来时，k为1，use为0，进行交换后，k变为了0，use变为了1，不满足while条件，进入临界区，此时第二个进程执行swap，由于k和use都是1，所以交换后k还是1，满足while条件，进行忙等，直到第一个进程执行swap，把use变为0，才会破坏第二个进程的忙等。</p><h3 id="忙等互斥缺陷"><a href="#忙等互斥缺陷" class="headerlink" title="忙等互斥缺陷"></a>忙等互斥缺陷</h3><ul><li>忙等:浪费CPU资源</li><li>会造成优先级反转</li></ul><h2 id="信号量互斥算法"><a href="#信号量互斥算法" class="headerlink" title="信号量互斥算法"></a>信号量互斥算法</h2><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>是一个确定的二元组(s, q)，其中s是一个具有非负初值的整型变量，q是一个初始状态为空的队列。<br>q是一个初始状态为空的队列，当有进程被阻塞时就会进入此队列。<br>使用中，s为正代表还有几个资源可用，为负代表队列中有几个进程在等待。<br><div class="note pink no-icon flat"><p>所以所见并非所得，你看到的它是一个像整型的变量，但实际上它是一个二元组，只不过q是被系统隐藏的。</p></div></p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>二元信号量，取值仅为0，1。主要用于互斥，你可以认为他就是锁</li><li>一般信号量，取值不限，初值为可用物理资源的总数，用于进程间的协作同步问题。<div class="note pink no-icon flat"><p>所以做题的时候，想实现互斥，就二极管信号量，如果是同步，就一般信号量。</p></div><h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><h4 id="AND型信号量集"><a href="#AND型信号量集" class="headerlink" title="AND型信号量集"></a>AND型信号量集</h4>将进程需要的所有共享资源一次全部分配给它；待该进程使用完后再一起释放。<br><img src="AND信号量.png" alt="AND信号量"><div class="note green no-icon flat"><p>筷子要两根一起拿~</p></div><h4 id="一般信号量集"><a href="#一般信号量集" class="headerlink" title="一般信号量集"></a>一般信号量集</h4>在AND型信号量集的基础上进行扩充：进程对信号量Si的测试值为ti（用于信号量的判断，即 <code>Si &gt;= ti</code>，表示资源数量低于ti时，便不予分配），占用值为di（用于信号量的增减，即<code>Si = Si - di</code>和<code>Si = Si + di</code>）<br><img src="一般信号量集.png" alt="一般信号量集"><div class="note blue no-icon flat"><p>SP(S,d,q)代表对于信号量S，每次申请q个资源，当资源少于d个时，不予通过。</p></div></li></ul><h2 id="管程互斥算法"><a href="#管程互斥算法" class="headerlink" title="管程互斥算法"></a>管程互斥算法</h2><p>在我看来，管程是对信号量的一种包装，屏蔽了信号量比较难用的缺点，同时扩展了信号量<br><img src="Hoare.png" alt="Hoare"></p><h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><h2 id="低级通信"><a href="#低级通信" class="headerlink" title="低级通信"></a>低级通信</h2><p>信号量，管程，传递一些状态和整数都是低级通信</p><h2 id="高级通信"><a href="#高级通信" class="headerlink" title="高级通信"></a>高级通信</h2><p>管道、共享内存、消息系统是高级通信。</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><h4 id="无名管道"><a href="#无名管道" class="headerlink" title="无名管道"></a>无名管道</h4><ul><li>半双工管道，只能单向传递信息。</li><li>只能用于父子进程或者兄弟进程之间通信</li><li>本质上是一个文件，一个存在于只内存中的文件</li><li>写入是写在末尾，读出是从头部读</li></ul><h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><ul><li>克服无名管道通信对象的限制</li><li>仍然是一个文件</li></ul><h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p><img src="消息传递.png" alt="消息传递"></p><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><ul><li>是最有用的进程间通信方式，是最快的IPC形式，避免了其他通信用到的复制操作</li><li>通过映射同一物理空间实现</li><li>这是一种共享，一次写入对所有进程都可见，所以需要同步和互斥<br><img src="共享内存.png" alt="共享内存"></li></ul><h1 id="经典同步互斥问题"><a href="#经典同步互斥问题" class="headerlink" title="经典同步互斥问题"></a>经典同步互斥问题</h1><h2 id="生产者——消费者"><a href="#生产者——消费者" class="headerlink" title="生产者——消费者"></a>生产者——消费者</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>若干进程通过有限的共享缓冲区交换数据。其中，“生产者”进程不断写入，而“消费者”进程不断读出；共享缓冲区共有N个；任何时刻只能有一个进程可对共享缓冲区进行操作。<br><img src="生产消费.png" alt="生产消费"></p><h3 id="完整写法"><a href="#完整写法" class="headerlink" title="完整写法"></a>完整写法</h3><p><img src="生产者写法.png" alt="生产者写法"></p><h2 id="读者——写者"><a href="#读者——写者" class="headerlink" title="读者——写者"></a>读者——写者</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>对共享资源的读写操作，任一时刻“写者”最多只允许一个，而“读者”则允许多个。<br><img src="读者问题.png" alt="读者问题"></p><h3 id="完整写法-1"><a href="#完整写法-1" class="headerlink" title="完整写法"></a>完整写法</h3><p><img src="读者写法.png" alt="读者写法"><br><div class="note blue no-icon flat"><p>这是一种读者优先的写法。</p></div></p><h2 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>5个哲学家围绕一张圆桌而坐，桌子上放着5支筷子，每两个哲学家之间放一支；哲学家的动作包括思考和进餐，进餐时需要同时拿起他左边和右边的两支筷子，思考时则同时将两支筷子放回原处。如何保证哲学家们的动作有序进行？如：不出现相邻者同时要求进餐；不出现有人永远拿不到筷子。</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><ul><li>设置信号量值为4的信号量，代表只允许同时4个哲学家进餐，这样总会有人拿到两根筷子吃饭并释放</li><li>对筷子编号，奇数号先拿左，偶数号先拿右。</li><li>同时拿两根筷子，要么就一根不拿。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内存管理方式复习</title>
      <link href="/posts/64884/"/>
      <url>/posts/64884/</url>
      
        <content type="html"><![CDATA[<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="大小尾端"><a href="#大小尾端" class="headerlink" title="大小尾端"></a>大小尾端</h2><h3 id="大尾端"><a href="#大尾端" class="headerlink" title="大尾端"></a>大尾端</h3><p>所谓的大端模式，就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。<br>所谓的小端模式，就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。<br>举个例子，比如对于0x12345678</p><ul><li>大端模式：$$\eqalign{  & address:00 \cdot 01 \cdot 02 \cdot 03  \cr   & thValue:12 \cdot 34 \cdot 56 \cdot 78 \cr} $$</li><li>小端模式：$$\eqalign{  & address:00 \cdot 01 \cdot 02 \cdot 03  \cr   & thValue:78 \cdot 56 \cdot 34 \cdot 12 \cr} $$<h3 id="记忆方式"><a href="#记忆方式" class="headerlink" title="记忆方式"></a>记忆方式</h3></li><li>记忆一：地址从低到高，符合一般认知的数字排列方式是大端。</li><li>记忆二：小段高位对高地址，低位对低地址。<div class="note green no-icon flat"><p>这个真的很重要！期末必考，我说的！</p></div><h2 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h2>作业是用户需要计算机完成的某项任务，是要求计算机所做工作的集合。<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2>进程包括程序和程序处理对象（数据集），是一个程序对某个数据集的执行过程。<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2>程序是静止的，是存放在磁盘上的可执行文件。<h2 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3></li><li>进程是竞争计算机系统有限资源的基本单位，有自己的生存周期，可以创建其他进程，是程序在处理机上一次执行的过程，是动态的概念。</li><li>程序只是一个存在与磁盘上的可执行文件，是一个静态概念。</li><li>任务是用户向计算机提交任务的任务实体，包括作业提交、作业收容、作业执行和作业完成。作业执行需要进程完成，整体作业的完成离不开一个个程序。</li></ul><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul><li>每个进程可以运行多个程序。</li><li>每个作业可能需要多个进程完成。</li><li>每个程序可以被多个进程执行。</li><li>一个作业通常包括程序、数据和操作说明书3部分。</li><li>每一个进程由进程控制块PCB、程序和数据集合组成。</li><li>这说明程序是进程的一部分，是<em>进程的实体</em>。因此，一个作业可划分为若干个进程来完成，而每一个进程有其实体——程序和数据集合。</li></ul><h1 id="页式内存管理"><a href="#页式内存管理" class="headerlink" title="页式内存管理"></a>页式内存管理</h1><h2 id="实现结构"><a href="#实现结构" class="headerlink" title="实现结构"></a>实现结构</h2><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>在分页存储管理系统中，把每个作业的地址空间分成一些大小相等的片，称之为页面（Page）或页，各页从0开始编号。<br><div class="note orange no-icon flat"><p>注意是地址空间，即逻辑地址，所以页的概念只是在虚拟地址上。</p></div></p><h3 id="存储块"><a href="#存储块" class="headerlink" title="存储块"></a>存储块</h3><p>在分页存储管理系统中，把主存的存储空间也分成与页面相同大小的片，这些片称为存储块，或称为<strong><em>页框（Frame）</em></strong>，同样从0开始编号。</p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>为了便于在内存找到进程的每个页面所对应块，分页系统中为每个进程配置一张页表，进程逻辑地址空间中的每一页，在页表中都对应有一个页表项。</p><h3 id="页表寄存器"><a href="#页表寄存器" class="headerlink" title="页表寄存器"></a>页表寄存器</h3><p>页表的基址及长度由页表寄存器给出。<br><img src="页表寄存器结构.png" alt="页表寄存器结构"></p><h3 id="物理块管理表"><a href="#物理块管理表" class="headerlink" title="物理块管理表"></a>物理块管理表</h3><p>描述物理内存空间的分配使用状况。<br><div class="note purple no-icon flat"><p>具体实现有位图法，空闲链表法。</p></div></p><h3 id="地址划分"><a href="#地址划分" class="headerlink" title="地址划分"></a>地址划分</h3><h4 id="逻辑地址"><a href="#逻辑地址" class="headerlink" title="逻辑地址"></a>逻辑地址</h4><p><img src="逻辑地址.png" alt="逻辑地址"></p><h4 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h4><p><img src="物理地址.png" alt="物理地址"></p><h2 id="地址变换流程"><a href="#地址变换流程" class="headerlink" title="地址变换流程"></a>地址变换流程</h2><h3 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="解析逻辑地址"><a href="#解析逻辑地址" class="headerlink" title="解析逻辑地址"></a>解析逻辑地址</h4><p>给定逻辑地址A，如何求出其页号和偏移量？</p><h5 id="2进制-8进制-16进制"><a href="#2进制-8进制-16进制" class="headerlink" title="2进制/8进制/16进制"></a>2进制/8进制/16进制</h5><p>直接根据地址划分截取对应位进行转换即可。</p><h5 id="10进制"><a href="#10进制" class="headerlink" title="10进制"></a>10进制</h5><p>设逻辑地址为va,每一页大小为m,则页号(pagenum)为：<br>$$pagenum = \left\lfloor {{{va} \over m}} \right\rfloor $$<br>偏移量(offset)为：<br>$$offset = va\% m$$</p><h4 id="页表查找"><a href="#页表查找" class="headerlink" title="页表查找"></a>页表查找</h4><p><img src="页表查找.png" alt="页表查找.png"></p><h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p><img src="页表变换.png" alt="页表变换.png"></p><h3 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h3><ol><li>将虚拟地址用之前的方法转换出页号和偏移地址。</li><li>将页号与页表寄存器中的页表长度进行比较，超过长度就产生越界中断。</li><li>结合页表寄存器的基地址、页号、表项长度查询页表，得到对应的页表项，具体公式为:$$destnation = pgdir + pagenum*(entry\_size)$$</li><li>从页表项中取出物理块号</li><li>将物理块号拼接偏移地址得到实际物理地址，进行访问。</li></ol><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>一级页表，在物理空间中需要连续的地址存储，且需要一次性给够空间，所以对于逻辑地址较大的设备，页表会很长，为它找这么大的空间是很难且没必要的。因此引入多级页表，只放入页目录，需要页表时再调入内存，且不需要连续的地址存储</p><h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4><p><img src="多级页表.png" alt="多级页表"></p><h4 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h4><p><img src="访问方式.png" alt="访问方式"></p><h3 id="哈希页表"><a href="#哈希页表" class="headerlink" title="哈希页表"></a>哈希页表</h3><p>对页号进行哈希处理，根据哈希值直接查表，对于碰撞的处理用链表解决。<br><img src="哈希页表.png" alt="哈希页表"></p><h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>页表按照物理块组织，即表项一是第一个物理块，表项二是第二个物理块……<br><img src="反置页表.png" alt="反置页表"></p><h4 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h4><p>用进程标志符和页号去检索反置页表，进行遍历检索，直到表尾或者找到某一项的值对应上，然后这个表项为第几项说明物理块就是第几块。</p><h4 id="哈希优化"><a href="#哈希优化" class="headerlink" title="哈希优化"></a>哈希优化</h4><p>通过哈希表(hash table)查找可由逻辑页号得到物理页面号。虚拟地址中的逻辑页号通过哈希表指向反置页表中的表项链头（因为哈希表可能指向多个表项），得到物理页面号。<br><img src="哈希.png" alt="哈希"></p><h1 id="段式内存管理"><a href="#段式内存管理" class="headerlink" title="段式内存管理"></a>段式内存管理</h1><h2 id="实现结构-1"><a href="#实现结构-1" class="headerlink" title="实现结构"></a>实现结构</h2><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><h4 id="表项"><a href="#表项" class="headerlink" title="表项"></a>表项</h4><p><img src="段表表项.png" alt="段表表项"></p><h3 id="段表寄存器"><a href="#段表寄存器" class="headerlink" title="段表寄存器"></a>段表寄存器</h3><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><img src="段表寄存器结构.png" alt="段表寄存器结构"></p><h2 id="地址变换流程-1"><a href="#地址变换流程-1" class="headerlink" title="地址变换流程"></a>地址变换流程</h2><h3 id="图示-2"><a href="#图示-2" class="headerlink" title="图示"></a>图示</h3><p><img src="地址变换.png" alt="地址变换"></p><h3 id="文字-1"><a href="#文字-1" class="headerlink" title="文字"></a>文字</h3><ol><li>将逻辑地址中的段号 S 与段表长度TL 进行比较。判断合法性</li><li>根据段表的始址和该段的段号，计算出该段对应段表项的位置，从中读出该段在内存的始址。</li><li>再检查段内地址 d，是否超过该段的段长 SL。判断合法性。</li><li>则将该段的基址与段内地址 d 相加，即可得到要访问的内存物理地址。</li></ol><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>二维：段长和段起始位置</li><li>共享公用子程序易实现。</li><li>对子程序的信息保护易实现。</li><li>便于动态增长</li><li>便于动态链接</li><li>用户参与，用户知道段表的结构</li><li>地址变换比较复杂，费时</li><li>管理困难</li><li>分段最大尺寸受主存限制</li></ol><h1 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用分段方法来分配和管理虚拟存储器，而用分页方法来分配和管理实存储器<br><img src="段页定义.png" alt="段页定义">  </p><h2 id="实现结构-2"><a href="#实现结构-2" class="headerlink" title="实现结构"></a>实现结构</h2><p>一个进程对应一个段表、一个段对应一个页表。<br><img src="段页结构.png" alt="段页结构"></p><h2 id="地址变换流程-2"><a href="#地址变换流程-2" class="headerlink" title="地址变换流程"></a>地址变换流程</h2><h3 id="图示-3"><a href="#图示-3" class="headerlink" title="图示"></a>图示</h3><p><img src="段页变换.png" alt="段页变换"></p><h3 id="文字-2"><a href="#文字-2" class="headerlink" title="文字"></a>文字</h3><ol><li>将段号与段表长度进行比较，若段号大于或等于段表长度，产生越界中断。</li><li>利用段表始址与段号得到该段表项在段表中的位置。取出该段的页表始址和页表长度。</li><li>将页号与页表长度进行比较，若页号大于或等于页表长度，产生越界中断。</li><li>利用页表始址与页号得到该页表项在页表中的位置。</li><li>取出该页的物理块号，与页内地址拼接得到实际的物理地址。</li></ol><h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>以上的所有内存管理都需要一次性一个作业的所有内容装入后才能运行，作业装入后需要一直存在于内存中，直至结束，覆盖和交换所起效果也有限，需要引入一种全新的解决方法———虚拟存储管理。</p><h1 id="虚拟存储管理"><a href="#虚拟存储管理" class="headerlink" title="虚拟存储管理"></a>虚拟存储管理</h1><h2 id="理论前提"><a href="#理论前提" class="headerlink" title="理论前提"></a>理论前提</h2><p>局部性原理</p><ul><li>时间局部：一条指令被执行，一个数据被访问，一般都只集中于一定时间内。</li><li>空间局部：当前一段时间内访问的指令或者数据一般都只集中于一定区域内。</li></ul><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ul><li>在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。</li><li>执行过程中，如果发生缺页，再通过中断调入内存</li><li>执行过程中，可以将暂时不访问的页或段调出内存，需要时再调入。</li></ul><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul><li>提供了一个很大的地址空间和内存</li><li>虚拟内存把主存作为磁盘的高速缓存，在主存和磁盘之间根据需要来回传送数据，高效地使用了主存</li><li>获得了一个不超过外存交换区和主存内存之和大小的“内存”</li></ul><div class="note purple no-icon flat"><p>实际上虚拟内存的最大容量主要由计算机的地址结构决定，例如32 位机器的虚拟存储器的最大容量就是 4GB。<br>它只能寻址这么大，就算交换区有400G.<br>我个人感觉最大容量是取地址结构和外存交换区+内存的最小值。</p></div><h2 id="与覆盖交换对比"><a href="#与覆盖交换对比" class="headerlink" title="与覆盖交换对比"></a>与覆盖交换对比</h2><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><ul><li>借鉴之处：学习了覆盖不用将程序的所有内容都调入内存的思想，只保留程序的一部分在内存中。</li><li>创新之举：不再需要用户维护，由操作系统自行维护。</li></ul><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><ul><li>借鉴之处：学习了交换将内容换出到外存以节约内存的思想。</li><li>创新之举：相比于交换粒度更细，交换一般交换整个程序，虚拟存储交换程序中的某些页面。</li></ul><h2 id="页面置换策略"><a href="#页面置换策略" class="headerlink" title="页面置换策略"></a>页面置换策略</h2><h3 id="最优置换"><a href="#最优置换" class="headerlink" title="最优置换"></a>最优置换</h3><p>从主存中移出永远不再需要的页面，如无这样的页面存在，则应选择最长时间不需要访问的页面。<br><div class="note pink no-icon flat"><p>我们不可能预测未来，这个策略只是一个空想策略。<br>但它可以被作为标杆，让策略向他靠拢。</p></div></p><h3 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h3><p>最简单的页置换算法，操作系统记录每个页被调入内存的时间，当必需置换掉某页时，选择最旧的页换出。</p><h4 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h4><p>在使用FIFO算法作为缺页置换算法时，分配的缺页增多，但缺页率反而提高，这样的异常现象称为belady Anomaly。<br>就是原来有5页物理页，让你做文章，现在变成6页了，理论上应该缺页会少一点，但在先进先出下反而多了。</p><h3 id="Second-Chance"><a href="#Second-Chance" class="headerlink" title="Second Chance"></a>Second Chance</h3><p>如果被淘汰的数据之前被访问过，则给其第二次机会。<br>就是给一个标志位，标志放入队列后是否又被再次访问，如果有，淘汰时，如果本来是要淘汰它，就给它一次机会，把它移到队尾，清除标志位。</p><h3 id="Clock算法"><a href="#Clock算法" class="headerlink" title="Clock算法"></a>Clock算法</h3><p>通过一个环形队列，避免将数据在FIFO队列中移动。二次机会的改进。<br>和Second Chance一样，但是给一个指针代表指向队列头，以后移动指针就相当于将某一元素移到了队尾。<br><img src="clock算法.png" alt="clock算法"></p><h3 id="最近最少使用（LRU）"><a href="#最近最少使用（LRU）" class="headerlink" title="最近最少使用（LRU）"></a>最近最少使用（LRU）</h3><p>如果数据最近被访问过，那么将来被访问的几率也更高。所以淘汰最近最久未使用的页面。</p><h3 id="老化算法（AGING）"><a href="#老化算法（AGING）" class="headerlink" title="老化算法（AGING）"></a>老化算法（AGING）</h3><p>LRU算法开销很大，硬件很难实现。老化算法是LRU的简化，但性能接近LRU<br><img src="老化算法.png" alt="老化算法"><br>淘汰时淘汰从左往右0最多的。</p><h2 id="工作集和驻留集"><a href="#工作集和驻留集" class="headerlink" title="工作集和驻留集"></a>工作集和驻留集</h2><h3 id="概念定义"><a href="#概念定义" class="headerlink" title="概念定义"></a>概念定义</h3><ul><li>工作集：当前正在使用的页面的集合。</li><li>驻留集：虚拟存储系统中，每个进程驻留在内存的页面集合，或进程分到的物理页框集合。<div class="note green no-icon flat"><p>何为当前？<br>工作集是在[t - Q, t]时间段内所访问的页面的集合，| W(t, Q) | 指工作集大小即页面数目</p></div><h3 id="引入目的"><a href="#引入目的" class="headerlink" title="引入目的"></a>引入目的</h3>系统应当为每个活跃进程分配多少个页框？</li><li>分配太少，缺页中断率太高，你是在跑程序还是在搞中断?</li><li>分配太多，主存干脆就跑你一个程序好了，别并发了。</li></ul><p>所以要依据进程在过去的一段时间内访问的页面来调整驻留集大小。</p><h3 id="初始分配策略"><a href="#初始分配策略" class="headerlink" title="初始分配策略"></a>初始分配策略</h3><ol><li>等分法：根据现有的进程平分物理块。</li><li>比例法：分给进程的块数=进程地址空间大小 / 全部进程的总地址空间 * 可用块总数</li><li>优先权法：优先级高的多分点，优先级低的少分点<h3 id="可选分配策略"><a href="#可选分配策略" class="headerlink" title="可选分配策略"></a>可选分配策略</h3></li><li>固定分配策略：为每个活跃进程分配固定数量的页框。</li><li>可变分配策略：首先分配一定的数量，然后根据运行时的缺页率动态调整。<div class="note purple no-icon flat"><p>听起来可变是好的，但可变带来了更加复杂的管理机制，也同样会带来性能压力。</p></div><h3 id="可选置换策略"><a href="#可选置换策略" class="headerlink" title="可选置换策略"></a>可选置换策略</h3></li><li>局部置换策略：系统在进程自身的驻留集中判断当前是否存在空闲页框，并在其中进行置换。</li><li>全局置换策略：在整个内存空间内判断有无空闲框，并允许从其它进程的驻留集中选择一个页面换出内存</li></ol><h3 id="可选组合策略"><a href="#可选组合策略" class="headerlink" title="可选组合策略"></a>可选组合策略</h3><p><img src="组合策略.png" alt="组合策略"><br><em>没有固定全局策略，固定只能和局部玩，因为你和全局玩了，你拿了别人的页面，你就不固定了。</em></p><h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><h4 id="君可知抖？"><a href="#君可知抖？" class="headerlink" title="君可知抖？"></a>君可知抖？</h4><p>进程缺页率急剧上升频繁调页使得调页开销增大。</p><h3 id="君何故抖"><a href="#君何故抖" class="headerlink" title="君何故抖?"></a>君何故抖?</h3><p>驻留集小于工作集。</p><h3 id="君如何医？"><a href="#君如何医？" class="headerlink" title="君如何医？"></a>君如何医？</h3><ol><li>采用局部置换策略，你抖你自己抖，别抢别人的页面大家最后一起抖。</li><li>引入工作集算法，根据工作集大小避免将驻留集缩小到工作集下。</li><li>预留部分页面。</li><li>挂起若干进程。</li></ol><h2 id="负载控制"><a href="#负载控制" class="headerlink" title="负载控制"></a>负载控制</h2><p>智能挂起或引入进程，最大化CPU利用。<br><div class="note green no-icon flat"><p>那如何做到智能?</p></div></p><h3 id="负载准则"><a href="#负载准则" class="headerlink" title="负载准则"></a>负载准则</h3><h4 id="L-S准则"><a href="#L-S准则" class="headerlink" title="L=S准则"></a>L=S准则</h4><p>通过调整多道程序的度，使发生两次缺页之间的平均时间（L）等于处理一次缺页所需要的平均时间（S）</p><h4 id="50-准则"><a href="#50-准则" class="headerlink" title="50%准则"></a>50%准则</h4><p>分页单元的利用率保持在50%左右。</p><h2 id="零散知识"><a href="#零散知识" class="headerlink" title="零散知识"></a>零散知识</h2><h3 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h3><p>用FIFO算法选择被置换页，把被置换的页面放入两个链表之一。即：如果页面未被修改，就将其归入到空闲页面链表的末尾，否则将其归入到已修改页面链表。</p><h3 id="双指针轮转置换算法"><a href="#双指针轮转置换算法" class="headerlink" title="双指针轮转置换算法"></a>双指针轮转置换算法</h3><p>该算法利用页面表上的几个指针维护一个空闲页面表。当空闲页面数少于一定阈值时，该算法置换一些页面加入空闲页面表。<br><img src="双指针轮盘.png" alt="双指针轮盘"></p><font size=4 color="red">天生万物以养人，人无一物以报天，现在是2023年5月28日凌晨两点，杀杀杀!</font> ]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统内存管理复习</title>
      <link href="/posts/37572/"/>
      <url>/posts/37572/</url>
      
        <content type="html"><![CDATA[<h1 id="存储器（非重要）"><a href="#存储器（非重要）" class="headerlink" title="存储器（非重要）"></a>存储器（非重要）</h1><h2 id="DRAM-动态存储器-和SRAM-静态存储器-的对比"><a href="#DRAM-动态存储器-和SRAM-静态存储器-的对比" class="headerlink" title="DRAM(动态存储器)和SRAM(静态存储器)的对比"></a>DRAM(动态存储器)和SRAM(静态存储器)的对比</h2><p><img src="DRAM和SRAM的区别.png" alt="DRAM和SRAM的区别"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>RAM: Random Access Memory</li><li><ul><li>SRAM</li></ul></li><li><ul><li>DRAM</li></ul></li><li><ul><li>SDRAM,DDR SDRAM</li></ul></li><li><p>ROM: Read Only Memory</p></li><li><ul><li>PROM,EPROM,EEPROM</li></ul></li><li><p>Flash memory(SSD)</p></li><li><ul><li>Nor</li></ul></li><li><ul><li>NAND</li></ul></li><li><p>Disk(磁盘)</p></li><li><p>Tape(磁带)</p></li></ul><h1 id="GCC包含的几个工具"><a href="#GCC包含的几个工具" class="headerlink" title="GCC包含的几个工具"></a>GCC包含的几个工具</h1><ul><li>CC1 : 预处理器和编译器</li><li>as : 汇编器</li><li>collect2 : 链接器</li></ul><h1 id="程序装入、执行的过程"><a href="#程序装入、执行的过程" class="headerlink" title="程序装入、执行的过程"></a>程序装入、执行的过程</h1><p>一般要经历预处理、编译、链接、重定位、装入。</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><img src="链接的本质.png" alt="链接的本质"></p><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>重定位分为静态重定位和动态重定位。</p><h2 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>ELF头魔数检验</li><li>找到段表项</li><li>根据段表项解析出各个段应当被加载到的虚地址，在文件中的偏移。</li><li>正式加载每一段，分配物理页面，并按虚地址映射。</li><li>用0填充内存和文件大小不匹配的区域</li><li>改PC为入口地址</li><li>开始执行</li></ol><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>我们只需要了解bss段，data段和text段。<br>bss:用来存放程序中未初始化的全局变量的一块内存区域。bss是英文Block Started by Symbol的简称。bss段属于静态内存分配。<br>data:数据段（data segment）用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。<br>text:代码段（code segment/text segment）用来存放程序执行代码的一块内存区域。<br><div class="note orange no-icon flat"><ol><li>text和data段都在可执行文件中，由系统从可执行文件中加载，而bss段不在可执行文件中，由系统初始化。 （一般为0）</li><li>一个装入内存的可执行程序，除了bss、data和text段外，还需构建一个栈（stack）和一个堆（heap）</li><li>你可以认为一个程序就是由bss、data和text段组成的</li></ol></div></p><h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><ul><li>栈：存放局部变量，函数压栈（静态）</li><li>堆：存放malloc等分配的内容（动态增缩）</li></ul><h2 id="整体细节"><a href="#整体细节" class="headerlink" title="整体细节"></a>整体细节</h2><ul><li>程序的入口点一般不是main函数，在此之前要做一些准备才能跳转到main函数。</li><li>一个segment在文件中的大小是小于等于其在内存中的大小。</li><li>如果在文件中的大小小于在内存中的大小，那么在载入内存时通过补零使其达到其在内存中应有的大小。</li><li>代码段和数据段都在segment中</li></ul><h1 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h1><p><img src="ELF.png" alt="ELF"><br>这个连接将程序头表/段头表讲的很清楚，注意的是他以64位为基础。<a href="https://zhuanlan.zhihu.com/p/389408697">ELF 文件解析 3-段</a><br>这个连接将节头表讲的很清楚，注意的是他以64位为基础。<a href="https://zhuanlan.zhihu.com/p/386573979">ELF 文件解析 1-节</a><br><div class="note orange no-icon flat"><p>记住几个结构体的名字：<br>Elf32_Ehdr 是ELF文件头的数据结构。<br>Elf32_Shdr 是节头表表项的数据结构。<br>Elf32_Phdr 是段头表表项的数据结构。</p></div></p><h1 id="存储管理"><a href="#存储管理" class="headerlink" title="存储管理"></a>存储管理</h1><h2 id="基石"><a href="#基石" class="headerlink" title="基石"></a>基石</h2><ol><li>地址独立：程序发出的地址与物理地址无关</li><li>地址保护：一个程序不能访问另一个程序的地址空间<h2 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h2>分配和回收<h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><h4 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h4>直接指定、静态分配、动态分配。<h4 id="直接指定"><a href="#直接指定" class="headerlink" title="直接指定"></a>直接指定</h4>用实际物理地址进行分配<h4 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h4>均从逻辑地址的0地址开始，链接装入时才能确认在物理内存中的地址<h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4>同样是装入时确认在物理内存中的地址，但可以动态控制程序的大小</li></ol><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>单道程序比较简单、采用直接指定的方式。</p><h2 id="多道程序"><a href="#多道程序" class="headerlink" title="多道程序"></a>多道程序</h2><h3 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h3><p>分区式分配：把内存分为一些大小相等或不等的分区(partition)，每个应用程序占用一个或几个分区。操作系统占用其中一个分区。<br><div class="note pink no-icon flat"><p>可以支持多个程序并发，但难以进行共享。</p></div></p><h3 id="划分分区的方法"><a href="#划分分区的方法" class="headerlink" title="划分分区的方法"></a>划分分区的方法</h3><h4 id="固定式分区"><a href="#固定式分区" class="headerlink" title="固定式分区"></a>固定式分区</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>把内存划分为若干个固定大小的连续分区。</p><h5 id="分配方式"><a href="#分配方式" class="headerlink" title="分配方式"></a>分配方式</h5><ul><li>单队列分配：无论大小，统一排队等待分配<br><img src="单一队列.png" alt="单一队列"></li><li>多队列分配：根据分区的大小，开多个队列针对各个分区进行分<br><img src="多队列.png" alt="多队列"><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5></li><li>优点：易于实现，开销小</li><li>缺点：内碎片造成浪费，分区数目固定，限制了并发程序数目</li><li>数据结构： 分区表，记录分区大小和使用情况</li></ul><h4 id="可变式分区"><a href="#可变式分区" class="headerlink" title="可变式分区"></a>可变式分区</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>分区的边界可以移动，即分区的大小可变。</p><h5 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h5><ul><li>首次适应：每个空白区按其在存储空间中地址递增的顺序连在一起，在为作业分配存储区域时，从这个空白区域链的始端开始查找，选择第一个足以满足请求的空白块。</li><li>下次适应：把存储空间中空白区构成一个循环链，每次为存储请求查找合适的分区时，总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将它划分后分配出去。</li><li>最佳适应算法：为一个作业选择分区时，总是寻找其大小最接近于作业所要求的存储区域。</li><li>最坏适应算法：为作业选择存储区域时，总是寻找最大的空白区</li><li>快速适应算法：把空闲分区按容量大小进行分类，经常用到长度的空闲区设立单独的空闲区链表。系统为多个空闲链表设立一张管理索引表。分配时根据索引直接查表，取下合适的空闲区链表首项即可。</li><li>伙伴系统：分区均为2的n次幂，对于一个分配请求，向上取整找最合适的，如果没有，就将大的拆成两个最合适的，一个挂在表中，一个分配，这两个成为伙伴，只有两个同时空闲，就会向上重新合并成大的，直到合不了位置。</li></ul><h5 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h5><ul><li>内碎片：指分配给作业的存储空间中未被利用的部分，如固定分区中存在的碎片。</li><li>外碎片：指系统中无法利用的小的空闲分区。如分区与分区之间存在的碎片。这些不连续的区间就是外部碎片。动态分区管理会产生外部碎片，可以通过紧凑进行进行缓解，通过多重分区分配进行缓解。<div class="note pink no-icon flat"><p>一个作业往往由相对独立的程序段和数据段组成，将这些片断分别装入到存储空间中不同的区域内的分配方式。</p></div></li></ul><h3 id="分区保护"><a href="#分区保护" class="headerlink" title="分区保护"></a>分区保护</h3><ol><li>界限寄存器：上下界寄存器方法、基址、限长寄存器方法。</li><li>存储保护键方法：给存储块配锁，访问前看锁和钥匙是否匹配。</li></ol><h2 id="内存扩展"><a href="#内存扩展" class="headerlink" title="内存扩展"></a>内存扩展</h2><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>把一个程序划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称为覆盖段） ，共享主存的同一个区域，这种内存扩充技术就是覆盖。</p><h4 id="工作主体"><a href="#工作主体" class="headerlink" title="工作主体"></a>工作主体</h4><p>程序员指明覆盖结构，操作系统完成。</p><h4 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h4><p><img src="覆盖.png" alt="覆盖"></p><h3 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>广义的说，所谓交换就是把暂时不用的某个（或某些）程序及其数据的部分或全部从主存移到辅存中去，以便腾出必要的存储空间；接着把指定程序或数据从辅存读到相应的主存中，并将控制转给它，让其在系统上运行。</p><h4 id="工作主体-1"><a href="#工作主体-1" class="headerlink" title="工作主体"></a>工作主体</h4><p>操作系统独立完成。</p><h4 id="图示-1"><a href="#图示-1" class="headerlink" title="图示"></a>图示</h4><p><img src="交换.png" alt="交换"></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>覆盖可减少一个程序运行所需的空间。交换可让整个程序暂存于外存中，让出内存空间。</li><li>覆盖是由程序员实现的，操作系统根据程序员提供的覆盖结构来完成程序段之间的覆盖。交换技术不要求程序员给出程序段之间的覆盖结构。</li><li>覆盖技术主要对同一个作业或程序进行。交换主要在作业或程序间之间进行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统启动复习</title>
      <link href="/posts/59341/"/>
      <url>/posts/59341/</url>
      
        <content type="html"><![CDATA[<h1 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h1><h2 id="全流程图"><a href="#全流程图" class="headerlink" title="全流程图"></a>全流程图</h2><p><img src="MIPS启动.png" alt="MIPS启动"><br>（框选为流程中谁占有CPU）</p><h2 id="文字注解"><a href="#文字注解" class="headerlink" title="文字注解"></a>文字注解</h2><h3 id="GPT解释"><a href="#GPT解释" class="headerlink" title="GPT解释"></a>GPT解释</h3><p><img src="MIPSGPT.png" alt="MIPSGPT"></p><h3 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h3><h4 id="解释一"><a href="#解释一" class="headerlink" title="解释一"></a>解释一</h4><p>BootLoader是Booter和Loader的合写：<br>Booter要初始化系统硬件使之运行起来，至少是部分运行起来。<br>Loader将操作系统映像加载到内存中，并跳转到操作系统的代码运行。</p><h4 id="解释二"><a href="#解释二" class="headerlink" title="解释二"></a>解释二</h4><p>BootLoader都分为stage1和stage2两大部分：</p><ul><li>依赖于cpu体系结构的代码（如设备初始化代码等）通常都放在stage1且可以用汇编语言来实现；<br><img src="Stage1具体流程.png" alt="Stage1具体流程"></li><li>stage2则通常用C语言来实现，这样可以实现复杂的功能，而且有更好的可读性和移植性；</li></ul><p><img src="Stage2具体流程.png" alt="Stage2具体流程"><br>将内核加载到内存也是在这一阶段完成的。<br><div class="note blue no-icon flat"><p>我们见到的U-Boot就是BootLoader的具体一种。</p></div></p><h2 id="引导操作系统（Linux）"><a href="#引导操作系统（Linux）" class="headerlink" title="引导操作系统（Linux）"></a>引导操作系统（Linux）</h2><p>这一部分对应流程图中第二个方框，在BootLoader加载内核镜像到内存后，控制权交给操作系统，Bootloader结束工作，操作系统开始进行自初始化。</p><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><h4 id="一阶段"><a href="#一阶段" class="headerlink" title="一阶段"></a>一阶段</h4><p><img src="Linux启动第一阶段.png" alt="Linux启动第一阶段"></p><h4 id="二阶段"><a href="#二阶段" class="headerlink" title="二阶段"></a>二阶段</h4><p><img src="Linux启动第二阶段.png" alt="Linux启动第二阶段"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经历过流程图中的启动，在mips上的启动就已经完全完成了。</p><h1 id="X86"><a href="#X86" class="headerlink" title="X86"></a>X86</h1><h2 id="全流程图-1"><a href="#全流程图-1" class="headerlink" title="全流程图"></a>全流程图</h2><p><img src="X86启动.png" alt="X86启动"></p><h2 id="文字注解-1"><a href="#文字注解-1" class="headerlink" title="文字注解"></a>文字注解</h2><h3 id="GPT解释-1"><a href="#GPT解释-1" class="headerlink" title="GPT解释"></a>GPT解释</h3><p><img src="X86GPT.png" alt="X86GPT"><br>GPT这里有点问题，就是BootLoader的位置，详情看注意事项。</p><h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><ul><li>BIOS进行关键硬件设备的初始化</li><li>BIOS在主板ROM中存储</li><li>BIOS中包含了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息、PnP特性等等</li></ul><div class="note orange no-icon flat"><p>BIOS只能寻址16-20位，即64KB-1M的内存，管理内存较少，逐渐跟不上时代，UEFI异军突起。</p></div><h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><ul><li>硬盘上第0磁头第0磁道第一个扇区被称为MBR，也就是Master Boot Record，即主引导记录，它的大小是512字节。</li><li>MBR包含三部分内容，前446字节为启动代码和数据，后面为分区表，最后跟两个幻数标识这是MBR<h3 id="BootLoader-1"><a href="#BootLoader-1" class="headerlink" title="BootLoader"></a>BootLoader</h3>Boot loader 也可以称之为操作系统内核加载器(OS kernel loader), 是操作系统内核运行之前运行的一段小程序。通过这段小程序，我们可以初始化硬件设备、建立内存空间的映射图，从而将系统的软硬件环境带到一个合适的状态，以便为最终调用操作系统内核做好一切准备。通常是严重地依赖于硬件而实现的。<h3 id="引导操作系统（Linux）-1"><a href="#引导操作系统（Linux）-1" class="headerlink" title="引导操作系统（Linux）"></a>引导操作系统（Linux）</h3>Linux启动的工作除体系结构相关部分外，其它都与MIPS几乎一样。</li></ul><h1 id="X86与MIPS启动对比"><a href="#X86与MIPS启动对比" class="headerlink" title="X86与MIPS启动对比"></a>X86与MIPS启动对比</h1><ol><li>MIPS没有BIOS，直接使用BootLoader启动；X86先经过BIOS,再使用BootLoader启动。（这一条很重要）。</li><li>MIPS和X86的BootLoader略有区别，MIPS更定制化一些，X86由于已经有BIOS了，可能普适一些（这一条纯个人理解）。</li><li>MIPS不存在MBR的概念，X86存在，且需要MBR。</li><li>MBR存在于第0磁头第0磁道第一个扇区，而引导扇区Boot Sector（也叫分区引导记录（PBR））存在于每一个分区的第一个扇区。</li><li>MBR不属于任何一个分区，所以不要纠结什么PBR和MBR重合的问题。</li><li>X86里面有很多BootLoader，你可以认为MBR，PBR本身是BootLoader，也可以认为MBR有一个BootLoader，PBR又指向一个BootLoader（这个比较真），但以应试为准的话，就认为PBR指向的为BootLoader吧（这是王道的定义，即流程图的理解）<br><img src="MBR与PBR.png" alt="MBR与PBR"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统引论复习</title>
      <link href="/posts/53776/"/>
      <url>/posts/53776/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统定义"><a href="#操作系统定义" class="headerlink" title="操作系统定义"></a>操作系统定义</h1><h2 id="OS课程定义"><a href="#OS课程定义" class="headerlink" title="OS课程定义"></a>OS课程定义</h2><p>操作系统是一组管理计算机硬件资源的软件集合，它向计算机程序提供共性的服务。</p><h2 id="王道定义"><a href="#王道定义" class="headerlink" title="王道定义"></a>王道定义</h2><p>操作系统是指控制和管理整个计算机系统的硬件与<strong>软件资源</strong>，合理的组织、调度计算机的工作与资源的分配，进而为用户和其他软件提供方便接口与环境的程序集合。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>最大的区别在于OS课程没有强调操作系统同时管理软件资源，软硬件资源合称<em>计算机资源</em><br><div class="note blue no-icon flat"><p>软件资源指为方便使用计算机和提高使用效率而组织的程序以及用于开发、使用和维护的有关文档。软件系统可分为系统软件和应用软件两大类资源。</p></div></p><h1 id="操作系统定位"><a href="#操作系统定位" class="headerlink" title="操作系统定位"></a>操作系统定位</h1><ul><li>操作系统是计算机系统中最基本的<strong><em>系统软件</em></strong>，也就是它的本质仍为软件。</li><li>操作系统管理硬件、为上层提供统一接口从而方便使用、并提供保护（内核态）。<br><img src="操作系统定位.png" alt="操作系统定位"></li></ul><h1 id="操作系统特征"><a href="#操作系统特征" class="headerlink" title="操作系统特征"></a>操作系统特征</h1><p>并发，共享，虚拟，异步。<br><div class="note orange no-icon flat"><p>并发指的是宏观上两个或多个事件在同一时间间隔内发生，实际上，对于单CPU环境，每一时刻只能有一个程序执行。但在宏观上好像在同时执行，称为并发。<br>并行指的是在每一时刻都有两个或多个事件在同时发生，这是真正的同时进行。<br>把在一段时间内只允许一个进程访问的资源称为临界资源。</p></div></p><h1 id="操作系统功能"><a href="#操作系统功能" class="headerlink" title="操作系统功能"></a>操作系统功能</h1><p>计算机系统资源的管理者</p><ul><li>处理机管理</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>作业控制</li></ul><p>作为用户和计算机硬件系统之间的接口</p><div class="note pink no-icon flat"><p>裸机是指没有任何软件支持（包括操作系统）的计算机。</p></div><h1 id="操作系统历史"><a href="#操作系统历史" class="headerlink" title="操作系统历史"></a>操作系统历史</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="操作系统历史.png" alt="操作系统历史"></p><h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>系统对作业的处理成批进行，但内存中只始终保持一道作业。</p><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><p>在处理中，如果该作业需要进行IO操作，CPU会在IO期间等待而什么也不做，显然没有利用最大化</p><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>多道程序设计技术的引入使得多道批处理可以实现，其允许多个程序同时进入内存并允许它们在CPU中交替运行，当某一程序因为IO操作暂停运行时，CPU不再空闲等待，而是引入另一个程序继续执行。将这些空闲时间利用了起来。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>多道，成批。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>资源利用率高，系统吞吐量大，CPU和其他资源保持忙碌状态</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>平均周转时间长，用户响应时间较长，没有人机交互能力，用户不能了解自己的程序的运行情况，又不能控制计算机。</p><h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><ul><li>需要人机交互</li><li>需要支持多用户，多进程</li></ul><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>将CPU处理时间分割为多个时间片，将时间片分给不同程序，达到多个程序“同时”运行的效果。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><p>同时性、交互性、独立性、及时性</p><h3 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h3><h4 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h4><p>有些场景下，有些需求需要快速被响应，过时则会带来严重后果。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>硬实时系统：某个动作必须绝对在规定的时刻完成</li><li>软实时系统：接受偶尔的违反时间规定，不造成永久性损害。</li></ul><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>及时性、可靠性</p><h3 id="网络和分布式操作系统"><a href="#网络和分布式操作系统" class="headerlink" title="网络和分布式操作系统"></a>网络和分布式操作系统</h3><h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><p>将网络中的各台计算机有机的结合起来，提供一种统一、经济而有效的使用各台计算机的方法、实现各台计算机间的数据的互相传送。<br>特点是：网路中资源的共享和计算机间的通信</p><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><p>多台计算机组成，互相通信、同等地位、资源共享、任意计算机都可组成可重构的子系统，最重要的是一个任务可以分布在多个计算机上共同完成工作。<br>特点是：分布性和并行性<br><div class="note orange no-icon flat"><p>这两个操作系统可能在定义上看起来比较相似，但它们的本质区别是：分布式操作系统中的若干计算机相互协同完成同一任务。</p></div></p><h1 id="操作系统实现"><a href="#操作系统实现" class="headerlink" title="操作系统实现"></a>操作系统实现</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>区别于王道，我们课程认为异常可以包括中断，其分类如下：<br><img src="异常.png" alt="异常"></p><h3 id="异步异常"><a href="#异步异常" class="headerlink" title="异步异常"></a>异步异常</h3><p>主要指的是中断，其随时可能发生，所以是异步的。</p><h3 id="同步异常"><a href="#同步异常" class="headerlink" title="同步异常"></a>同步异常</h3><p>是某一特定指令执行的结果。所以是同步的。</p><h1 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h1><h2 id="模块接口"><a href="#模块接口" class="headerlink" title="模块接口"></a>模块接口</h2><p><img src="模块接口.png" alt="模块接口"></p><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>模块接口是将操作系统按功能划分为若干具有一定独立性的模块。各模块之间通过规定好的接口进行通信</p><h3 id="划分标准"><a href="#划分标准" class="headerlink" title="划分标准"></a>划分标准</h3><ul><li>内聚性：模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好</li><li>耦合度：模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好<br><strong><em>高内聚，低耦合</em></strong><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3>加速了操作系统的研制过程、增加了操作系统的灵活性、便于修改和维护。<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3>接口定义困难、无序性，这种无序导致测试起来很麻烦，只能整体测正确性。<h2 id="有序分层法"><a href="#有序分层法" class="headerlink" title="有序分层法"></a>有序分层法</h2><img src="有序分层.png" alt="有序分层"><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3>将操作系统分成若干层（注意是操作系统），最底层为硬件，最高层为用户接口，每层只能调用紧邻它的低层的功能和服务。<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3></li><li>便于系统测试，先测里面的，再套一层测这一层的正确性，一层一层套上去、</li><li>易于扩充和维护，加层数就好。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>层间定义困难</li><li>运行效率低，通过的层数太多。</li></ul><h2 id="虚拟机结构"><a href="#虚拟机结构" class="headerlink" title="虚拟机结构"></a>虚拟机结构</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>虚拟机是一台逻辑计算机，利用特殊的虚拟化技术，隐藏特定计算平台的实际物理特性，为用户提供抽象的，统一的、模拟的计算环境。</p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>可以实现完全保护，安全性很高</li><li>用软件向硬件逐层扩展</li><li>把多道程序和扩充机器的功能完全分开，让两部分都变得简单灵活和易于维护</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><p>性能开销比较大</p><h2 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>将最基本的功能保留在内核，其余全部移到用户态执行，减少内核的负载和设计复杂性。</p><ul><li>内核中只包括中断处理、进程通信（IPC）、基本调度等</li><li>文件系统、网络功能、内存管理、设备管理等作为服务在微内核上运行。</li></ul><div class="note pink no-icon flat"><p>服务指的就是用户进程。</p></div><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ol><li>内核易于实现，可移植性好、配置灵活、适应分布式环境</li><li>服务崩溃不会导致整个操作系统崩溃，重启服务就行。</li></ol><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><p>速度较慢，切换比较多。</p><div class="note purple no-icon flat"><p>深刻体现了机制与策略分开的设计思路，微内核提供机制，执行体（服务）提供策略<br>机制是实现某一功能的具体执行机构，策略是在机制的基础上借助某些参数和算法来实现优化，或达到不同的功能目标。<br>参考:<a href="https://blog.csdn.net/lhwhit/article/details/108007853">机制与策略分开</a></p></div><h3 id="客户端-服务器模型"><a href="#客户端-服务器模型" class="headerlink" title="客户端-服务器模型"></a>客户端-服务器模型</h3><p>微内核采用的一种模型。<br><img src="服务器模型.png" alt="服务器模型"></p>]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Manacher算法</title>
      <link href="/posts/30323/"/>
      <url>/posts/30323/</url>
      
        <content type="html"><![CDATA[<p>这个算法应用在日常中还是比较常见使用的，但不知道为什么很少人讲这个算法，至少在我的身边是这样。</p><h1 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h1><p>给定如下序列，求其最长回文子串的长度<br>$${\rm{a}}baccabd$$<br>没错，Manacher就是解决这种最长回文字串的问题，其时间复杂度为O(n)。<br><div class="note orange no-icon flat"><p>暴力解法时间复杂度为O(n^2)。<br>双指针解法时间复杂度为O(n^2)。<br>动态规划解法时间复杂度为O(n^2)。<br>现在知道选谁了吧（</p></div></p><h1 id="算法学习"><a href="#算法学习" class="headerlink" title="算法学习"></a>算法学习</h1><h2 id="处理输入"><a href="#处理输入" class="headerlink" title="处理输入"></a>处理输入</h2><h3 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h3><p>先看两个回文串的例子：<br>$$aabbaa$$<br>这个回文串的中心位置在两个B的中间，我们叫它虚对称轴。<br>$$aabaa$$<br>这个回文串的中心位置在B，我们叫它实对称轴。<br>在任何给定的回文串中，都可能会出现这两种情况，处理第二种情况显然是比较轻松的。第一种则比较复杂，那么为了处理方便，我们可以把任意给定的字符串的虚对称轴实化：<br>$$a*a*b*a*a$$<br>即用一个符号显式表示出虚对称轴，这样，我们就将第一种情况归一化到了第二种情况，处理时候只处理第二种情况即可。<br><div class="note blue no-icon flat"><p>需要注意，我们在两个字符之间插入“*”会导致字符串整体扩大2倍，所以最后的答案要/2。</p></div></p><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] manacherString(String str) &#123;</span><br><span class="line">    <span class="type">char</span>[] charArr = str.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] res = <span class="keyword">new</span> <span class="title class_">char</span>[str.length() * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">        res[i] = (i &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="string">&#x27;#&#x27;</span> : charArr[index++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>实现Manacher算法，需要三个额外空间：</p><ul><li>当前寻找到的回文串的最右位置R</li><li>该回文串的中心位置C</li><li>每一个位置的回文半径</li></ul><p>之后从左到右枚举每一个位置i,计算以这个位置为对称轴得到的最大回文半径。有以下四种情况：</p><ol><li>i在R外，此时暴力枚举，更新C，R，该位置的回文半径。<br><img src="i在R外.png" alt="i在R外"></li><li>i在R内，i相对于R的对称轴i’, i’的回文半径r’满足如下关系：$$C - R > i' - r'$$        r’即为i位置的最大回文半径。<br><img src="i在R内1.png" alt="i在R内1"></li><li>i在R内，i相对于R的对称轴i’,i’的回文半径r’满足如下关系$$C - R < i' - r'$$        <code>C+R-i</code>即为i位置的最大回文半径r.本题为1,(看起来是0只是因为“*”没画出来)<br><img src="i在R内2.png" alt="i在R内2"></li><li>i在R内，i相对于R的对称轴i’,i’的回文半径r’满足如下关系$$C - R = i' - r'$$ i的r在半径为r’的基础上暴力枚举。<br><img src="i在R内3.png" alt="i在R内3"><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3>暴力枚举大家都懂，我们主要讲后三种情况：</li></ol><ul><li>第二种：先证明 <code>r &gt;= r&#39;</code>, 由于 i 和 i’ 关于C对称，<code>[C-R,C+R]</code>为以C为对称轴的回文串，现在已知C左边i’的回文串半径是r’, 所以对于右边的i来说，按照同样的半径，这两个串也是关于C对称的，所以既然左边已经是回文串，那么右边必然也是回文串。所以可以得到r至少为r’;<br>再证明<code>r = r&#39;</code> 若r比r’大1，那么由于 <code>C + r &lt; C + R</code>, 所以 <code>C ＋ r ＋ 1 &lt;= C + R</code>,即新的区间仍然在<code>[C-R,C+R]</code>为以C为对称轴的回文串内，那么根据区间的对称性，理应i’的回文半径也得＋1，但显然i’的回文半径就是r’，矛盾，所以<code>r = r&#39;</code><br><img src="i在R内1.png" alt="i在R内1"></li><li>第三种，先证明 <code>r &gt;= C + R - i</code>, 同理第二种，由<code>[C-R,C+R]</code>内的对称性可得，<code>r &gt;= C + R - i</code> ， 现在证明 <code>r = C + R - i</code>,假设 <code>r &gt; C + R - i</code> ,则考虑<code>C+R+1</code>,<code>C-R-1</code>,如果<code>C+R+1</code>在i的回文半径内，则由回文串的性质，<code>C+R+1</code>的字符与 <code>2i - C - R - 1</code> ，这两点关于i对称，而 <code>2i - C - R - 1</code> 在<code>[C-R,C+R]</code>内，所以求其关于C的对称<code>3C -  2i + R + 1</code> ，得到i’回文半径内的一点，再由i’作为对称轴得到<code>2i&#39; - 3C + 2i - R - 1</code>. 结合i’与i的关系 <code>i&#39; + i = 2C</code>,带入得，该点坐标为<code>C-R-1</code>,那么<code>C-R-1</code>与<code>C+R+1</code>应该是相等的，那么R应该在原来的基础上＋1，但显然不是这样，所以矛盾。<br><img src="i在R内2.png" alt="i在R内2"></li><li>第四种，同理第三种的情况，r’的最小值为<code>C + R - i</code>,  但由于正好擦边，所以第三种后面的证明已经不成立了，这时候就只能暴力枚举了R外的情况了。<br><img src="i在R内3.png" alt="i在R内3"><div class="note orange no-icon flat"><p>这里的证明不太好理解，结合一下刚才的图片理解即可。</p></div><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxLcpsLength</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>[] str = manacherString(s);</span><br><span class="line">    <span class="type">int</span>[] pArr = <span class="keyword">new</span> <span class="title class_">int</span>[str.length];</span><br><span class="line">    <span class="type">int</span> <span class="variable">C</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//中心</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">//回文右边界再往右一个位置 最右的有效区是R-1位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length ; i++) &#123;</span><br><span class="line">        pArr[i] = R &gt; i ? Math.min(pArr[<span class="number">2</span> * C - i],R - i) : <span class="number">1</span>; <span class="comment">//至少不用验的区域</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i + pArr[i] &lt; str.length &amp;&amp; i - pArr[i] &gt; -<span class="number">1</span>) &#123; <span class="comment">//四种情况中的两种扩一次也会失败，所以无所谓</span></span><br><span class="line">            <span class="keyword">if</span> (str[i + pArr[i]] == str[i - pArr[i]]) &#123;</span><br><span class="line">                pArr[i]++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i + pArr[i] &gt; R) &#123; <span class="comment">//更新C和R</span></span><br><span class="line">            R = i + pArr[i];</span><br><span class="line">            C = i;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,pArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res - <span class="number">1</span>; <span class="comment">//半径-1就是答案</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3>代码对以上的思路进行了综合，导致其看起来不像之前的思路那样好理解，首先是R设置为了回文右边界再往右一个位置，这是为了处理的方便。<br>之后是对于四种情况的处理，其实完全可以用四个<code>if-else</code>来处理，但那样代码太长，为了简短代码，天才们提取出了四种情况的共性，写成了<code>while</code>里面的东西，即反正对于第二三种情况，扩一次也会自动失败，所以认为他们也首先暴力扩张也没关系。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯估计</title>
      <link href="/posts/61719/"/>
      <url>/posts/61719/</url>
      
        <content type="html"><![CDATA[<p>这是北航由刘雪峰老师讲授的信号处理与信息推断课程，本人根据老师PPT在期末复习时总结如下，如有侵权，立刻删除。<br>在这里也鼓励计算机学院的大家去选这门课，真的对人生很有帮助。</p><hr><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="信息推断"><a href="#信息推断" class="headerlink" title="信息推断"></a>信息推断</h2><p>信息推断是指从观察到的现象、推测出现象背后隐藏的信息。<br><div class="note orange no-icon flat"><p>即从表象推本质，这显然是很难做到准确的，因为内因与外在不是一一对应的，且千人千面。</p></div></p><h2 id="错误的信息推断"><a href="#错误的信息推断" class="headerlink" title="错误的信息推断"></a>错误的信息推断</h2><h3 id="黑白思维"><a href="#黑白思维" class="headerlink" title="黑白思维"></a>黑白思维</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>一件事情发生的原因只有一个，而且是我认为的那个，在此期间我只会找能加强我认为的原因的证据来确信想法。</p><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>事情发生的原因不止一个</li><li>证据是没有用的，你只找加强你自信心的证据</li></ul><h2 id="较好的信息推断"><a href="#较好的信息推断" class="headerlink" title="较好的信息推断"></a>较好的信息推断</h2><h3 id="概率思维"><a href="#概率思维" class="headerlink" title="概率思维"></a>概率思维</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>找到一件事情背后尽可能的原因，搜集尽可能的数据，来给原因给予概率，找最大的原因作为最终的原因。</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><ul><li>不会遗漏原因</li><li>证据有用，用来调整概率</li><li>信息量大（搜集了全面的证据）</li></ul><h3 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>对于一件事情列举所有可能的原因，找到每一个原因产生该事实的概率，选择概率最大的原因作为结论，即最有可能产生该现象的原因。</p><h4 id="地位"><a href="#地位" class="headerlink" title="地位"></a>地位</h4><p>这是概率思维的具体体现</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>好处自然是概率思维的好处</li><li>缺陷：忽略了这个原因本身发生的可能性，可能会导致结论出错。</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>坐在飞机上飞行，突然飞机剧烈颠簸，显然有如下的两个原因：</p><ol><li>飞机出现故障</li><li>飞机遇到了气流</li></ol><p>根据最大似然估计，若飞机出现故障，几乎100%会剧烈颠簸，但若飞机遇到气流，却不一定会剧烈颠簸，所以按照最大似然估计，我们认为飞机出事了。</p><p>但实际上，飞机作为世界上最安全的交通工具，出事的概率为20万分之一，而遇到气流的概率为10%，我们尽可能地往小估计，遇到气流后，发生颠簸的概率为10%，那么坐100次飞机我们遇到一次颠簸，坐200000次飞机遇到一次出事，现在还能说我们认为飞机出事吗？<br><div class="note orange no-icon flat"><p>这就是原因本身的概率对结果的影响。</p></div></p><h1 id="贝叶斯"><a href="#贝叶斯" class="headerlink" title="贝叶斯"></a>贝叶斯</h1><h2 id="概率概念"><a href="#概率概念" class="headerlink" title="概率概念"></a>概率概念</h2><h3 id="先验概率"><a href="#先验概率" class="headerlink" title="先验概率"></a>先验概率</h3><p>指根据以往经验和分析。在实验或采样前就可以得到的概率。<br>P（原因i）就是在观测之前，对于原因i本身成立的概率的评估。</p><h3 id="后验概率"><a href="#后验概率" class="headerlink" title="后验概率"></a>后验概率</h3><p>指某件事已经发生，想要计算这件事发生的原因是由某个因素引起的概率。<br><div class="note orange no-icon flat"><p>显然，我们想寻求的就是后验概率。</p></div></p><h3 id="似然概率"><a href="#似然概率" class="headerlink" title="似然概率"></a>似然概率</h3><p>P(观测到的现象|原因i),是在原因i成立时，观察到该现象出现的概率。这概率描述了原因i的解释力度。</p><h3 id="总体概率"><a href="#总体概率" class="headerlink" title="总体概率"></a>总体概率</h3><p>P（观测到的现象），是指在没有任何前提下，该观测到的现象总体发生的概率。</p><h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2>$$P(AIB) = { {P(A)P(BIA)} \over {P(B)} }$$<p>转化到信息推断这里就是：<code>P(原因i|观测到的现象) = P(原因i) * P(观测到的现象|原因i) / P(观测的现象)</code></p><h2 id="图形解释"><a href="#图形解释" class="headerlink" title="图形解释"></a>图形解释</h2><p><img src="图解法.png" alt="图解法"><br>根据《雄厚》的数学功底，我们要想求P（飞机遇到气流|飞机颠簸），就是相当于求左边绿色的区域/（绿色+蓝色）区域总和<br>现在我们等价变形如下：<br><img src="面积换算.png" alt="面积换算"><br>显然，这就是贝叶斯公式：<br><img src="贝叶斯图形得出.png" alt="贝叶斯图形得出"></p><h2 id="文字解释"><a href="#文字解释" class="headerlink" title="文字解释"></a>文字解释</h2><p>贝叶斯公式的含义就是：后验概率是在先验概率的基础上用观测的现象进行调整的结果。<br>我们选择最大的后验概率，就是选择了既能够在一定程度上解释观测到的现象，本身又常见的原因。<br><div class="note blue no-icon flat"><p>最大似然估计选出来的是最能解释观测的原因。</p></div><br><div class="note orange no-icon flat"><p>后验概率 = 先验概率 X 标准化的似然概率</p></div></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>奥卡姆剃刀：对于一个或多个现象，能用假定最少解释的，绝不用假定多的</li></ul><p>这是由于假定越少，先验概率越大。在奥卡姆剃刀中假设似然概率相同。</p><h1 id="先验概率-1"><a href="#先验概率-1" class="headerlink" title="先验概率"></a>先验概率</h1><h2 id="先验概率的重要性"><a href="#先验概率的重要性" class="headerlink" title="先验概率的重要性"></a>先验概率的重要性</h2><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>先验概率是该原因整体上发生的概率，在贝叶斯公式中占有很高的地位，所以有时候起着一锤定音的作用。</li><li>在很多能解释现象的原因上，似然概率都大差不差，所以中心就在于先验概率</li></ul><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><ol><li>守门员扑点球根据先验概率，每个球员的常用点球方向</li><li>外部视角看待事情，外部视角代表着先验概率</li><li>锚定效应，起始的锚锁定了你的先验概率。</li><li>汉隆剃刀，能用愚蠢解释不用恶意解释，这个世界对你的恶意远没有你想象的多，所以以恶意作为先验概率必然低。</li></ol><h2 id="先验概率的求法"><a href="#先验概率的求法" class="headerlink" title="先验概率的求法"></a>先验概率的求法</h2><ol><li>根据对象的历史记录</li><li>用样本估计总体</li></ol><h1 id="似然概率-1"><a href="#似然概率-1" class="headerlink" title="似然概率"></a>似然概率</h1><h2 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h2>$${ {P(AI{H_i})} \over {P(A)} } = { {P(AI{H_i})} \over {P(AI{H_1}) \times P({H_1}) + P(AI{H_2}) \times P({H_2}) +  \cdots P(AI{H_n}) \times P({H_n})} }$$<h2 id="观测的信息量"><a href="#观测的信息量" class="headerlink" title="观测的信息量"></a>观测的信息量</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>出人意料的程度，某个信息的信息量，改变认知越大，越出乎意料，信息量就越大，反之越小</p><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><p>依旧是贝叶斯公式：<br>$$P({H_i}IA) = P({H_i}) \times { {P(AI{H_i})} \over {P(A)} }$$<br>P（Hi）是先验概率，在观测前对Hi的认知<br>P（Hi|A)是后验概率，是在观测后对Hi的认知<br>后验概率是在先验概率的基础上，用当前观测做的调整。</p><p>调整幅度大，越说明这个观测的信息量大，因为它改变了你的认知，信息量大的证据也叫<font color="red" size = 5>排他性证据</font></p><div class="note green no-icon flat"><p>什么样的观测可以直观得出信息量大？</p><ol><li>当Hi完全不能解释A，即P(A|Hi) = 0,这样会导致分子为0,后验概率直接被扭转为0</li><li>除了Hi之外，其他所有原因都不能解释A,即P(A|Hj) = 0 (i!=j),这样会导致相互消除，后验概率被直接扭转为1</li></ol></div><div class="note pink no-icon flat"><p>什么样的观测可以直观得出信息量小？</p><ol><li>当每个原因对观测的解释力度都差不多的时候，即P（A|H1）= P（A|H2）= P（A|H3）= a,此时原贝叶斯公式化简为P（Hi|A) = P(Hi),可见观测A没作用。</li></ol></div><h1 id="解释与排他"><a href="#解释与排他" class="headerlink" title="解释与排他"></a>解释与排他</h1><p>解释一件事情是很容易的，即很容易找到可以引起这个观测的原因，但找到排他性证据是很难的，即很难找到一个只能被一个原因解释的观测。</p><h1 id="改变观念的难度"><a href="#改变观念的难度" class="headerlink" title="改变观念的难度"></a>改变观念的难度</h1><h2 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h2><ul><li>因为坚信观念，所以主动收集加强观念的证据</li><li>因为坚信观念，证据也很难立刻改变认知。</li></ul><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><p><img src="公式推导1.jpg" alt="公式推导1"><br>其中,<code>R = P(A|~H) / P(A|H)</code><br>可见以下三种情况</p><ol><li>R &gt; 1,则分母最终大于1，后验概率相比先验概率变低，说明~H比H能够更好的解释观测A.</li><li>R &lt; 1,则分母最终小于1，后验概率相比先验概率升高，说明H比~H能够更好的解释观测A.</li><li>R = 1,则分母最终等于1，后验概率相比先验概率不变，说明H和~H对观测A的解释力度相当.<br>与此同时，最终的变化幅度还受到了<code>1-P(H)</code>的限制，而如果坚信观念，我们认为<code>P（H）</code>一般比较高，所以<code>1-P(H)</code>很低，变化幅度被大幅削弱了，这说明观念的难以改变。</li></ol><h1 id="条件独立"><a href="#条件独立" class="headerlink" title="条件独立"></a>条件独立</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><h3 id="理解一"><a href="#理解一" class="headerlink" title="理解一"></a>理解一</h3><p>在数学上，如果事件A和事件B关于事件C条件独立，那么有<br><code>P(A,B|C) = P(A|C) * P(B|C)</code><br>事件C发生的前提下，A和B同时发生的概率等于在C发生的前提下A发生的概率乘以C发生的前提下乘以B发生的概率。</p><h3 id="理解二"><a href="#理解二" class="headerlink" title="理解二"></a>理解二</h3><p><code>P(A|B,C) = P(A|C)</code><br><code>P(B|A,C) = P(B|C)</code><br>如果事件A和事件B关于事件C条件独立，那么在事件C发生的前提下，我们能否知道A（或者B）发生了，对我们推断B（或者A）发生了没有任何帮助。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>很多情况下，两个事件从统计意义上是相关的，但是它们都是关于背后的另外一个事件条件独立的。</p><h1 id="多观测下的贝叶斯"><a href="#多观测下的贝叶斯" class="headerlink" title="多观测下的贝叶斯"></a>多观测下的贝叶斯</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2>$$P({H_i}I{A_1},{A_2}) = P({H_i}) \times { {P({A_1},{A_2}I{H_i})} \over {P({A_1},{A_2})} }$$<p>用信息推断来讲，就是<code>P（原因i|观测1，观测2）= P（原因i） * P（观测1，观测2|原因i）/ P（观测1，观测2）</code></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>若两个观测在Hi下条件独立，原式可化简为</li></ol>$$P({H_i}I{A_1},{A_2}) = P({H_i}) \times { {P({A_1}I{H_1}) \times P({A_2}I{H_i})} \over {P({A_1},{A_2})} }$$<ol><li>若两个观测在H1,H2,H3…Hn下都条件独立，原式可进一步化简为</li></ol>$$P({H_i}I{A_1},{A_2}) = P({H_i}) \times { {P({A_1}I{H_1}) \times P({A_2}I{H_i})} \over {\sum\limits_{k = 1}^n {P({A_1}I{H_k}) \times P({A_2}I{H_k}) \times P({H_k})} } }$$<div class="note orange no-icon flat"><p>现实中，完全独立的事情太少见了，因此我们假设条件独立。</p></div><div class="note green no-icon flat"><p>判断独立，可以通过P(A1,A2)是否等于P(A1)P(A2)得知，但一般情况这个公式不好用，建议使用P(A1|A2)是否等于P(A1)来判断。</p></div><h1 id="依次到来的观测"><a href="#依次到来的观测" class="headerlink" title="依次到来的观测"></a>依次到来的观测</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>设想这样一种情形，我们想对某件事情做一个推断，但观测是依次到来的，我们的贝叶斯计算显然如下：</p><ol><li>观测1到来，计算P(原因i|观测1)</li><li>观测2到来，计算P(原因i|观测1,观测2)</li><li>观测3到来，计算P(原因i|观测1,观测2,观测3)</li></ol><p>这确实是显然的，但在计算策略上，我们是否需要每次都利用贝叶斯重新计算一次？</p><h2 id="在线贝叶斯"><a href="#在线贝叶斯" class="headerlink" title="在线贝叶斯"></a>在线贝叶斯</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul><li>和某个原因相关的观测是源源不断到来的。</li><li>在拿到一个新观测的时候，不需要根据所有的观测来重新计算后验概率，而是在之前的后验概率基础上，用新的观测来更新</li></ul><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3>$$P({H_i}I({A_1},{A_2} \ldots {A_{k - 1} }),{A_k}) = P({H_i}I({A_1},{A_2} \ldots {A_{k - 1} })) \times { {P({A_k}I{H_i})} \over {P({A_k}I({A_1},{A_2} \ldots {A_{k - 1} }))} }$$<p>文字描述就是：（K时刻的后验概率 = K-1时刻的后验概率 * K时刻的标准化的似然概率）<br><div class="note purple no-icon flat"><p>在K-1时刻的后验概率，在K时刻变成了先验概率，说明：<br>先验概率P(原因i)，是对所有历史积累信息的沉淀和总结。即P（原因i|历史上所有观测）,即当前的先验概率，实际上是历史的后验概率。<br>所以先验和后验是相对于某一时刻的。</p></div></p><h3 id="道理"><a href="#道理" class="headerlink" title="道理"></a>道理</h3><ul><li>观点要随着事实的改变而改变</li><li>证据比较少时候切莫盖棺定论</li><li>初始的先验概率可能并不重要</li><li>重要的是不断地调整自己认知</li></ul><h2 id="离线贝叶斯"><a href="#离线贝叶斯" class="headerlink" title="离线贝叶斯"></a>离线贝叶斯</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>每次到来一个新观测就利用贝叶斯公式全部重新计算一次。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><ul><li>在线贝叶斯是一种精益求精的策略，即最开始的时候不求结果的完美，只是先寻求一个结果，之后根据观测不断打磨结果。</li><li>离线贝叶斯是一种步步为营的策略，每一步都力求正确，最后得到一个正确结果</li></ul><div class="note green no-icon flat"><p>精益求精：数值解、敏捷模型（开发工作被组织为一系列短周期的快速迭代，通过客户反馈不断改进，达到完美）<br>步步为营：解析解、瀑布模型（将一个系统的开发分成多个阶段，每个阶段都有相应的管理和控制，最后拿出完美的成品）</p></div><h1 id="现实贝叶斯"><a href="#现实贝叶斯" class="headerlink" title="现实贝叶斯"></a>现实贝叶斯</h1><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><p>住在北京海淀区世纪城小区的一家五口人，父亲35岁，母亲30岁，小孩6岁刚上小学，小孩的姥姥姥爷帮忙照顾小孩，请问这家养狗的概率是多少</p><h2 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h2><p>已知的观测（证据）如下：</p><ol><li>A1:5口之家</li><li>A2：年龄</li><li>A3：姥姥姥爷帮忙照顾小孩</li><li>A4：海淀区世纪城小区</li></ol><p>养狗（H）的概率利用贝叶斯公式，计算如下：<br>$$P(HI{A_1},{A_2},{A_3},{A_4}) = P(H) \times { {P({A_1}IH) \times P({A_2}IH) \times P({A_3}IH) \times P({A_4}IH)} \over {P({A_1},{A_2},{A_3},{A_4})} }$$<br>现在的问题是，我们并不知道公式右边的概率。</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ol><li>把所有的观测分成两组，利用在线贝叶斯的思想，一组放在先验概率中，另外一组放在似然概率。</li><li>用统计数据直接找到先验概率，不计算，并且忽略似然概率</li></ol><p>更具体地一些说，现在有n个观测，A1…An,我们将其划分到两个集合A和B中，把A放在先验概率中，把B作为当前观测：<br>$$P({H_i}I{A_1},{A_2},{A_3},{A_4}) = P({H_i}IA) \times { {P(BI{H_i})} \over {P(BIA)} }$$<br>然后把似然概率忽略掉，直接认为先验概率为所求。<br><div class="note green no-icon flat"><p>其实是挺迷惑的，我感觉直接去掉部分观测，把其后验作为所求也是这个效果，可能是结合在线贝叶斯有说服力吧。</p></div></p><h2 id="分组原则"><a href="#分组原则" class="headerlink" title="分组原则"></a>分组原则</h2><ol><li>先验的统计数据容易拿到。</li><li>把信息量大的观测放到集合A里面。</li></ol><h2 id="两个观测的现实贝叶斯"><a href="#两个观测的现实贝叶斯" class="headerlink" title="两个观测的现实贝叶斯"></a>两个观测的现实贝叶斯</h2><p>两个观测的贝叶斯定理，我们需要选一个放入先验，选一个放入似然，选哪个？</p><h3 id="数学推导-1"><a href="#数学推导-1" class="headerlink" title="数学推导"></a>数学推导</h3><p><img src="公式推导2.jpg" alt="数学推导"><br>考虑我们的近似过程，我们显然希望<code>P(H|A1,A2) = P(H|A1)</code>尽可能成立，只有这样证明似然并没有扭转先验，即使我们进行了近似结果也不会相差很大。<br>考虑一下三种情况：</p><ol><li>先验概率P(H|A1)接近1，而且P(A2|~H)/P(A2|H)不会无穷大。</li></ol><p>即A1的解释力度很大，A2不排斥这个证据（观测），此时应该把A1放入先验，A2放入似然，此时后验概率接近1.</p><ol><li>先验概率P(H|A1)接近0，而且P(A2|~H)/P(A2|H)不会接近0</li></ol><p>即A1强烈反对某个观测。而A2并不排斥另外一个假设，此时应该把A1放入先验概率，把A2放入似然概率中，此时后验概率接近0</p><div class="note purple no-icon flat"><p>总结就是，某个观测具有旗帜鲜明的立场（强烈支持或者反对某个假设），另一个比较和稀泥，就应该把前者放入先验中。</p></div><ol><li>P(A2|~H)/P(A2|H)接近1，</li></ol><p>即A2这个观测不属于排他性证据，不能帮助我们更好的区别H和~H，信息量不大。应该放入似然概率中。</p><div class="note red no-icon flat"><p>总结就是，在能找到统计数据的前提下，应该尽量把信息量大的观测放入先验。</p></div><h2 id="多个观测的现实贝叶斯"><a href="#多个观测的现实贝叶斯" class="headerlink" title="多个观测的现实贝叶斯"></a>多个观测的现实贝叶斯</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><p>一个学生找工作，其基本情况如下：男，XX大学，硕士生，XXXX实验室。2017年毕业，有过少量硬件开发的经验和网页开发经验，掌握一些算法和信号处理知识，请问他找到好工作的概率是多少？</p><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>显然我们可以得到以下的观测：</p><ul><li><font color="red">A1：XX大学硕士</font></li><li><font color="red">A2：2017年毕业</font></li><li><font color="red">A3：XXXX实验室</font></li><li>A4：有过少量硬件开发的经验和网页开发经验</li><li>A5：掌握一些算法和信号处理知识</li><li>H：找到工作</li></ul><p>我们要求的便是P(H|A1,A2,A3,A4,A5),我们要将一些观测放入先验，其余丢入似然。显然A1,A2,A3的信息量比较大，所以将其放入先验，即我们最终求的是P(H|A1,A2,A3)<br>P（H|A1,A2,A3）：2017年毕业的XX大学XX实验室的硕士生找到好工作的概率。我们寻求它的统计数据</p><font color="red">但.....概率不好算，这个统计数据真的就好拿到吗？</font><p>显然不见得，样本数量太少了。且本身就很难拿到数据。显然我们又陷入了新的困境</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><h4 id="降低观测数量"><a href="#降低观测数量" class="headerlink" title="降低观测数量"></a>降低观测数量</h4><p>将P(H|A1,A2,A3)变为P(H|A1,A2)，这样拿到的样本的数量就会增多，我们就更容易拿到相关的数据统计。<br><div class="note red no-icon flat"><p>但今日割十城，明日割十城，先不说准确度的下降了，难道删除了这些元素我们就能拿到我们想要的数据统计吗？</p></div></p><h4 id="增大观测颗粒度"><a href="#增大观测颗粒度" class="headerlink" title="增大观测颗粒度"></a>增大观测颗粒度</h4><ul><li>XX大学XX实验室硕士生</li><li>XX大学硕士生</li><li>XX市985高校的硕士毕业生</li><li>全国985高校的硕士毕业生</li><li>全国一本的硕士毕业生</li><li>全国的硕士毕业生</li></ul><p>从上到下颗粒度逐渐上升，数据统计获取越来越容易。这体现了分层描述的思想。</p><h3 id="分层描述法"><a href="#分层描述法" class="headerlink" title="分层描述法"></a>分层描述法</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h4><p>围绕被观测的对象，在不同的颗粒度上将该对象的所有信息展现出来</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>明确对象：忘掉观测，明确这个问题中我们观测的对象是谁</li><li>描述对象：明确了这个对象之后，重新组织现有的观测，对该对象的特点进行由粗粒度到细粒度的多级描述。此外，在分层描述法中，信息量大的观测要尽量放在前面的层次上。</li><li>寻找统计：根据多级描述，找到颗粒度最细，并且能够从网上查到对应的统计数据的那个描述。把该描述对应的观测放入集合A中。</li></ol><h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><p>对于刚才的例子，我们重新整理所有的观测：</p><ul><li>这是一个2017年985高校的硕士毕业生</li><li>这是一个2017年XX学校的硕士毕业生</li><li>这是一个2017年XXX学校XXX实验室的硕士毕业生</li><li>这是一个2017年XXX学校XXX实验室的硕士毕业生，过少量硬件开发的经验和网页开发经验，掌握一些算法和信号处理知识。</li></ul><p>经过查找资料，我们最终找到了第二层的资料。将其放入先验，得到结论，他的就业率大概是95.80%</p><div class="note blue no-icon flat"><p>分层描述法帮助我们摆脱观测的桎梏，先定位对象，然后针对该对象将手头的观测按照由粗到精的层次重新组织，逐级描述该对象<br>它帮助我们选择观测，避免遗漏观测，简化工作量</p></div><hr><p>以上理论部分全部结束，下面是一些在别的领域的应用，仅供加深印象</p><h1 id="医学领域的贝叶斯"><a href="#医学领域的贝叶斯" class="headerlink" title="医学领域的贝叶斯"></a>医学领域的贝叶斯</h1><h2 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h2><ul><li>漏报：漏报被称为“假阴性”，这是由于他本身是阳性，但诊断却为阴性</li><li>误报：误报被称为“假阳性”，这是由于他本身是阴性，但诊断却为阳性</li><li>假阴性率：用此来衡量漏报的程度，用某种方法来检测100个已经被确诊的患者，如果有90个被检出，那假阴性率为10%。本质为在已经确诊的前提下，检测结果为阴性的条件概率。</li><li>真阳性率：用此来衡量漏报的程度，用某种方法来检测100个已经被确诊的患者，如果有90个被检出，那真阳性率为90%，本质为在已经确诊的前提下，检测结果为阳性的条件概率。</li><li>假阳性率：用此来衡量误报的程度，用某种方法来检测100个健康或者未患该病的人，如果有10个被检出，那假阳性率为10%，本质为在未患该病的前提下，检测结果为阳性的条件概率。</li><li>真阴性率：用此来衡量误报的程度，用某种方法来检测100个健康或者未患该病的人，如果有90个未被检出，那真阴性率为90%，本质为在未患该病的前提下，检测结果为阴性的条件概率。</li></ul><div class="note blue no-icon flat"><p>漏报的人真阳性，假阴性<br>误报的人假阳性，真阴性</p></div><h2 id="医生诊病"><a href="#医生诊病" class="headerlink" title="医生诊病"></a>医生诊病</h2><h3 id="正常做法"><a href="#正常做法" class="headerlink" title="正常做法"></a>正常做法</h3><p>列举所有可能的原因。<br>搜集所有可能的证据，计算每个原因的后验概率。<br><div class="note red no-icon flat"><p>但这样做是不合适的，因为原因（疾病）太多了，证据不可能搜集全</p></div></p><h3 id="医生做法"><a href="#医生做法" class="headerlink" title="医生做法"></a>医生做法</h3><ul><li>列出所有原因，按照可能性和成本综合排序</li><li>每次针对一个原因来搜集相关的证据，用来证实或者排除该原因。</li></ul><div class="note orange no-icon flat"><p>针对一个原因，用证据来上调下调其后验概率</p></div><p>调整其概率，自然其他的原因的后验概率也会随之改变，一举多得。</p><h3 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h3><ul><li>找排他性证据来大幅调整先验概率。</li><li>将多选一变为二选一，即将诸多原因分类为我要研究的那个原因和剩下的所有原因。</li></ul><h3 id="道理-1"><a href="#道理-1" class="headerlink" title="道理"></a>道理</h3><ul><li>将多选一变成二选一</li><li>收集那些能够帮助估计后验概率的信息</li><li>避免收集无效信息</li><li>证据的性价比和采集顺序，用漏报率低且成本低的方法快速筛掉大部分不符合要求的，在剩余的选项中采用更精确的方法来排除误报。</li><li>检查多不一定就是好医生，即使不考虑成本，如果某个病的基础概率低，而某种检测手段又会存在假阳性时，就很可能被误报。</li></ul><div class="note blue no-icon flat"><p>什么时候信息无效？</p><ul><li>A2自身不排他，P（A2|H）=P（A2|~H）</li><li>之前的信息包含了A2的信息</li><li>在A1出现的情况下，A2和H条件独立</li></ul></div><p>一道经典的题型：有一名病人，他可能患有两种疾病中的一个（H1和H2），现在观察到了A1，并且知道了H1的情况下症状A1发生的概率，即P(A1|H1)，我们接下来怎么做来更加确信他患的什么病？</p><ol><li>找H2发生的情况下A1发生的概率P（A1|H2）</li><li>找H1的另一个症状A2并找到概率P（A2|H1）</li><li>找H2的另一个症状A2的概率，即P（A2|H2）</li></ol><p>答案是1，因为1可以帮助我们对比H1和H2在这个症状上的解释力度。相比23更为合适。<br><div class="note blue no-icon flat"><p>此题易错选2，看似多找一个A2的证据可以加强说服力，但从始至终都没有考虑H2在这两个证据上的表现，不对比就没有信息，而且很可能这个信息也可以解释H2导致完全没有信息量。</p></div></p><h1 id="媒体领域的贝叶斯"><a href="#媒体领域的贝叶斯" class="headerlink" title="媒体领域的贝叶斯"></a>媒体领域的贝叶斯</h1><h2 id="震惊"><a href="#震惊" class="headerlink" title="震惊"></a>震惊</h2><p>对于让你感到震惊的消息，必然是扭转了你的先验概率，对于这种事物，必须加以小心，分析他的证据是否是排他性的。</p><h2 id="证据错误"><a href="#证据错误" class="headerlink" title="证据错误"></a>证据错误</h2><h3 id="证据不可信"><a href="#证据不可信" class="headerlink" title="证据不可信"></a>证据不可信</h3><p>证据的渠道不可信，导致证据不可信</p><h3 id="证据不量化"><a href="#证据不量化" class="headerlink" title="证据不量化"></a>证据不量化</h3><p>有句话说得好：抛开剂量谈毒性，都是耍流氓，给出证据时只说这样做有害，却不说到哪个程度有害。</p><h3 id="个例代统计"><a href="#个例代统计" class="headerlink" title="个例代统计"></a>个例代统计</h3><h4 id="有偏采样"><a href="#有偏采样" class="headerlink" title="有偏采样"></a>有偏采样</h4><h5 id="幸存者偏差"><a href="#幸存者偏差" class="headerlink" title="幸存者偏差"></a>幸存者偏差</h5><p>在采样的时候只考虑到幸存者而没能接触到更重要但无法幸存的样本，因而导致结论出现错误</p><h5 id="伯格森悖论"><a href="#伯格森悖论" class="headerlink" title="伯格森悖论"></a>伯格森悖论</h5><p>两个通常独立的事物会在特定场合下关联起来，由此产生的相关性容易带来认知上的偏差，导致两个本来无关的变量之间体现出貌似强烈的相关关系。</p><h2 id="使用贝叶斯需要注意"><a href="#使用贝叶斯需要注意" class="headerlink" title="使用贝叶斯需要注意"></a>使用贝叶斯需要注意</h2><ul><li>不要漏掉可能的原因</li><li>不要漏掉重要的观测</li><li>不要找错先验概率的条件</li><li>不要把熟悉的当作概率高的</li></ul><h2 id="被媒体扭曲的先验概率"><a href="#被媒体扭曲的先验概率" class="headerlink" title="被媒体扭曲的先验概率"></a>被媒体扭曲的先验概率</h2><ul><li>媒体反复报道小概率事件，让你觉得这事件发生概率不低</li><li>媒体恶意裁剪观测（证据），让你的先验发生改变。</li><li>信息茧房</li></ul><h2 id="阴谋论"><a href="#阴谋论" class="headerlink" title="阴谋论"></a>阴谋论</h2><p>几乎所有的事情都可以用阴谋论来解释，因此阴谋这个原因对一般事物的解释力度很高。</p><font color="red">但我们忽略了阴谋的先验概率</font>]]></content>
      
      
      <categories>
          
          <category> 北航信号处理与信息推断 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU扩展设计——分支预测</title>
      <link href="/posts/21201/"/>
      <url>/posts/21201/</url>
      
        <content type="html"><![CDATA[<h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>本文为笔者学习《超标量处理器设计》的一些理解，请学习时结合本书食用~<br><a href="https://pan.baidu.com/s/1_FuWMCAaTii7CPYI19BaFQ?pwd=lgdq">超标量处理器设计分享</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>考虑我们在计组设计中未曾考虑的问题：如果跳转指令成功跳转，选择默认不跳转的我们需要清空流水线前面的指令，这种清空被称为跳转惩罚。<br><div class="note green no-icon flat"><p>但由于我们的设计是五层流水线，跳转级在第二级，我们只需要引入延迟槽，便不需要清空流水线前面的指令，使得这个问题得到了解决。</p></div></p><p>但现代CPU设计具有以下的特点：</p><ul><li>流水线的深度往往较深，可以达到十几级，一次清空就要被浪费掉许多条指令。</li><li>流水线的设计采用超标量设计，一次取指取到大于等于两条指令。</li><li>处理器高并行。</li></ul><p>这样的特点导致了这种惩罚已经不是可以通过延迟槽避免的了，并且单次惩罚损失10+条指令。</p><p>并且在现代编程中，if,for,while这些语句的出现并不稀奇，所以这种频繁的惩罚是我们不能接受的，我们就需要对跳转进行尽力的预测，让CPU的实际运行尽力接近于我们的预测，这就引入了今天的设计——分支预测。</p><h1 id="预测内容"><a href="#预测内容" class="headerlink" title="预测内容"></a>预测内容</h1><h2 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h2><p>我们需要预测现在摆在我们面前的这条分支语句会不会发生跳转。</p><h2 id="目标地址"><a href="#目标地址" class="headerlink" title="目标地址"></a>目标地址</h2><p>我们需要预测现在摆在我们面前的这条分支语句如果真跳了，会跳到哪里？<br><div class="note pink no-icon flat"><p>这里可能有一个疑问，那就是跳到哪里这个难道不是固定的吗？我们会用一个式子直接算出来。确实，对于B类型的跳转是这样的<br>但J类型的跳转呢？比如<code>jr $ra</code>呢？假如现在用的$ra没被写回，或者还未产生怎么办？所以我们需要预测。<br>而且，一般情况下，我们并不通过计算来算B类型跳转，也是通过预测进行的。</p></div></p><h1 id="方向预测具体实现"><a href="#方向预测具体实现" class="headerlink" title="方向预测具体实现"></a>方向预测具体实现</h1><h2 id="基于两位饱和计数器的分支预测"><a href="#基于两位饱和计数器的分支预测" class="headerlink" title="基于两位饱和计数器的分支预测"></a>基于两位饱和计数器的分支预测</h2><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>最好写的分支预测，后续更强大的分支预测的基础。<br>对于简单程序预测率极高，捕捉冒泡排序、快速排序的分支效果欠佳。</p><div class="table-container"><table><thead><tr><th style="text-align:center">测试点</th><th style="text-align:center">预测率</th></tr></thead><tbody><tr><td style="text-align:center">stream_copy</td><td style="text-align:center">164/32612 = 99.5%</td></tr><tr><td style="text-align:center">bubble_sort</td><td style="text-align:center">216537/731271 = 70.3%</td></tr></tbody></table></div><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="一条指令"><a href="#一条指令" class="headerlink" title="一条指令"></a>一条指令</h4><p>在某种情况下，对于某一条特定的跳转指令，跳转方向是固定的。<br><div class="note green no-icon flat"><p>这里强调一下某一条特定的跳转指令，指的是同一PC值取出来的那一条跳转指令，下同。</p></div><br>比如：For循环的循环判断<br>我们因此可以用一定量过去的同一PC的该条指令真正执行的跳转方向来预测本次跳转的方向。<br>由于是二位的，所以我们利用过去两次执行情况来预测本次执行，我们先定义四个状态</p><ul><li>Strongly taken: 计数器饱和，在这种状态下预测本次发生跳转。</li><li>Weakly taken: 计数器不饱和，在这种状态下预测本次发生跳转。</li><li>Weakly not taken: 计数器不饱和，在这种状态下预测本次不发生跳转。</li><li>Strongly not taken: 计数器饱和，在这种状态下预测本次不发生跳转。</li></ul><div class="note purple no-icon flat"><p>饱和不饱和在笔者这里看来代表了一种本次预测的可信度：<br>如果是饱和的，那有很大概率预测是正确的。<br>如果是不饱和的，那有相比于饱和较低的概率预测是正确的。</p></div><p>使用方法很简单：</p><ul><li>对于每次预测的结果，我们用它来改变状态机的状态。</li><li>对于每次进行的预测，我们根据我们当前所处的状态给出预测。</li></ul><p>状态转移如下：<br><img src="两位饱和计数.png" alt="饱和计数"></p><p>例如现在我们处于Strongly not taken状态，并且这时候来了一条需要预测的指令，我们做出了不跳转的预测。<br>假如我们预测正确，状态不变，仍为Strongly not taken饱和。<br>假如我们预测失败，状态转移，变为Weakly not taken不饱和。</p><h4 id="完全实现"><a href="#完全实现" class="headerlink" title="完全实现"></a>完全实现</h4><h5 id="压缩大小"><a href="#压缩大小" class="headerlink" title="压缩大小"></a>压缩大小</h5><p>前面是对于某一条固定PC值对应的跳转指令的预测方式，但在实际中，我们会有很多pc值不同的跳转，我们都需要对其进行预测。</p><p>所以我们可以建立一个数组（在FPGA开发中是寄存器组），存放每一个跳转的两位饱和计数的状态。</p><p>每次预测和更新都从这个数组中取出状态进行更新，这样就完成了对于所有跳转的预测。</p><p>但是，由于板子资源有限，我们显然不能开2^32大小的数组，所以采用将 31位 PC 哈希为 12位 哈希值来减少碰撞。</p><p>为了节约资源，选用 IP 核而不是寄存器堆来存储这 <code>2^12 = 4096</code> 个饱和计数器的状态。</p><p>所以，分支预测需要两周期完成。</p><h5 id="内容携带"><a href="#内容携带" class="headerlink" title="内容携带"></a>内容携带</h5><p>更新时需要两个内容，原始饱和计数器的值和是否跳转。</p><p>如果原始饱和计数器的值仍然要从IP核取出，就会导致更新多一周期，为了避免这种情况，在预测时就会将原始饱和计数器的值流水。让 CPU 在更新时将这个值传递回来。</p><h4 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h4><p><img src="饱和计数器设计思路.png" alt="饱和计数器设计思路"></p><h2 id="局部历史分支预测"><a href="#局部历史分支预测" class="headerlink" title="局部历史分支预测"></a>局部历史分支预测</h2><h3 id="定位-1"><a href="#定位-1" class="headerlink" title="定位"></a>定位</h3><p>某些位置的分支是有历史性规律的，比如固定循环次数的 for 循环。根据该指令过去的跳转情况来预测下一次是否跳转称为局部历史分支预测。</p><p>由于使用到了饱和计数器，它可以被视为是饱和计数器分支预测的升级版本。</p><p>对于简单的程序，由于它的训练时间较长等因素，预测率略微低于饱和计数器分支预测</p><p>对于冒泡排序、快速排序则比饱和计数器分支预测更加优秀。</p><div class="table-container"><table><thead><tr><th style="text-align:center">测试点</th><th style="text-align:center">预测率</th></tr></thead><tbody><tr><td style="text-align:center">stream_copy</td><td style="text-align:center">307/32624 = 99.1%</td></tr><tr><td style="text-align:center">bubble_sort</td><td style="text-align:center">136310/730336 = 81.3%</td></tr></tbody></table></div><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>根据某一指令过去的 3 次执行情况来捕捉规律，这 3 次执行的可能如下：TTT,TTN,TNT,NTT,TNN,NNT,NTN,NNN. 对每个情况都建立一个饱和计数器，捕捉在每种情况上该指令的跳转情况。</p><p>即给出 PC 值，取出该 PC 值的执行情况，由执行情况和 PC 寻址到相应的饱和计数器，用该饱和计数器给出预测。</p><p><img src="BHR示意.png" alt="BHR示意"></p><p>图为针对某一条分支的局部历史预测取值示意</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="PHT-压缩"><a href="#PHT-压缩" class="headerlink" title="PHT 压缩"></a>PHT 压缩</h4><p>（PHT 是指存储所有饱和计数器状态的那个 IP核）</p><p>如果根据某一指令过去的三次执行情况来捕捉规律，一个分支指令就需要 8 个饱和计数器，相比于饱和计数器分支预测方法，PHT 的占用面积是 8 倍。<br>这显然不太能被接受，所以我们需要压缩 PHT. 尽管可能会带来冲突(多个分支共享一个饱和计数器)。</p><p>我采用这种方式进行压缩：在我的实现中，PHT 仍然有 4096 项，深度是12位，所以我用3位执行情况拼接9位PC完成12位寻址<br><img src="BHR的PHT压缩.png" alt="BHR的PHT压缩"></p><h4 id="BHR-引入"><a href="#BHR-引入" class="headerlink" title="BHR 引入"></a>BHR 引入</h4><p>我们需要记录每一个分支指令的历史 3 次执行情况，这也需要一个表格来记录，因此需要引入新的 IP 核统一存储这个信息。称其为 BHR。</p><p>BHR 大小我设置为 4096项，仍然采用和上述饱和计数器预测相同的哈希函数将 PC 哈希后寻址。</p><font color = "red">BHR 采用 IP 核的 Distribute Ram 实现，综合消耗 LutRam，这是为了保证分支预测仍然两周期完成。否则就是三周期。</font> <p><img src="BHR预测逻辑.png" alt="BHR预测逻辑.png"></p><h4 id="总体流程-1"><a href="#总体流程-1" class="headerlink" title="总体流程"></a>总体流程</h4><p><img src="BHR总体逻辑.png" alt="BHR总体逻辑"></p><h2 id="全局历史分支预测"><a href="#全局历史分支预测" class="headerlink" title="全局历史分支预测"></a>全局历史分支预测</h2><h3 id="定位-2"><a href="#定位-2" class="headerlink" title="定位"></a>定位</h3><p>某些位置的分支是有历史性规律的，比如 <code>if..else if...else</code>。 根据前述 <code>if</code> 对应的跳转指令预测后面的 <code>else if..else</code> 是否跳转被称为全局历史预测。</p><p>由于使用到了饱和计数器，它可以被视为是饱和计数器分支预测的升级版本。</p><p>对于简单的程序，由于它的训练时间较长、全局规律不明显等因素，预测率略低于前述两种方法。</p><p>对于冒泡排序、快速排序则比前述两种方法显著优秀。</p><div class="table-container"><table><thead><tr><th style="text-align:center">测试点</th><th style="text-align:center">预测率</th></tr></thead><tbody><tr><td style="text-align:center">stream_copy</td><td style="text-align:center">351/32624 = 98.9%</td></tr><tr><td style="text-align:center">bubble_sort</td><td style="text-align:center">67440/730336 = 90.8%</td></tr></tbody></table></div><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>根据过去最近 6 条分支指令的执行情况来预测当前分支是否跳转，和局部历史类似，对于每一个情况建立一个饱和计数器，捕捉在每个情况上将要被预测的分支指令的跳转规律。</p><p>即给出 PC 值，取出该 PC 值的执行情况，由执行情况和 PC 寻址到相应的饱和计数器，用该饱和计数器给出预测。</p><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="GHR"><a href="#GHR" class="headerlink" title="GHR"></a>GHR</h4><p>由于我们记录的是全局分支执行情况，所以区别于 BHR 的 IP 核实现，我们只需要利用一个寄存器即可记录执行信息。</p><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>GHR 的更新是我写分支目前为止遇到的最复杂，最让人不适的更新，有几个问题：</p><ol><li>GHR 的内容如何更新 ？ 如果仅仅是在分支更新信息返回时更新，那么在预测发出到更新返回这一段时间内，往往也会有分支指令，这些分支指令的预测理应是在了解前述分支执行情况上进行的预测，如果在分支信息更新信息返回时更新，显然不能满足这个条件。</li><li>GHR 不能完全正确 这是因为在前期分支指令还处于部分被识别，部分没有被识别的情况下，GHR 也不能满足反映最近 6 次分支指令执行情况，准确的说只能满足最近已识别 6 次分支指令执行情况。</li></ol><p>问题一的解决是通过用预测是否跳转来更新 GHR， 在更新信息返回时再进行纠正。</p><p>问题二难以解决，且不会影响长期正确性，最多加长训练时间，所以暂时不做处理。</p><font color = "red">GHR 这里的复杂逻辑目前我已经尽力完善，但可能还有潜在问题，用时间来慢慢思考吧。</font> <h4 id="总体流程-2"><a href="#总体流程-2" class="headerlink" title="总体流程"></a>总体流程</h4><p><img src="GHR总体逻辑.png" alt="GHR总体逻辑.png"></p><h2 id="竞争式分支预测"><a href="#竞争式分支预测" class="headerlink" title="竞争式分支预测"></a>竞争式分支预测</h2><h3 id="定位-3"><a href="#定位-3" class="headerlink" title="定位"></a>定位</h3><p>分支预测集大成者，集成局部历史与全局历史，根据预测准确性自动选择预测方法。</p><font color = "red">对于简单和复杂的程序，预测率都处于前述方法的中上游水平，属于是稳而不尖的分支预测，当然可能是我的实现问题，我个人感觉它不该只是这个水平。</font> <div class="table-container"><table><thead><tr><th style="text-align:center">测试点</th><th style="text-align:center">预测率</th></tr></thead><tbody><tr><td style="text-align:center">stream_copy</td><td style="text-align:center">99.2%</td></tr><tr><td style="text-align:center">bubble_sort</td><td style="text-align:center">87.0 %</td></tr></tbody></table></div><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>引入新的饱和计数器来记录两种方法对某一分支指令的预测情况，利用此饱和计数器选择预测率较高的方法来预测该分支指令。</p><h3 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="GHR-更新的变化"><a href="#GHR-更新的变化" class="headerlink" title="GHR 更新的变化"></a>GHR 更新的变化</h4><p>引入竞争后，GHR 的更新逻辑变得更加复杂，具体变为了四种情况：</p><ol><li>使用了 BHR 的预测信息，且 BHR 与 GHR 预测都正确，不需要更新</li><li>使用了 BHR 的预测信息，且 BHR 预测正确， GHR 预测错误，更新时仅仅需要修改 GHR 某一位。</li><li>使用了 BHR 的预测信息，且 BHR 预测错误， GHR 预测错误，更新和全局历史预测一致。</li><li>使用了 BHR 的预测信息，且 BHR 预测错误， GHR 预测正确，更新时不能直接利用流水传递的 Recover_GHR 来更新。</li></ol><h4 id="CPHT-的引入"><a href="#CPHT-的引入" class="headerlink" title="CPHT 的引入"></a>CPHT 的引入</h4><p>CPHT 的本质和 PHT 相同，都是饱和计数器的状态，只不过 CPHT 中饱和计数器的状态是为了选择方法。</p><p><img src="CMP 预测逻辑.png" alt="CMP预测逻辑"></p><h4 id="总体流程-3"><a href="#总体流程-3" class="headerlink" title="总体流程"></a>总体流程</h4><p><img src="CMP总体逻辑.png" alt="CMP总体逻辑.png"></p><h1 id="地址预测具体实现"><a href="#地址预测具体实现" class="headerlink" title="地址预测具体实现"></a>地址预测具体实现</h1><h2 id="跳转指令分类"><a href="#跳转指令分类" class="headerlink" title="跳转指令分类"></a>跳转指令分类</h2><ul><li>Branch: b 开头的指令，例如 <code>beq</code>，这类指令只有两个固定的目标地址，跳转为一个，不跳转为一个，但不跳转可以通过当前 PC 直接计算得出，所以只需要用表格记录跳转的目标地址即可。</li><li>Jump: j 开头的部分指令，例如 <code>j</code>，这类指令只有一个固定的目标地址，所以只需要用表格记录跳转的目标地址即可。</li><li>Call: 用来进入函数的跳转指令，例如<code>jal</code>，这类指令只有一个固定的目标地址，所以只需要用表格记录跳转的目标地址即可。</li><li>Return: 用来返回函数的跳转指令，例如<code>jr</code>，这类指令会根据 Call 的地址变化而变化，设计较为特殊，用栈来维护目标地址。</li></ul><h2 id="具体实现-3"><a href="#具体实现-3" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="记录模组"><a href="#记录模组" class="headerlink" title="记录模组"></a>记录模组</h3><h4 id="表项"><a href="#表项" class="headerlink" title="表项"></a>表项</h4><p>采用 IP核 记录目前为止遇到的所有的分支指令的 PC 值，类型，Branch、Jump、Call的跳转的目标地址。<br>即 IP 核表项为：</p><div class="table-container"><table><thead><tr><th style="text-align:center">校验码</th><th style="text-align:center">跳转类型</th><th style="text-align:center">目标地址</th></tr></thead><tbody><tr><td style="text-align:center">9位</td><td style="text-align:center">3位</td><td style="text-align:center">32位</td></tr></tbody></table></div><div class="note green no-icon flat"><p>校验码是将要存在该处的跳转指令的 PC 进行异或处理后的 9 位数字，是为了在预测时结合 PC 确认此处所存内容是否对应。<br>由于这里存的都是跳转后的目标地址，所以如果错误的根据不对应的目标地址给出预测，会必定导致预测失败而清空流水线，所以需要进行校验。</p></div><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><p>二路组相联，一路 2048 个表项，两路一共 4096 个表项。</p><p><img src="BTB.png" alt="BTB"></p><h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a>更新</h4><p>对于两路中相同地址的内容，采用 LRU 算法进行更新。</p><div class="note orange no-icon flat"><p>目前由于表项开的足够大，第二路从来没有被使用过，所以冲突也从来没有发生过。<br>未来会缩小面积。</p></div><h3 id="RAS-栈"><a href="#RAS-栈" class="headerlink" title="RAS 栈"></a>RAS 栈</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>Return 返回虽然不能通过表格记录的方式进行预测，但也是有迹可循的。需要结合 Call 来捕捉规律。</p><p>根据函数的规格，一个 Call 必定有一个 Return. 且 Return 的返回地址是 调用它的 Call 所在的 PC + 8。</p><p>考虑层层调用的函数，每次 Return 都是返回到最近的 Call 的 PC + 8. 所以我们可用栈来维护这些 PC.</p><div class="note orange no-icon flat"><p>其实很简单,函数的层层调用不都是不断压栈吗,那 RAS 也是栈实现就行。</p></div><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>每次 Call 就将 PC + 8 压栈，每次 Return 就将顶部 PC 弹出。</p><p><img src="RAS.png" alt="RAS"></p><h3 id="总体流程-4"><a href="#总体流程-4" class="headerlink" title="总体流程"></a>总体流程</h3><p><img src="BTB逻辑.png" alt="BTB总体逻辑"></p>]]></content>
      
      
      <categories>
          
          <category> 龙芯 NSCSCC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分支预测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix 记忆留存 （三）</title>
      <link href="/posts/50087/"/>
      <url>/posts/50087/</url>
      
        <content type="html"><![CDATA[<p>这是该系列第三篇，也是最后一篇</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客是笔者在学习Unix课程时所积累的学习笔记。<br>希望对后来学习Unix的友友复习准备Unix的期末考试有帮助。</p><h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>基本文件I/O函数：open、creat、read、write、lseek、close<br>术语：不带缓冲的I/O（指每一个read、write都调用内核中的一个系统调用），低级例程。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>一个非负的整数，一个结构数组的下标，进程打开的文件表项的下标。<br>open、creat函数会返回一个文件描述符<br><img src="文件结构.png" alt="文件结构"><br><div class="note purple no-icon flat"><p>文件描述符0、1、2默认打开，分别对应于标准输入（键盘）、标准输出（显示器）、标准错误输出（显示器）文件。在unistd.h中定义为STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO</p></div></p><h3 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h3><h4 id="open"><a href="#open" class="headerlink" title="open"></a>open</h4><p><code>#include &lt;fcntl.h&gt;</code><br><code>int open(const char *pathname, int oflag, [mode_t mode])</code><br>返回值：若成功，返回非负整数，即文件描述符。一定是当前“进程文件描述符表”中最小未使用的描述符。出错返回-1。<br>pathname:常量，文件名，绝对路径或相对路径均可。<br>oflag:打开方式选项。O_RDONLY、O_WRONLY、O_RDWR三者必须选其一。O_CREAT、O_APPEND、O_TRUNC等任意选择。多个选项进行“或”运算构成oflag选项。<br>mode:仅当oflag具有O_CREAT选项时，需要此参数，用于指定新建文件的访问权限。</p><h4 id="creat"><a href="#creat" class="headerlink" title="creat"></a>creat</h4><p><code>#include &lt;fcntl.h&gt;</code><br><code>int creat(const char *pathname, mode_t mode)</code><br>返回值：若成功，返回非负整数，即文件描述符。出错返回-1<br>pathname:常量，文件名，绝对路径或相对路径均可。<br>mode:指定新建文件的访问权限。<br><div class="note green no-icon flat"><p>若原有文件存在，则原有文件的属性和内容将会被覆盖。</p></div><br>等价于:<br><code>open(pathname, O_WRONLY|O_CREAT|O_TRUNC, mode)</code><br>语义上creat简单，涉及原子操作，应当使用open。</p><h4 id="close"><a href="#close" class="headerlink" title="close"></a>close</h4><p><code>#include &lt;unistd.h&gt;</code><br><code>int close(int filedes)</code><br>返回值:若成功，返回0，出错返回-1<br>filedes:文件描述符<br><div class="note pink no-icon flat"><p>进程终止时，内核自动关闭其打开的所有文件</p></div></p><h4 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h4><p><strong>作用</strong>：移动文件“读写指针”（或称“文件偏移量”）。读写操作会自动移动文件读写指针。<br><code>#include &lt;unistd.h&gt;</code><br><code>off_t lseek(int filedes, off_t offset, int whence)</code><br><strong>off_t</strong>:  与系统有关，通常是长整型<br><strong>filedes</strong>: 文件描述符<br><strong>whence</strong>:  移动偏移量的方式。0：绝对方式；1：相对方式；2：相对文件尾部<br><strong>offset</strong>:   移动的距离，非绝对方式移动时，可以为负。<br><strong>返回值</strong>:  新的文件偏移量。</p><h4 id="read"><a href="#read" class="headerlink" title="read"></a>read</h4><p><strong>作用</strong>：从已打开的文件中读取数据，自动移动文件读写指针。<br><code>#include &lt;unistd.h&gt;</code><br><code>ssize_t  read(int filedes, void *buff, size_t nbytes)</code><br><strong>ssize_t</strong>：  通常是整型，size_t通常是无符号整型。<br><strong>filedes</strong>： 文件描述符<br><strong>buff</strong>：  存放数据的缓冲区<br><strong>nbytes</strong>：  需要读取的字节数<br><strong>返回值</strong>：实际读取的字节数。正常读取时，返回值等于nbytes;遇到文件结束时，小于nbytes；出错返回-1</p><h4 id="write"><a href="#write" class="headerlink" title="write"></a>write</h4><p><strong>作用</strong>：将数据写入已打开的文件，自动移动文件读写指针。<br><code>#include &lt;unistd.h&gt;</code><br><code>ssize_t  write(int filedes, void *buff, size_t nbytes)</code><br><strong>ssize_t</strong>:  通常是整型，size_t通常是无符号整型。<br><strong>filedes</strong>: 文件描述符<br><strong>buff</strong>:  存放数据的缓冲区<br><strong>nbytes</strong>:  需要写入的字节数<br><strong>返回值</strong>：实际写入的字节数。正常写入时，返回值等于nbytes;磁盘空间满时，小于nbytes（这种情况也可以认为是出错）；出错返回-1</p><h4 id="dup2"><a href="#dup2" class="headerlink" title="dup2"></a>dup2</h4><p><code>#include &lt;unistd.h&gt;</code><br><code>int  dup2(int filedes1, int filedes2)</code><br><strong>作用</strong>：将文件描述符filedes1的表项复制给filedes2的表项。如果filedes2已经打开，则先将其关闭。<br><strong>返回值</strong>：正常返回filedes2，出错返回-1</p><h4 id="link"><a href="#link" class="headerlink" title="link"></a>link</h4><p><code># include &lt;unistd.h&gt;</code><br><code>int link(const char *existingpath, const char *newpath)</code><br><strong>作用</strong>：  创建一个新的目录项newpath，指向一个现有的文件existingpath。</p><h4 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h4><p><code>int unlink(const char *pathname)</code><br><strong>作用</strong>：删除一个目录项，对应文件的链接数减1。</p><h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p><code>#include &lt;stdio.h&gt;</code><br><code>int remove(const char *pathname)</code><br><strong>作用</strong>：删除一个文件或目录的链接。</p><h4 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h4><p><code>#include &lt;stdio.h&gt;</code><br><code>rename(const char *oldname, const char *newname)</code><br><strong>作用</strong>：文件或目录更名。</p><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p><code># include &lt;sys/stat.h&gt;</code><br><code>int mkdir(const char *pathname, mode_t mode)</code><br><strong>作用</strong>：创建一个目录。</p><h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><p><code># include &lt;unistd.h&gt;</code><br><code>int rmdir(const char *pathname)</code><br><strong>作用</strong>：删除一个<em>空</em>目录。</p><h4 id="目录文件读函数"><a href="#目录文件读函数" class="headerlink" title="目录文件读函数"></a>目录文件读函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line">DIR*            <span class="title function_">opendir</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span> <span class="comment">//打开目录</span></span><br><span class="line"><span class="keyword">struct</span> dirent*  <span class="title function_">readdir</span><span class="params">(DIR *dp)</span>              <span class="comment">//读取目录</span></span><br><span class="line"><span class="type">int</span>             <span class="title function_">closedir</span><span class="params">(DIR *dp)</span>             <span class="comment">//关闭目录</span></span><br><span class="line"><span class="type">void</span>            <span class="title function_">seekdir</span><span class="params">(DIR *dp, <span class="type">long</span> loc)</span>    <span class="comment">//寻找目录</span></span><br></pre></td></tr></table></figure><div class="note orange no-icon flat"><p>只有内核才可以写。</p></div><h4 id="位置函数"><a href="#位置函数" class="headerlink" title="位置函数"></a>位置函数</h4><p>改变进程的当前工作目录 //cd命令<br><code># include &lt;unistd.h&gt;</code><br><code>int chdir(const char *pathname)</code><br><code>int fchdir(int filedes)</code><br>获取当前工作目录  //pwd命令<br><code>#include &lt;unistd.h&gt;</code><br><code>char *getcwd(char *buff, size_t size)</code></p><h4 id="文件组织架构"><a href="#文件组织架构" class="headerlink" title="文件组织架构"></a>文件组织架构</h4><ul><li>一般UNIX文件组织架构如下：</li></ul><p><img src="内核数据结构.png" alt="内核数据结构"><br>fd就是前面一直提到的文件描述符。</p><ul><li>不同进程打开相同文件的情况：</li></ul><p><img src="相同文件.png" alt="相同文件"><br>其实也很好理解，首先由于fd要互斥，所以fd一定不同。<br>且重复打开某个文件，肯定要求读写指针不能相同，否则就会互相影响。<br>但文件是同一个文件，所以连到同一个V节点。</p><ul><li>fork之后的情况</li></ul><p><img src="fork.png" alt="fork"><br>这个也很好理解，fork就相当于复制了一份原进程，自然保持一模一样。</p><ul><li>重定向</li></ul><p><img src="重定向.png" alt="重定向"><br>dup2(3,0)   将进程文件表中的表项3复制给表项0 ——标准输入重定向<br>dup2(3,1)   将进程文件表中的表项3复制给表项1 ——标准输出重定向<br><div class="note green no-icon flat"><p>现在大概了解重定向的实现原理了吧~</p></div></p><h2 id="文件属性和目录"><a href="#文件属性和目录" class="headerlink" title="文件属性和目录"></a>文件属性和目录</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  mode <span class="type">_t</span>       st_mode;      <span class="comment">//文件类型和权限</span></span><br><span class="line">  <span class="type">ino_t</span>         st_ino;       <span class="comment">//i节点号</span></span><br><span class="line">  <span class="type">dev_t</span>         st_dev;       <span class="comment">//文件系统设备号（磁盘和分区）</span></span><br><span class="line">  <span class="type">dev_t</span>         st_rdev;      <span class="comment">//设备文件的设备号</span></span><br><span class="line">  <span class="type">nlink_t</span>       st_nlink;     <span class="comment">//链接数</span></span><br><span class="line">  <span class="type">uid_t</span>         st_uid;       <span class="comment">//文件所有者的用户ID</span></span><br><span class="line">  <span class="type">gid_t</span>         st_gid;       <span class="comment">//文件所有者的组ID</span></span><br><span class="line">  <span class="type">off_t</span>         st_size;      <span class="comment">//文件长度（字节数），普通文件</span></span><br><span class="line">  <span class="type">time_t</span>        st_atime;     <span class="comment">//最后一次访问的时间</span></span><br><span class="line">  <span class="type">time_t</span>        st_mtime;     <span class="comment">//最后一次修改文件内容的时间</span></span><br><span class="line">  <span class="type">time_t</span>        st_ctime;     <span class="comment">//最后一次修改文件属性的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配套函数"><a href="#配套函数" class="headerlink" title="配套函数"></a>配套函数</h3><p><code>int stat(const char *pathname, struct stat *buf)</code><br>作用：获取文件信息。<br><code>int fstat(int filedes, struct stat *buf)</code><br>作用：由文件描述符取得文件的状态。<br><div class="note green no-icon flat"><p>两者返回的结果都是stat结构体，只是使用场景不同。</p></div></p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>普通文件、目录文件、字符设备文件、块设备文件、 FIFO、符号链接、套接字</p><h3 id="判断文件类型"><a href="#判断文件类型" class="headerlink" title="判断文件类型"></a>判断文件类型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S_ISREG(<span class="type">mode_t</span> mode)   <span class="comment">//是否普通文件</span></span><br><span class="line">S_ISDIR(<span class="type">mode_t</span> mode)   <span class="comment">//是否目录文件</span></span><br><span class="line">S_ISCHR(<span class="type">mode_t</span> mode)   <span class="comment">//是否字符设备文件</span></span><br><span class="line">S_ISBLK(<span class="type">mode_t</span> mode)   <span class="comment">//是否块设备文件</span></span><br><span class="line">S_ISFIFO(<span class="type">mode_t</span> mode)  <span class="comment">//是否管道文件</span></span><br><span class="line">S_ISLNK(<span class="type">mode_t</span> mode)   <span class="comment">//是否符号链接</span></span><br><span class="line">S_SOCK(<span class="type">mode_t</span> mode)    <span class="comment">//是否套接字</span></span><br></pre></td></tr></table></figure><h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3><ul><li>9个普通权限位<br>S_IRUSER, S_IWUSER, S_IXUSER  //用户权限位<br>S_IRGRP,   S_IWGRP,   S_IXGRP   //用户组权限位<br>S_IROTH,   S_IWOTH,  S_IXOTH   //其他用户权限位</li><li>3个特殊权限位（针对可执行文件）<br>S_ISUID  执行时设置有效用户ID，如passwd命令文件<br>S_ISGID  执行时设置有效用户组ID<br>S_SVTX   第一次执行时，保存正文，即常驻内存。</li></ul><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>新文件的用户ID、组ID等于创建进程的有效用户ID和组ID<br>新文件的权限由指定权限和屏蔽字共同决定。</p><ul><li>指定权限，open和creat函数中给出的权限。</li><li>屏蔽字（umask值），被umask屏蔽的权限位即使在open或creat中指定了也会被屏蔽掉。</li><li><code>#include  &lt;sys/stat.h&gt;</code></li><li><code>mode_t umask(mode_t mode)</code></li><li>umask函数设置当前屏蔽字，返回以前的屏蔽字。</li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="获取进程"><a href="#获取进程" class="headerlink" title="获取进程"></a>获取进程</h3><p><code>#include &lt;unistd.h&gt;</code><br><code>pid_t getpid(void)</code>   获取调用者的进程ID<br><code>pid_t getppid(void)</code>  获取调用者的父进程ID。</p><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p><code>#include &lt;unistd.h&gt;</code><br><code>pid_t fork(void)</code><br>功能：创建一个新的进程，新进程是旧进程的副本。旧进程叫父进程，新进程叫子进程。<br>返回值：fork函数调用一次，返回两次。在父进程中返回子进程的ID，在子进程中返回0，出错返回-1<br>目的：并行，运行新程序。</p><h3 id="运行新程序"><a href="#运行新程序" class="headerlink" title="运行新程序"></a>运行新程序</h3><p>父进程fork一个子进程后，子进程往往需要调用一个exec函数来运行一个新程序。<br>否则，这个fork我个人认为是没意义的。<br>exec函数用一个新程序替换调用进程原有的代码、数据、堆栈等，新程序从头开始执行。exec不产生新的进程，所有调用前后的进程号不发生变化。<br>exec函数有很多，并不指具体一个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0,…,(<span class="type">char</span> *)<span class="number">0</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg0,…,(<span class="type">char</span> *)<span class="number">0</span>, <span class="type">char</span> *<span class="type">const</span> envp[])</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *arg0,…,(<span class="type">char</span> *)<span class="number">0</span>)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(cons <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[])</span></span><br></pre></td></tr></table></figure><br>1) execl和execlp比较直观，类似命令行输入，推荐使用。<br>2）execve是系统调用，其他是库函数。<br>3）返回值：正常不返回，出错返回-1</p><h3 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h3><p>通过wait函数实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span>   <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statloc)</span></span><br><span class="line"><span class="type">pid_t</span>   <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statloc, <span class="type">int</span> options)</span></span><br><span class="line">waitid、wait3、wait4等</span><br></pre></td></tr></table></figure></p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul><li>全称：IPC（Interprocess Communication）</li><li>包括：半双工管道、半双工命名管道（FIFO）、全双工管道、全双工命名管道、消息队列、信号量、共享存储、套接字、STREAMS<div class="note green no-icon flat"><p>Linux支持以上全部，其他UNIX一般只支持一部分。</p></div></li><li>使用习惯：<br>套接字可支持不同主机的进程间通信（网络通信），其他为主机内通信。<br>主机内通信常用半双工管道，网络通信常用套接字。</li></ul><h4 id="半双工管道"><a href="#半双工管道" class="headerlink" title="半双工管道"></a>半双工管道</h4><p>是所有UNIX系统都提供的一种通信方式。<br>特点：<br>1）半双工的工作方式。通信方向是双向的，但只能选择其中一种。<br>2）只能在具有公共祖先的进程之间使用。通常是父子进程之间。<br>创建：<br><code>#include &lt;unistd.h&gt;</code><br><code>int pipe(int filedes[2])</code><br>创建一个管道，若成功返回0，不成功返回-1；<br>由参数filesdes返回两个文件描述符: filedes[0]、filesdes[1]， filedes[0]为读而打开， filedes[1]为写而打开。<br><img src="半双工管道.png" alt="半双工管道"><br>创建管道之后的情形如上图所示。将数据写入fd[1]，从fd[0]中读出。<br>管道在单个进程中没有意义，通常在pipe函数之后，立刻会调用fork，产生一个子进程，情形如下图所示：<br><img src="父子管道.png" alt="父子管道"><br>fork之后，选择通信方向:<br>如果父进程写、子进程读，则父进程close fd[0]，子进程close fd[1]；<br>反之，子进程关闭fd[0]，父进程关闭fd[1]。<br>规则：<br>1）写端关闭时，read函数返回0，表示文件结束；<br>2）读端关闭时，write函数返回-1，并且出现SIGPIPE异常（信号）。<br>常量PIPE_BUF规定了内核管道缓冲区大小，每次write的字节数需小于PIPE_BUF<br>举例：（父进程写，子进程读）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> fd[<span class="number">2</span>]; <span class="type">char</span> line[MAXLINE];</span><br><span class="line">pipe(fd);</span><br><span class="line"><span class="keyword">if</span> (pid=fork() &gt;<span class="number">0</span>)&#123;   <span class="comment">//父进程</span></span><br><span class="line">    close(fd[<span class="number">0</span>]);</span><br><span class="line">    write(fd[<span class="number">1</span>],<span class="string">&quot;hello world!\n&quot;</span>, <span class="number">12</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pid==<span class="number">0</span>)｛    <span class="comment">//子进程</span></span><br><span class="line">    close(fd[<span class="number">1</span>]);</span><br><span class="line">    read(fd[<span class="number">0</span>], line, MAXLINE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h4><p>命名管道是一种文件<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkfifo f1  <span class="comment">//建立管道</span></span><br><span class="line">$ ls -l  f1  <span class="comment">//可以看到f1的权限什么的，确实说明是一个文件</span></span><br><span class="line">$ cat &lt; f1   <span class="comment">//将f1中的内容打印</span></span><br><span class="line">$ ls -l &gt; f1 <span class="comment">//输出目录到f1中</span></span><br></pre></td></tr></table></figure><br>函数：<br><code>#include &lt;sys/stat.h&gt;</code><br><code>int mkfifo(const char *pathname, mode_t mode)</code></p><h3 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h3><p>无论进程如何结束，都会执行内核中的一段代码：关闭所有打开文件，释放占用的内存。<br>进程结束时，内核会保存其终止状态，直到该进程的父进程取走其状态。<br><div class="note orange no-icon flat"><p>父进程结束，其子进程成为孤儿进程，由进程1（init进程）领养。<br>子进程先于父进程结束，如果父进程未取走其状态，则该进程仍然占有一定的内核资源，成为“僵死进程”。<br>由于僵死进程占用资源，因此当一个长期运行的服务类程序调用fork后，应处理僵死进程。</p></div></p><h4 id="正常结束"><a href="#正常结束" class="headerlink" title="正常结束"></a>正常结束</h4><ul><li>main函数执行完</li><li>main函数中执行return</li><li>任意位置执行exit、_exit、_Exit<h4 id="异常结束"><a href="#异常结束" class="headerlink" title="异常结束"></a>异常结束</h4>收到某个信号而结束<div class="note green no-icon flat"><p>比如kill命令中的-9.</p></div></li></ul><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>fork之后，所有父进程打开的文件描述符都被复制到子进程中。父子进程相同的文件描述符指向相同的内核文件表，具有相同的文件偏移量。如果父子进程同时操作相同的文件，则需要同步机制，否则会产生混乱。</p><p>一般情况下，应该尽量回避父子进程同时操作相同文件的情况。1）父进程等待子进程结束后再运行；2）父子进程运行不同的程序段，使用不同的文件。</p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>信号是一种异步事件，通常是非正常情况，如：人为终止进程、除数为0、非法内存访问等。所谓“异步”，指信号的出现是随机的。</p><h3 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h3><ul><li>人为按下中断键 Ctrl_C</li><li>用户使用kill命令</li><li>进程调用kill函数</li><li>程序运行错误，除数为0、非法内存访问</li><li>软件产生的信号：闹钟超时、写一个读端已关闭的管道、网络传来带外数据。——这些基本是可以预见的信号。<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3>系统默认处理或忽略。<br>捕捉信号  通知内核在某种信号发生时调用一个用户函数。<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h4><code>#inclucde &lt;signal.h&gt;</code><br><code>void  (*singnal(int signo, void (*func)(int)))(int)</code><br>这个函数比较抽象，需要好好理解：<br><code>void (*func)(int)</code>一个函数指针，所指向的函数需要一个整型参数，无返回值。<br><code>singnal(int signo, void (*func)(int))</code>, signal函数有两个参数，一个整型，一个函数指针。<br><code>void (*signal(…))(int)</code>  signal的返回值也是一个函数指针，所指向的函数需要一个整型参数，无返回值。<div class="note green no-icon flat"><p>这个和OO电梯多线程里面的signal没啥关系，不要魔怔（其实是我魔怔），这个是用来捕捉信号的~</p></div><h5 id="捕捉实例："><a href="#捕捉实例：" class="headerlink" title="捕捉实例："></a>捕捉实例：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">signal(SIGINT, my_sig);</span><br><span class="line">signal(SIGALRM, my_sig);</span><br><span class="line"><span class="type">void</span> <span class="title function_">my_sig</span><span class="params">(<span class="type">int</span> signo)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (signo==SIGINT)&#123;</span><br><span class="line">     …</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(signo==SIGALRM)&#123;</span><br><span class="line">     …</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h4><code>#include &lt;unistd.h&gt;</code><br><code>unsigned int alarm(unsigned int seconds)</code><br>按秒设置下一次闹钟的时间。<br>返回值，如果以前设置过闹钟，再次设置时返回上一次设置时间的余数；否则返回0。<br>alarm函数设置的时间到达时，产生SIGALRM信号。该信号的默认动作是终止程序。<h4 id="进程控制中的信号处理"><a href="#进程控制中的信号处理" class="headerlink" title="进程控制中的信号处理"></a>进程控制中的信号处理</h4>fork时，子进程继承父进程的信号处理。<br>exec时，恢复系统默认设置<h4 id="重入问题"><a href="#重入问题" class="headerlink" title="重入问题"></a>重入问题</h4>信号处理程序可以被中断，中断时可能导致信号处理程序重新进入（再次被调用）。<br>printf不可重入，大多数标准IO库函数不可重入。<br>信号处理程序应尽可能简单，尽可能不用库函数。</li></ul><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到这里，我的笔记也就分享完毕了，大概核心就是PPT内容加我的注解。感叹Unix虽然只有8节课，但也已经将Unix讲的五脏俱全。</p><p>这门课对于OS也还是有一定的帮助，毕竟Unix就是一个活生生的操作系统嘛。</p>]]></content>
      
      
      <categories>
          
          <category> Unix &amp; Linux 系统学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆留存 </tag>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix 记忆留存 （二）</title>
      <link href="/posts/53214/"/>
      <url>/posts/53214/</url>
      
        <content type="html"><![CDATA[<p>这是该系列第二篇。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客是笔者在学习Unix课程时所积累的学习笔记。<br>希望对后来学习Unix的友友复习准备Unix的期末考试有帮助。</p><h1 id="UNIX体系结构"><a href="#UNIX体系结构" class="headerlink" title="UNIX体系结构"></a>UNIX体系结构</h1><p><img src="体系结构.png" alt="体系结构"></p><h1 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h1><h2 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h2><p>1.将一些有用的命令组合变成实用工具。<br>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l  | sed -n &#x27;/^d/p&#x27;   //显示当前目录下的子目录</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi lsdir                //用vi打开lsdir</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh lsdir                //执行lsdir脚本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x lsdir          //为lsdir赋予执行权限</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">PATH=<span class="variable">$HOME</span>/bin:<span class="variable">$PATH</span>    //修改路径</span></span><br></pre></td></tr></table></figure><br>2.快速编写一些实用的软件<br>例如写一个自己的cat命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi mycat                     //用vi打开mycat文件</span></span><br><span class="line">awk &#x27;&#123;print NR, &quot;: &quot;,$0&#125;&#x27; $1   //$1 为shell命令的第1个参数</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x mycat               //给mycat赋予执行权限</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mycat file1                  //执行Mycat并传参file1，效果和<span class="built_in">cat</span>相同</span></span><br></pre></td></tr></table></figure></p><h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><h3 id="重置"><a href="#重置" class="headerlink" title="重置"></a>重置</h3><p>直接举例子：<br>脚本如下：<br><img src="位置参数.png" alt="位置参数"><br>输出如下：<br><img src="输出1.png" alt="输出1"><br>可以看出set命令重置了位置参数<br>参数$0是命令名，不会被重置<br>set会重置除$0以外的所有参数</p><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><p>脚本如下：<br><img src="位置移动.png" alt="位置移动"><br>输出如下:<br><img src="输出2.png" alt="输出2"><br>可以看出shift是左移了参数，$0不算在内。</p><h2 id="shell命令行结构"><a href="#shell命令行结构" class="headerlink" title="shell命令行结构"></a>shell命令行结构</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">单个命令</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span>              //已经在（一）中介绍</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span>             //查看当前日期+时间</span></span><br><span class="line">多个命令            </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span>; <span class="built_in">date</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span>; <span class="built_in">date</span> |<span class="built_in">wc</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(<span class="built_in">who</span>; <span class="built_in">date</span> )|<span class="built_in">wc</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(<span class="built_in">who</span>; <span class="built_in">date</span>)|<span class="built_in">tee</span> save |<span class="built_in">wc</span></span></span><br><span class="line">后台命令</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(<span class="built_in">sleep</span> 5; <span class="built_in">date</span>)&amp;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(<span class="built_in">sleep</span> 5; <span class="built_in">date</span>)&amp; <span class="built_in">who</span></span></span><br><span class="line">命令行特殊符号</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"> &lt;  &gt;&gt;  &lt;&lt;  ;  &amp;</span></span><br><span class="line">转义 $ echo \&gt;</span><br></pre></td></tr></table></figure><h2 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> *           //输出本目录所有文件名字</span></span><br><span class="line">转义 $ echo \*     //输出*</span><br><span class="line">单引号 $ echo &#x27;*&#x27;  //取消所有特殊字符的含义</span><br><span class="line">双引号 $ echo &quot;*&quot;  //除$\``外，取消其它特殊字符的含义</span><br></pre></td></tr></table></figure><h2 id="Shell元字符集"><a href="#Shell元字符集" class="headerlink" title="Shell元字符集"></a>Shell元字符集</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">          //prog&gt;file标准输出重定向</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;          //prog&gt;&gt;file标准输出重定向（添加）</span></span><br><span class="line">&lt;           //prog&lt;file标准输入重定向</span><br><span class="line">&lt;&lt;str       //即时文件读入，直到str结束</span><br><span class="line">|           //p1|p2   p1的标准输出连接到p2的标准输入</span><br><span class="line">*           //匹配文件名中任意字符串</span><br><span class="line">?           //匹配文件名中任意单个字符</span><br><span class="line">[ccc]       //匹配文件名中单个ccc中的字符。ccc可以指定范围，如0-9，a-z等</span><br><span class="line">;           //命令结束符。p1;p2，先执行p1，再执行p2</span><br><span class="line">&amp;           //后台命令结束符。不等命令结束，立即接受新的命令</span><br><span class="line">`…`         //执行命令…，用执行后的标准输出代替…   例如$ echo `date`</span><br><span class="line">(…)         //在子shell里运行括号里的命令</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1, <span class="variable">$2</span>, …   //位置参数</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">var        //引用变量var的值</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">&#123;var&#125;      //同上，在可能引起歧义时，使用&#123;&#125;将变量名括起来。</span></span><br><span class="line">\           //转义，取消字符的特殊含义</span><br><span class="line">&#x27;…&#x27;         //单引号，字符串，对…中的特殊字符不作解释</span><br><span class="line">&quot;…&quot;         //双引号，字符串，对…中的特殊字符仅解释$\``</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">          //注释。从<span class="comment">#开始至行尾为注释</span></span></span><br><span class="line">var=value   //对变量var赋值</span><br><span class="line">P1 &amp;&amp; p2    //运行p1，若成功，运行p2</span><br><span class="line">P1 || p2    //运行p1，若不成功，运行p2</span><br></pre></td></tr></table></figure><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><p>其实在之前已经介绍的比较清楚了，这里再举几个例子加深一下印象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> don<span class="string">&#x27;t do that                    //会认为这不是一条完整指令</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">echo &quot;don&#x27;</span>t <span class="keyword">do</span> that<span class="string">&quot;                  //don&#x27;t do that</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">echo &quot;</span>don<span class="string">&#x27;t do that, $0&quot;              //don&#x27;</span>t <span class="keyword">do</span> that,bash</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;don&#x27;t do that, <span class="variable">$0</span>, `date`&quot;</span>      //don<span class="string">&#x27;t do that,bash,2023年 04月 26日 星期三 23:58:21 CST</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">echo &quot;don&#x27;</span>t <span class="keyword">do</span> that, \<span class="variable">$0</span>, \`<span class="built_in">date</span>\`<span class="string">&quot;   //don&#x27;t do that, <span class="variable">$0</span>, `date`</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">echo &#x27;don&#x27;t do that,  <span class="variable">$0</span>, `date`&#x27;     //会认为这不是一条完整指令</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="string">echo &#x27;dont do that,  <span class="variable">$0</span>, `date`&#x27;      //dont do that,  <span class="variable">$0</span>, `date`</span></span></span><br></pre></td></tr></table></figure></p><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>每个程序启动时自动打开三个文件：标准输入、标准输出和标准错误输出文件，文件描述符分别为0、1、2.<br>>和&gt;&gt;将标准输出定向为一个文件，如$who &gt; ttt<br>&lt;将标准输出定向为一个文件，如$cat &lt; ttt<br><div class="note orange no-icon flat"><p>如何重定向标准错误输出？</p></div><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc sig.c &gt;ttt       //重定向输出</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc sig.c 2&gt;ttt      //重定向错误输出</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc sig.c &gt;ttt 2&gt;&amp;1  //重定向输出和错误输出</span></span><br></pre></td></tr></table></figure></p><h3 id="lt-lt-的用途"><a href="#lt-lt-的用途" class="headerlink" title="&lt;&lt;的用途"></a>&lt;&lt;的用途</h3><p>&lt;&lt;定义即时文件的结束符，用于在shell程序中创建文件。<br>举个例子：<br>ttt.sh脚本内容如下：<br><img src="左移符号的用途.png" alt="左移符号的用途"><br>第一行表示将cat的输出重定向到$1的文件中，并且以end为结束符<br>第二行为一句话。<br>第三行出现结束符，cat命令结束运行。<br>输入如下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sh ttt.sh ttt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> ttt</span></span><br><span class="line">输出：hello world!</span><br></pre></td></tr></table></figure><br>这也说明结束符是不会被算进去的。</p><h2 id="shell程序的结构"><a href="#shell程序的结构" class="headerlink" title="shell程序的结构"></a>shell程序的结构</h2><p>结构就是没有结构，就是命令列表。</p><h3 id="命令分类"><a href="#命令分类" class="headerlink" title="命令分类"></a>命令分类</h3><ul><li>普通命令  who  date</li><li>赋值命令  i=5</li><li>运算命令  let j=$i*4</li><li>if命令</li><li>case命令</li><li>for命令</li><li>while命令</li><li>until命令</li></ul><h2 id="if命令"><a href="#if命令" class="headerlink" title="if命令"></a>if命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command11</span><br><span class="line">    command12</span><br><span class="line">    ......</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    command21</span><br><span class="line">    command22</span><br><span class="line">    ......</span><br><span class="line">else</span><br><span class="line">    command31</span><br><span class="line">    command32</span><br><span class="line">    ......</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>例如，判断参数个数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if test $# -eq 5    //$#为shell内部变量，代表参数个数</span><br><span class="line">then</span><br><span class="line">   echo there are 5 argus</span><br><span class="line">elif test $# -gt 5</span><br><span class="line">then</span><br><span class="line">   echo more than 5 argus</span><br><span class="line">else</span><br><span class="line">   echo less than 5 argus</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h2 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h2><p>常用于if、while、until命令中的条件判断<br>功能：判断文件类型或表达式是否为真</p><h3 id="file模式"><a href="#file模式" class="headerlink" title="file模式"></a>file模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test -e file   //文件存在</span><br><span class="line">test –b file   //文件存在且为块设备文件</span><br><span class="line">test –c file   //文件存在且为字符设备文件</span><br><span class="line">test –d file   //文件存在且为目录文件</span><br><span class="line">test –f file   //文件存在且为普通文件</span><br></pre></td></tr></table></figure><h3 id="expression模式"><a href="#expression模式" class="headerlink" title="expression模式"></a>expression模式</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test e1         //e1为真</span><br><span class="line">test ! e1       //e1为假</span><br><span class="line">test e1 –a e2   //e1,e2都为真</span><br><span class="line">test e1 –o e2   //e1或e2为真</span><br><span class="line">test f1 –nt f2  //文件f1比文件f2新</span><br><span class="line">test f1 –ot f2  //文件f1比文件f2旧</span><br></pre></td></tr></table></figure><h3 id="string模式"><a href="#string模式" class="headerlink" title="string模式"></a>string模式</h3><p>test –n str  //字符串str非空<br>test –z str  //字符串str为空</p><h2 id="case命令"><a href="#case命令" class="headerlink" title="case命令"></a>case命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case word in</span><br><span class="line">pattern1) list1;;</span><br><span class="line">pattern2) list2;;</span><br><span class="line">…</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>例如：改一改刚才的if例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case $# in</span><br><span class="line">5)</span><br><span class="line">   echo there are 5 argus;;</span><br><span class="line">[0-4])</span><br><span class="line">   echo less than 5 argus;;</span><br><span class="line">*)</span><br><span class="line">   echo more than 5 argus</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></p><h2 id="for命令"><a href="#for命令" class="headerlink" title="for命令"></a>for命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for variable in 某个集合   //集合中元素的个数决定循环的次数</span><br><span class="line">do</span><br><span class="line">    list</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>例如，显示所有命令行参数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line">echo there are $# argus</span><br></pre></td></tr></table></figure></p><h3 id="特殊（bash专属）"><a href="#特殊（bash专属）" class="headerlink" title="特殊（bash专属）"></a>特殊（bash专属）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for ((e1;e2;e3))</span><br><span class="line">do</span><br><span class="line">   list</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>这种结构几乎和C语言一模一样，除了多了一层括号。<br>例如，倒序显示命令行参数<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">j=0</span><br><span class="line">for i in $*</span><br><span class="line">do</span><br><span class="line">  a[j]=$i</span><br><span class="line">  let j=$j+1</span><br><span class="line">done</span><br><span class="line">for ((i=$#-1; i&gt;=0; i--))</span><br><span class="line">do</span><br><span class="line">  echo $&#123;a[i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><h2 id="shell内部变量"><a href="#shell内部变量" class="headerlink" title="shell内部变量"></a>shell内部变量</h2><p>$#   //命令行参数个数<br>$*   //命令行参数集合<br>$@   //命令行参数集合  //与$*有细微差别<br><div class="note orange no-icon flat"><p>对于 $* 来说，加了双引号之后所有位置参数就会被视为一个单词<br>对于 $@ 来说，是否加双引号，结果都是一样的</p></div><br>$?   //最后一条命令的返回值<br>$$   //当前shell的进程号<br>$!   //最后一个后台命令的进程号<br>$HOME//用户home目录<br>$PATH//查询PATH 环境变量<br>$PS1 //定义命令行的提示符<br>$PS2 //命令行里较长命令的换行提示信息（符）</p><h2 id="while命令结构"><a href="#while命令结构" class="headerlink" title="while命令结构"></a>while命令结构</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while</span><br><span class="line">   list</span><br><span class="line">do</span><br><span class="line">   list</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">until</span><br><span class="line">   list</span><br><span class="line">do</span><br><span class="line">   list</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><p>break 跳出循环<br>continue 下一个循环<br>exit n  终止shell程序，n为返回值<br>trap  设置中断处理命令。例如：</p><ul><li>trap ‘rm –f tmpfile; exit 1’ 1 2 15 </li></ul><h2 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case $# in</span><br><span class="line">0)</span><br><span class="line">   echo Usage: which cmd</span><br><span class="line">   exit -1;;</span><br><span class="line">esac</span><br><span class="line">for i in `echo $PATH|sed &#x27;s/:/ /g&#x27;`</span><br><span class="line">do</span><br><span class="line">   if test -f $i/$1</span><br><span class="line">   then</span><br><span class="line">      echo $i/$1</span><br><span class="line">      exit 0</span><br><span class="line">   fi</span><br><span class="line">done</span><br><span class="line">echo not found</span><br></pre></td></tr></table></figure><p>此为找到命令所在路径。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>shell编程的优点：充分利用现有资源，快捷<br>shell程序的缺点：功能有限，代码不易读，可移植性差<br>shell本身是一个普通用户的接口，能提供如此编程环境已经不易。</p><h1 id="C语言开发环境"><a href="#C语言开发环境" class="headerlink" title="C语言开发环境"></a>C语言开发环境</h1><h2 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h2><p>这里放一些平时不太用到的，常用的就不放了。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>自从1973年Dennis Ritchie发明C语言并用C语言改写了UNIX系统之后，C语言就与UNIX系统紧密结合在一起，成UNIX系统的“自然”语言。</p><p>1988年，IEEE推出POSIX标准，C语言有了标准的头文件，也使得任何UNIX系统都提供C语言编程环境。</p><p>因此，对许多应用而言，C语言总是首选。<br><div class="note green no-icon flat"><p>所以，一般情况下，如果有人和你说他的Linux没有C语言环境，你可以缓缓扣一个问号。</p></div></p><h2 id="预编译指令"><a href="#预编译指令" class="headerlink" title="预编译指令"></a>预编译指令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">include &lt;stdio.h&gt;   \\告诉编译程序，在编译之前在“常见位置”寻找stdio.h，将其内容包含到程序中。</span></span><br></pre></td></tr></table></figure><p>如何理解？<br>#为预编译指令，告诉编译程序其后的内容在编译之前需要处理。<br>include表示包含某个文件<br>&lt;&gt;表示“常见位置”，通常为/usr/include. 如果文件在其它位置，应使用“”号。如#include “myhead.h”。<br>stdio.h为标准输入/输出头文件，其中包含了main函数所使用的printf函数</p><h2 id="主函数参数"><a href="#主函数参数" class="headerlink" title="主函数参数"></a>主函数参数</h2><p><code>int argc; char *argv[];</code><br>主函数参数是命令行的参数，argc是参数的数量，argv是各个参数所组成的数组。<br>良好的习惯：对于输入数据，如果给出了输入文件，则从该文件读入数据，否则从标准输入读入数据；对于输出数据，如果给出了输出文件，则输出至该文件，否则输出至标准输出文件。——这样便于使用管道来连接命令。</p><h2 id="主函数返回值"><a href="#主函数返回值" class="headerlink" title="主函数返回值"></a>主函数返回值</h2><p><code>return 0;</code><br>主函数最好声明为int类型。如果程序正常结束，主程序的返回值最好为0，否则返回-1或其它值。这样有利于shell编程。<br>使用echo命令可以查看最后一条命令的返回值($?)</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>UNIX系统中默认的c编译器为cc。在Ubuntu中，cc等同于gcc。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc hello.c           //生成可执行程序 ./a.out</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -o hello hello.c  //生成可执行程序 hello</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc p1.c p2.c         //源程序由两个文件组成。编译p1.c和p2.c，生成./a.out</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -c p1.c           //编译p1.c，生成目标文件p1.o，不连接。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cc -g hello.c        //编译hello.c，在目标文件中加入调试信息。</span></span><br></pre></td></tr></table></figure></p><h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>gdb是GNU开源组织发布的一个UNIX下的程序调试工具。功能强大。<br>主要功能包括：<br>1）启动程序，可以按照自定义的要求运行程序。<br>2）可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式）<br>3）当程序被停住时，可以检查此时你的程序中所发生的事。<br>4）动态的改变你程序的执行环境。<br>（采用命令行界面）<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb)                  //gdb 命令提示符</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) <span class="built_in">help</span>             //显示gdb命令分类</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) <span class="built_in">help</span> breakpoints //显示断点设置的相关命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) h b              //同上。只要不引起歧义，gdb命令可以简写。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">(gdb) he bre           //同上。</span></span><br></pre></td></tr></table></figure></p><h3 id="工程管理器"><a href="#工程管理器" class="headerlink" title="工程管理器"></a>工程管理器</h3><p>这里指的是Makefile</p><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>自动编译工程中的源文件，生成最终程序。</p><p>在大型的软件开发过程中，软件由多个人开发，源程序包含很多个文件，这些文件在不断地更改，每一次编译的过程复杂，全部重新编译或重复某些不必要的编译是一件费时的过程，因此，“自动、合理的编译”显得十分重要。</p><h4 id="make文件"><a href="#make文件" class="headerlink" title="make文件"></a>make文件</h4><p>使用make命令来完成工程文件的编译，我们必须建立一个编译规则的描述文件，简称“make文件”。make文件的默认文件名为makefile、Makefile或GNUmakefile，也可以使用其它文件名。<br>使用默认文件名时，<strong>只需</strong>执行命令make即可完成编译；使用其它文件名时，需要执行make -f filename来完成编译。<br>GNUmakefile默认文件名只能由GNU make来识别，不推荐使用。<br><div class="note green no-icon flat"><p>现在，明白为什么OS编译MOS只需要make了吧，因为它使用的是默认文件名——Makefile.</p></div></p><h4 id="编译规则"><a href="#编译规则" class="headerlink" title="编译规则"></a>编译规则</h4><p>举个例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p: p1.o p2.o          //制作对象为p,依赖文件为p1.o p2.p</span><br><span class="line">   gcc -o p p1.o p2.o //gcc命令，生成执行文件</span><br><span class="line">p1.o: p1.c            //制作对象为p1.o,依赖文件为p1.c</span><br><span class="line">   gcc -c p1.c        //gcc命令，生成.o文件</span><br><span class="line">p2.o: p2.c            //制作对象为p2.o,依赖文件为p2.c</span><br><span class="line">   gcc -c p2.c        //gcc命令，生成.o文件</span><br></pre></td></tr></table></figure></p><ul><li>上例中包含3条规则，每条规则包含一个文件依赖关系和一条命令。p:p1.o p2.o表示文件p依赖文件p1.o和p2.o，如果这两个文件中的任何一个比文件p新（更改时间更晚），则执行规则中的命令gcc -o p p1.o p2.o。</li><li>所以，如果不新，就算执行这条命令也不会真正去执行gcc命令。</li><li>在默认情况下，make文件的第一条规则目标文件为终极目标文件。</li><li>make根据终极目标文件中所依赖的文件逐级展开规则。</li><li>对于所有所依赖的文件，make依次检查后续规则中是否有生成该文件的规则。如果有，则采用该规则；</li><li>如果没有，则可能自动生成一条隐含规则，如p1.o:p1.c; gcc -c p1.c。如果文件不存在，又无法自动生成隐含规则，则报错。</li><li>当终极目标的规则被完全展开后，make将从最后一个被展开的规则处开始执行，之后处理倒数第二个规则，依次回退，最后处理终极目标所在的规则。</li></ul><h4 id="编写结构"><a href="#编写结构" class="headerlink" title="编写结构"></a>编写结构</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标文件：依赖文件1  依赖文件2  …</span><br><span class="line">&lt;tab&gt;命令1   [#注释]</span><br><span class="line">&lt;tab&gt;命令2   [#注释]</span><br><span class="line">……</span><br></pre></td></tr></table></figure><div class="note orange no-icon flat"><p>必须是tab而不是n个空格。</p></div><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><ul><li>第一步：<strong>预处理</strong>。处理预处理指令，如#inlude、#define等，输出预处理后的源文件。</li><li>第二步：<strong>编译</strong>。词法和语法分析，如果有错误，则给出提示终止编译；如果没有错误，则将源程序翻译成汇编代码（或其它中间代码）。汇编代码是以助记符来代替机器代码的一种代码。</li><li>第三步：<strong>汇编</strong>。将汇编代码转换成机器代码，输出目标文件。</li><li>第四步：<strong>连接</strong>。连接各目标文件，生成可执行程序。</li></ul><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>make文件中可以使用变量，这样更为简洁，避免出错。例如：<br><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objs = main.o kbd.o command.o display.o \     // \用来表示该行未结束。  </span><br><span class="line">          insert.o search.o files.lo untils.o // n个.o文件</span><br><span class="line"><span class="section">edit:<span class="variable">$(objs)</span>                                  //制作目标为edit，依赖为一个变量的内容。</span></span><br><span class="line">   cc -o  edit <span class="variable">$(objs)</span>                        //编译生成edit文件。</span><br></pre></td></tr></table></figure><br><div class="note purple no-icon flat"><p>用\将较长的行分解为多行。\取消换行符的作用，其后面不能有空格等字符，否则会出错（很隐蔽的错误）。</p></div></p><h3 id="使用隐含规则"><a href="#使用隐含规则" class="headerlink" title="使用隐含规则"></a>使用隐含规则</h3><p>只有依赖关系而没有命令的规则为隐含规则.<br>对于隐含规则，make会自动运行相应的命令来生成目标文件。如 gcc -c -o p1.o p1.c<br>对于p1.o:p1.c这种自动的依赖关系，可以省略不写。<br>只有自动依赖关系的隐含规则可以不写。<br>其他是没法隐含的。</p><h3 id="伪目标规则"><a href="#伪目标规则" class="headerlink" title="伪目标规则"></a>伪目标规则</h3><p>伪目标规则完成某些编译以外的任务。<br>例如一个很常用的：<br><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clear:    //制作目标：clear</span></span><br><span class="line">   rm *.o //删除所有.o文件</span><br></pre></td></tr></table></figure><br>如果伪目标文件存在，将不会执行预期的操作，因此，最好在make文件中声明伪目标规则<br><figure class="highlight make"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clear  //声明伪目标规则</span></span><br></pre></td></tr></table></figure></p><h2 id="标准c函数"><a href="#标准c函数" class="headerlink" title="标准c函数"></a>标准c函数</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统需要向运行程序提供各种服务，如打开文件、读写文件、分配内存、获取当前时间、执行新的程序等。访问这些服务的接口叫做“系统调用（sysem call）”，或叫做“应用程序接口（API）”、“系统服务原语”等。</p><p>UNIX每个系统调用都在c库中设置一个具有同样名字的函数。这些函数按照系统要求的技术调用相应的内核服务。例如将若干c参数送入通用寄存器，然后执行某个软中断进入内核的机器指令。</p><p>从应用的角度，系统调用可视为c函数。</p><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>库函数是在系统调用基础上所实现的公共函数。</p><p>一个库函数可能会调用一个或多个系统调用，也可能不使用任何系统调用。例如，printf函数是库函数，它调用write系统调用；strcpy复制一个字符串，不使用系统调用。</p><h3 id="二者的关系"><a href="#二者的关系" class="headerlink" title="二者的关系"></a>二者的关系</h3><p>系统调用是操作系统内核提供的，而库函数是具体编程语言提供的。库函数构建在系统调用基础之上。</p><p>从编程的角度，编程者可编写其它函数来替换库函数，但无法替换系统调用。</p><p>系统调用通常提供某种功能的一个最小接口，而库函数通常提供比较复杂的功能。例如，系统调用write提供基本的文件写操作，而printf则提供格式化的写操作。</p><h3 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h3><p>在不需要严格区分的前提下，“标准c函数”、“库函数”指所有c语言标准头文件中定义的函数，其中包括库函数和系统调用。</p><h1 id="UNIX和C语言标准化"><a href="#UNIX和C语言标准化" class="headerlink" title="UNIX和C语言标准化"></a>UNIX和C语言标准化</h1><h2 id="ISO-C"><a href="#ISO-C" class="headerlink" title="ISO C"></a>ISO C</h2><p>ISO C 是纯语言标准，不针对任何操作系统。<br>ISO C 定义了标准库函数，包含24个头文件。</p><h3 id="c90"><a href="#c90" class="headerlink" title="c90"></a>c90</h3><p>1989年，美国国家标准学会（ANSI American National Standards Institude）推出c语言标准，1990年被国际标准化组织（ISO）采纳，简称c90</p><h3 id="c99"><a href="#c99" class="headerlink" title="c99"></a>c99</h3><p>1999年，ISO修改了标准，简称c99.</p><h2 id="IEEE-POSIX"><a href="#IEEE-POSIX" class="headerlink" title="IEEE POSIX"></a>IEEE POSIX</h2><p>1988年，为增强应用程序在各UNIX系统之间的可移植性，IEEE推出POSIX标准。<br>POSIX：Portable Operating System Interface，可移植的操作系统接口。<br>POSIX 标准不区分库函数和系统调用，一律称之为函数。<br>POSIX 标准包括ISO C所定义的标准库，另外还定义了26个必须的头文件，26个扩展头文件和8个可选的头文件。<br>1990年该标准被ISO采纳，通常称为POSIX.1</p><h2 id="Open-Group-SUS"><a href="#Open-Group-SUS" class="headerlink" title="Open Group SUS"></a>Open Group SUS</h2><p>1994年，Open Group推出单一UNIX规范（ SUS： Single UNIX Specification）。<br>SUS在POSIX基础上定义了一些附加接口，这些接口扩展了基本的POSIX规范的功能。相应的系统接口全集称之为X/Open系统接口（XSI: X/Open System Interface）。<br>XSI规定，只有遵循了POSIX.1中哪些可选的部分才能认为是遵循了XSI，并且规定：只有遵循了XSI的操作系统才能称为UNIX系统。</p>]]></content>
      
      
      <categories>
          
          <category> Unix &amp; Linux 系统学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆留存 </tag>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unix 记忆留存 （一）</title>
      <link href="/posts/5500/"/>
      <url>/posts/5500/</url>
      
        <content type="html"><![CDATA[<p>这是该系列第一篇。</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇博客是笔者在学习Unix课程时所积累的学习笔记。<br>希望对后来学习Unix的友友复习准备Unix的期末考试有帮助。</p><h1 id="什么是UNIX"><a href="#什么是UNIX" class="headerlink" title="什么是UNIX"></a>什么是UNIX</h1><p>UNIX是一类操作系统。</p><p>狭义理解，UNIX是一个分时操作系统的核心，控制和分配计算机资源（软硬件），协调各应用进程的运行。</p><p>广义理解，UNIX除了其核心外，还包括一些基本的工具，如编辑器、编译器、文件操作工具、文字处理工具等。</p><p>更广义地理解，UNIX还包括用户自己开发的各种工具软件。</p><h1 id="UNIX的历史"><a href="#UNIX的历史" class="headerlink" title="UNIX的历史"></a>UNIX的历史</h1><p>1965年，贝尔实验室参与由MIT和GE发起的一个计划：开发一个多用户、多任务、多层次（multi-user、multi-processor、multi-level）的操作系统MULTICS（MULTiplexed Information and Computing System）</p><p>1969年，MULTICS计划失败，贝尔实验室的工程师们退出该计划。 Ken Thompson将自己开发一款原本运行在MULTICS系统上游戏软件“Space Travel（星际之旅）”移植到GE-635的机器上（GECOS系统），但速度很慢，且GE-635的运行费用昂贵（75$/秒）</p><p>Ken Thompson决定为自己的游戏软件寻找一个替代的开发运行环境。正好有一台PDP-7（DEC公司生产）迷你计算机闲置。 Ken Thompson和Dennis Ritchie共同开发了一个简单的操作系统，仅支持两个用户，也只有两个用户（作者自己）。Brian Kernighan 参照MULTICS将这个简单的操作系统戏称为UNICS，后来人们取其谐音称UNIX。</p><p style="color: #FF0000;">1970年----UNIX元年。</p><p>良好的可移植性促使UNIX系统蔓延。1974年，Ken Thompson的母校U.C. Berkeley开始接触UNIX。</p><p>1977年，Bill Joy修改了部分Kernel，编写了vi、pascal编译器等，产生了1BSD（Berkeley Software Distribution）。</p><p>1978年，BSD UNIX与TCP/IP开始结合，成为最有影响力的UNIX系统。</p><p>1988年，为统一各UNIX系统编程接口，提供应用程序在各UNIX系统之间的可移植性。IEEE出台了POSIX（Portable Operating System Interface）标准，定义了UNIX系统必须提供的接口函数（在C语言头文件中定义）</p><p><img src="Unix家族.png" alt="Unix家族"></p><center>Unix家族</center><h1 id="系统时间"><a href="#系统时间" class="headerlink" title="系统时间"></a>系统时间</h1><p>自1970年1月1日0时0分0秒以来国际标准时间所经历过的秒数累计值。</p><blockquote><p>需要掌握Unix历史，这里考的比例还不低。</p></blockquote><h1 id="大事编年史"><a href="#大事编年史" class="headerlink" title="大事编年史"></a>大事编年史</h1><ul><li>1965:MULTICS</li><li>1969:MULTICS失败，UNIX开始研发</li><li>1970:UNIX元年(作者Ken Thompson和Dennis Ritchie)</li><li>1973:C语言诞生，UNIX第一个正式版本：SYSTEM V(Dennis Ritchie)</li><li>1977:Vi，Pascal编辑器，1BSD UNIX(Bill Joy)</li><li>1978:BSD UNIX结合TCP/IP，成为最具影响力系统</li><li>1984:X Window诞生</li><li>1987:X Window最后一版(11版本)</li><li>1987:MINIX(Andrew S. Tanenbaum)</li><li>1988:POSIX标准</li><li>1991:Linux(Linus Torvalds)</li><li>1994:X Window X11</li><li>1994:单一UNIX规范SUS,产生XSI,规定遵循XSI的操作系统才是Unix(Open Group)</li><li>2004:Ubuntu Linux(Mark Shuttleworth)</li></ul><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux的由来"><a href="#Linux的由来" class="headerlink" title="Linux的由来"></a>Linux的由来</h2><p>1987年，荷兰阿姆斯特丹Vrije大学Andrew S. Tanenbaum教授（MIT学士，Berkeley博士）为课堂教学编写了Minix系统。<br>1991年，年仅21岁的芬兰赫尔辛基大学的学生Linus Torvalds参考Minix开发了PC版的UNIX，命名为Linux。</p><h2 id="Linux的特点"><a href="#Linux的特点" class="headerlink" title="Linux的特点"></a>Linux的特点</h2><p>与UNIX兼容，遵从POSIX标准<br>自由，开源<br>性能高，安全性强</p><h2 id="Linux的版本"><a href="#Linux的版本" class="headerlink" title="Linux的版本"></a>Linux的版本</h2><p>核心版本  由Linus本人负责维护，版本号由三部分组成x.y.z，x是主版本号，y是次版本号，z是修订次数。次版本号为偶数表示稳定的版本，奇数表示测试版。<br>发行版  各公司推出的版本。如Red Hat，红旗Linux等等，有上百种。</p><h1 id="Ubuntu-Linux"><a href="#Ubuntu-Linux" class="headerlink" title="Ubuntu Linux"></a>Ubuntu Linux</h1><p>创始人 Mark Shuttleworth，1973年生于南非，现居伦敦。2004年通过旗下的Canonical公司来资助Ubuntu Linux的开发<br>是目前增长势头最强劲的Linux发行版</p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p>用户与计算机硬件之间的界面，它是控制、管理计算机系统内各种硬件和软件资源，有效地组织多道程序运行的系统软件(或程序集合)。</p><h1 id="X-Window"><a href="#X-Window" class="headerlink" title="X Window"></a>X Window</h1><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>1984年,麻省理工学院（MIT）计算机科学研究室开始研究UNIX系统下的视窗（window）系统，他们从斯坦福（Stanford）大学得到了一套叫做W（Window的第一个字母）的实验性视窗系统，然后开始进一步开发。同年6月，发布新系统的第一个版本，取名X（W的下一个字母），连同版本号，称X1。由于X是一个视窗系统，所以又叫X Window<br>1985年1月，发布第六版X6，对外部公司开始授权<br>1985年9月，发布X9<br>1985年12月，发布X10<br>1987年9月15日，发布X11。此时X已取得明显成功，MIT退出。第11版成为最终版。<br>1994年5月16日，第六次发布X11，称X11R64</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><ul><li>采用客户-服务器模型</li><li>X客户程序将显示请求发送给X服务程序，由X服务程序驱动硬件设备予以显示。</li><li>X客户与X服务器之间的接口协议叫做X协议<br><img src="X Windows.png" alt="X Window"><h3 id="X-server"><a href="#X-server" class="headerlink" title="X server"></a>X server</h3></li><li>处理输出<ul><li>接受X client的输出请求，驱动硬件显示</li></ul></li><li>处理输入<ul><li>接受键盘、鼠标的输入，当作“事件”传送给适当的客户程序。<h3 id="窗口管理器"><a href="#窗口管理器" class="headerlink" title="窗口管理器"></a>窗口管理器</h3>一个特殊的X客户程序，具有改变窗口大小、位置、堆放层次等功能。<h3 id="桌面系统"><a href="#桌面系统" class="headerlink" title="桌面系统"></a>桌面系统</h3>另一个特殊的X客户程序，依赖窗口管理器，控制桌面、菜单的位置、风格、效果等。<h3 id="X-协议"><a href="#X-协议" class="headerlink" title="X 协议"></a>X 协议</h3></li></ul></li><li>X 系统采用客户-服务器模型，带来如下优点：<ul><li>X server屏蔽了硬件特性，使得X client和X server之间的X协议是一个完全抽象的协议，具有很强的可移植性</li><li>将X协议构建在网络协议之上，X server和X client可以运行在不同的机器上，这带来了很大的灵活性。</li></ul></li></ul><div class="note warning flat"><p>当用户使用X协议登录远程计算机时，本地运行的是X server，远程计算机运行的应用程序是X client。</p></div><h3 id="X-开发接口"><a href="#X-开发接口" class="headerlink" title="X 开发接口"></a>X 开发接口</h3><ul><li>X Library<ul><li>最底层的程序界面，主要功能是存取X protocol的服务</li><li>常见的有：Xlib、Motif、Qt</li></ul></li><li>X Toolkit<ul><li>X Library基础上的拓展，提供大量函数或组件。</li><li>种类很多，有Motif、OpenLook、Gimp、X foums、X Toolkit（Xt）等</li></ul></li></ul><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>who 显示系统中有哪些使用者正在上面<br>who am I/whoami 实测whoami有效 表示当前用户<br>write username 给Username发消息<br>man command 查看command的手册<br>w/wr 执行这项指令可得知目前登入系统的用户有哪些人，以及他们正在执行的程序 实测w有效。<br>logout logout指令让用户退出系统，其功能和login指令相互对应。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="行编辑器"><a href="#行编辑器" class="headerlink" title="行编辑器"></a>行编辑器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ed                      <span class="comment"># 打开ed编辑器</span></span></span><br><span class="line">a                         # 表示要开始输入一个新文件</span><br><span class="line">now type in…              # 第一行输入</span><br><span class="line">what do you want to type? # 第二行输入</span><br><span class="line">.                         # 切到命令模式</span><br><span class="line">w tmp                     # w 表示保存 w tmp 表示保存为tmp</span><br><span class="line">q                         # 退出</span><br></pre></td></tr></table></figure> <blockquote><p>这玩意其实挺不常用的 = =,现在可能更多的是vim和nvim等</p></blockquote><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>但积累一下还是有必要的，因为假如不小心把系统玩坏了，就只能用这个编辑器来抢救系统了。</p></div><h3 id="文件列表"><a href="#文件列表" class="headerlink" title="文件列表"></a>文件列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span>     //普通列出当前目录所有文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> –l  //详细信息列表</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> –t  //按修改时间排序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> –lt //命令选项可以组合</span></span><br></pre></td></tr></table></figure> <h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>cat filename 命令用于连接文件并打印到标准输出设备上。<br>more filename 类似于cat,但只不过是将内容分页显示<br>touch 参见<a href="https://foreveryolo.github.io/posts/1949/">Linux指令操作记录</a><br><div class="note blue no-icon flat"><p>但需要注意的是，touch也可以用来改变内容更新时间</p></div><br>mv 参见<a href="https://foreveryolo.github.io/posts/1949/">Linux指令操作记录</a><br>cp 参见<a href="https://foreveryolo.github.io/posts/1949/">Linux指令操作记录</a><br>rm 参见<a href="https://foreveryolo.github.io/posts/1949/">Linux指令操作记录</a></p><h3 id="针对文本文件的命令"><a href="#针对文本文件的命令" class="headerlink" title="针对文本文件的命令"></a>针对文本文件的命令</h3><p>wc 利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。<br>gerp 参见<a href="https://foreveryolo.github.io/posts/1949/">Linux指令操作记录</a><br>sort 命令用于将文本文件内容加以排序。默认排序为按列第一个字符的ASCII<br>cmp  命令用于比较两个文件是否有差异。</p><p>当相互比较的两个文件完全一样时，则该指令不会显示任何信息。若发现有所差异，预设会标示出第一个不同之处的字符和列数编号。若不指定任何文件名称或是所给予的文件名为”-“，则cmp指令会从标准输入设备读取数据。</p><p>diff 命令用于比较文件的差异。<br>diff 以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。</p><blockquote><p>diff和cmp的区别在于diff按行比较，cmp按字比较。</p></blockquote><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">pwd</span>  显示当前路径（目录）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> 改变当前工作目录，或返回个人主目录</span></span><br><span class="line">. 和..目录</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> 创建子目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rmdir</span> 删除子目录</span></span><br></pre></td></tr></table></figure> <h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p><img src="Shell定位.png" alt="Shell定位"></p><h2 id="Shell的版本"><a href="#Shell的版本" class="headerlink" title="Shell的版本"></a>Shell的版本</h2><p>bsh, csh, ksh, bash,…</p><h2 id="Shell命令提示符"><a href="#Shell命令提示符" class="headerlink" title="Shell命令提示符"></a>Shell命令提示符</h2><p>root用户 #，普通用户$, %,…</p><h2 id="内部命令和外部命令"><a href="#内部命令和外部命令" class="headerlink" title="内部命令和外部命令"></a>内部命令和外部命令</h2><p>shell自己完成的命令为内部命令，如cd等；调用某个程序来完成的命令为外部命令，如ed。</p><h2 id="文件名缩写（模式）"><a href="#文件名缩写（模式）" class="headerlink" title="文件名缩写（模式）"></a>文件名缩写（模式）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span>  *.c        //匹配任意以.c为后缀的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span>  a*[1-9].c  //匹配任意a开头重复0次或多次，以数字1-9结尾的且以.c为后缀的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span>  ?.c        //匹配1-2个字符并且以.c为后缀的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> *         // 控制台输出当前目录的所有文件和目录名</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> \*        // 控制台输出 *，这是因为\发挥了转义的作用</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> <span class="string">&#x27;*&#x27;</span>         // <span class="built_in">ls</span> * 是查询出当前目录的文件和子目录的文件 <span class="string">&#x27;*&#x27;</span>实测不识别</span></span><br></pre></td></tr></table></figure> <h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &gt; tmp       //将标准输出重定向到文件tmp中（清除原有文件中的数据）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l &gt;tmp     //将标准输出重定向到文件tmp中（清除原有文件中的数据）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &gt;&gt; tmp      //将标准输出重定向到文件tmp中（追加原有文件中的数据之后）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> 2&gt;&gt; tmp     //将错误输出重定向到文件tmp中（追加原有文件中的数据之后）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &gt;&gt; tmp 2&gt;&amp;1 //将标准输出和错误输出重定向到文件tmp中（追加原有文件中的数据之后）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> &amp;&gt;&gt; tmp     //将标准输出和错误输出重定向到文件tmp中（追加原有文件中的数据之后）</span></span><br></pre></td></tr></table></figure> <h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span> | <span class="built_in">wc</span> -l             //  计算所有用户登录的终端数</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span> | grep pts | <span class="built_in">wc</span> -l  // 计算用户所使用的仿真终端数量. 管道线上的程序是同时运行的，它们之间存在通信。</span></span><br></pre></td></tr></table></figure> <h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span>; <span class="built_in">whoami</span>    //多个命令同时运行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">命令&amp;          //后台运行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps            //显示当前运行的进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span>          //终止某个进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nohup</span> <span class="built_in">command</span> //nohup 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">at  hh:mm 定时运行某些命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">at hh:mm &lt; commandfile</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">at hh:mm</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ......</span><br><span class="line">    Ctrl-D      //在Ubutun22.04上测试失败，未找到该指令。</span><br></pre></td></tr></table></figure> <div class="note blue no-icon flat"><p><code>who &amp;&amp; data</code>代表只有who执行成功才会执行data,需要与<code>;</code>区分</p></div><h2 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设置shell内部变量值</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">PS1=C:\\\&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">PS1=<span class="string">&#x27;`whoami`:`pwd` &gt;&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$HOME</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="variable">$PATH</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/bin</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">d=/home/lls/c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> <span class="variable">$d</span></span></span><br></pre></td></tr></table></figure> <h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h2><p><img src="文件树.png" alt="文件树"></p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>目录文件：包含其它文件的文件。<br>常规文件：文本文件、二进制文件（程序、数据库等）。<br>设备文件：键盘、显示器、打印机、硬盘等。<br><div class="note info flat"><p>一切都是文件，这个很重要！！！</p></div><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">ls</span> -l            //查看文件类型</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"><span class="built_in">od</span> -x filename   //分析文件结构</span></span><br></pre></td></tr></table></figure> </p><h2 id="主目录和当前目录"><a href="#主目录和当前目录" class="headerlink" title="主目录和当前目录"></a>主目录和当前目录</h2><p>主目录：用户登录时所在的位置。（$cd）<br>当前目录：用户或程序当前的工作位置。</p><h2 id="绝对和相对路径"><a href="#绝对和相对路径" class="headerlink" title="绝对和相对路径"></a>绝对和相对路径</h2><p>绝对路径：从根目录出发到某个文件的搜索路径。如：/home/user1/myc/p1.c<br>相对路径：从当前目录出发到某个文件的搜索路径。如：myc/p1.c,   ./bin/prog1,  ../user2/file1</p><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>字母、数字、’_’、’.’    在shell中具有特殊含义的符号避免使用，如&amp;*\{}[]$?%等</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><p>$ ls –l a.out<br>结果：     -rwxr-xr-x  1 user1 users 9319  2010-02-09 23:56 a.out<br>rwx：读、写、运行<br>9个权限位，每3个为一组，分别代表文件所有者、同组用户和其他用户的权限。<br>具体解释：<br><img src="权限位.png" alt="权限位"><br>更改文件权限可以用chmod<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> 777 a.out</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> –w a.out</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">chmod</span> +x ldir</span></span><br></pre></td></tr></table></figure><br>下面两个好理解，我解释一下777：</p><p>事实上，Linux 系统为每种权限（r、w 和 x）分配了对应的数字：</p><div class="table-container"><table><thead><tr><th style="text-align:center">权限</th><th style="text-align:center">数字</th></tr></thead><tbody><tr><td style="text-align:center">r</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">w</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">1</td></tr></tbody></table></div><p>所以，如果我们要合并这些权限，就需要做简单的加法了：将对应的数字相加。</p><p>假如我们要分配读、写权限，那么我们就要用 4+2，就等于 6。数字 6 表示具有读和写权限。</p><p>所以777就表示为文件所有者、同组用户和其他用户赋予全部rwx权限。</p><h3 id="目录文件权限"><a href="#目录文件权限" class="headerlink" title="目录文件权限"></a>目录文件权限</h3><p>x： 是否可以存取目录中的文件。<br>r： 是否可以对目录进行文件列表。可以存取已知的文件。<br>w：是否可以增加、删除目录中的文件。</p><div class="note blue no-icon flat"><p>可以认为X赋予我们访问、修改i节点的权限<br>W赋予我们修改目录项的权限<br>R赋予我们查看目录下的权限</p></div><h2 id="i节点"><a href="#i节点" class="headerlink" title="i节点"></a>i节点</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -il</span> </span><br><span class="line">输出：</span><br><span class="line">531049 -rwxrwxr-x 1 unicorn unicorn 101  3月 22 21:27 Pycharm.sh</span><br><span class="line">526278 -rw-rw-r-- 1 unicorn unicorn  38  4月 22 21:10 tmp</span><br></pre></td></tr></table></figure> <p>531049一列即为i节点。</p><h3 id="文件的组成"><a href="#文件的组成" class="headerlink" title="文件的组成"></a>文件的组成</h3><p>文件名、i节点、文件内容。<br>i节点中记录文件权限、所有者、修改日期、长度、存放位置等等。<br><img src="i节点.png" alt="i节点"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ln</span> file1 file2  //给file1所对应的i节点增加一个文件名file2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> file2        //删除文件名file2。对应的i节点和文件内容依然存在。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">rm</span> file1        //删除文件名file1。由于没有文件名指向该i节点，系统删除该i节点及其对应的文件内容</span></span><br></pre></td></tr></table></figure><p><img src="i节点使用.png" alt="i节点使用"></p><h2 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h2><p>UNIX的精华思想之一就是在文件系统中处理外部设备，按普通文件来处理外设。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l /dev                  //列出所有设备 用文件指令<span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> hello! &gt; /dev/pts/0    //结果是shell界面出现Hello! 和<span class="built_in">echo</span> hello!一个作用</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> c/sig.c &gt;/dev/pts/1     //我失败了，找不到/dev/pts/1</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> tmp /dev/pts/0           //tmp的文件显示在了shell界面</span></span><br></pre></td></tr></table></figure><br>所以/dev/pts/0什么含义已经呼之欲出了。<br>只能说这个思路真的太好了。</p><h1 id="文件编辑和流处理"><a href="#文件编辑和流处理" class="headerlink" title="文件编辑和流处理"></a>文件编辑和流处理</h1><h2 id="ed行编辑器"><a href="#ed行编辑器" class="headerlink" title="ed行编辑器"></a>ed行编辑器</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>作者：Ken Thompson（就是Unix创始人之一）<br>优点：<br>（1）运行环境要求低，是UNIX系统最基本的编辑器。<br>（2）编辑命令功能强大，至今仍然使用。<br>（3）ed提供的正则表达式广泛使用。<br>（4）运行速度很快。</p><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><p>之前已有介绍，这里为了保证完整性允许我再次介绍一次。</p><h4 id="一般指令"><a href="#一般指令" class="headerlink" title="一般指令"></a>一般指令</h4><ul><li>a 从当前行开始添加，实际上是在该行的下一行开始输入</li><li>.  结束添加状态   //必须在行首输入</li><li>w 存盘</li><li>q  退出ed编辑器</li><li>! <strong>临时进入shell</strong> 实测用法为！+ 指令</li></ul><h4 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h4><ul><li>显示命令p （在命令模式下输入）<ul><li>p 显示当前行。</li><li>5 将当前行改为第5行并显示当前行。</li><li>m,np 显示m到n行</li><li>.代表当前行，$代表最后一行</li><li>可使用相对行，如.,.+3p(代表1-3行) or $-5,$p（代表倒数5行）<br>举例：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">文件内容：</span><br><span class="line">123</span><br><span class="line">1234</span><br><span class="line">12345</span><br><span class="line">123456</span><br><span class="line">1234567</span><br><span class="line">12345678</span><br><span class="line">使用：</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">-5,<span class="variable">$p</span></span></span><br><span class="line">输出：</span><br><span class="line">1234</span><br><span class="line">12345</span><br><span class="line">123456</span><br><span class="line">1234567</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><p>/模式/ 查找下一个匹配模式的行，遇到尾行则从首行开始<br>?模式? 查找上一个匹配模式的行，遇到首行则从尾行开始<br>// 重复查找下一个匹配模式的行，模式不变<br>??重复查找上一个匹配模式的行，模式不变<br><div class="note warning flat"><p>查找会改变当前所在的行，查找本身有返回值，返回的是行号。</p></div><br>利用返回值可以做一些事情：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1,/main/p          //显示1到第一次出现main的行</span><br><span class="line">/main/-1,$p        //显示第一次出现main的行的上一行到最后一行</span><br><span class="line">5,?int?d           //删除5到最后一次出现int的行</span><br></pre></td></tr></table></figure></p><h4 id="插入删除撤销"><a href="#插入删除撤销" class="headerlink" title="插入删除撤销"></a>插入删除撤销</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">na      //从n行后添加</span><br><span class="line">ni      //从n行前插入。i、a都以行首.来结束</span><br><span class="line">m,nd    //删除m至n行</span><br><span class="line">u       //撤销所做的编辑</span><br></pre></td></tr></table></figure><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s/old/new/           //把当前行中第一个old替换为new</span><br><span class="line">s/old/new/g          //把当前行中每一个old都替换为new（g有global的意思）</span><br><span class="line">1,$ s/old/new/g      //把文件中所有的old都替换为new  （对每一行都做global替换操作）</span><br></pre></td></tr></table></figure><p>这里有一个助记符号：&amp;<br>表示被替换的对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1，$s/big/very &amp;/g  //把文件中的big都替换为very big</span><br><span class="line">s/and/\&amp;/           //把and改为&amp;,因为&amp;被\转义</span><br></pre></td></tr></table></figure></p><h4 id="ed正则表达式"><a href="#ed正则表达式" class="headerlink" title="ed正则表达式"></a>ed正则表达式</h4><ul><li>c 普通字符，与自己匹配，如a,b等。</li><li>\c 取消字符c的特殊意义，如\&amp;</li><li>^  在模式起始位置时，代表行首。如^a表示行首为a</li><li>$  在模式结束位置时，代表行尾。</li><li>. 匹配任意单个字符。</li><li><code>[…]</code> 匹配<code>[]</code>中任意单个字符，如<code>[1ac]</code>，<code>[a-z]</code>, <code>[1-9]</code></li><li><code>[^…]</code> 匹配不在…中的任意单个字符</li><li><code>r*</code>，零个或多个重复的r，r为单个字符。如<code>a*</code>, <code>[ab]*</code>, <code>.*</code></li><li>&amp; 仅用于替换命令s的右边，代表第一个模式 (这个参看前面的助记符 &amp;)<blockquote><p>这里的正则表达式和一般意义上的正则还是几乎一样的。<br>参看：<a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式</a></p></blockquote>一些例子：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/^$/                 //空行</span><br><span class="line">/./                  //非空行</span><br><span class="line">/^/                  //任意行</span><br><span class="line">/thing/              //包含字符串thing的行</span><br><span class="line">/^thing/             //以thing开始的行</span><br><span class="line"><span class="meta prompt_">/thing$</span><span class="language-bash">/             //以thing结尾的行</span></span><br><span class="line">/^thing$/            //内容为thing的行</span><br><span class="line">/thing.$/            //以thing加任意符号结尾的行</span><br><span class="line">/thing\.$/           //以thing.结尾的行</span><br><span class="line">/\/thing\//          //包含/thing/的行</span><br><span class="line">/[tT]hing/           //包含thing或Thing的行</span><br><span class="line">/thing[0-9]/         //包含thing+任意一个数字的行</span><br><span class="line">/thing[^0-9]/        //包含thing+任意一个非数字的行</span><br><span class="line">/thing[0-9][^0-9]/   //包含thing+任意一个数字+任意一个非数字的行</span><br><span class="line">/thing1.*thing2/     //包含thing1+任意内容+thing2的行</span><br><span class="line">/^thing1.*thing2$/   //以thing1开头，thing2结尾的行</span><br></pre></td></tr></table></figure></li></ul><h4 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h4><p>命令格式：m,ng/re/cmd，含义是从m行到n行中对于匹配re模式的行执行命令cmd. 如果作用范围是全文件(1,$)，m、n可以省略。<br>举例：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">g/…/p            //显示所有包含…的行</span><br><span class="line">g/…/d            //删除所有包含…的行</span><br><span class="line">g/…/s//rep1/     //对于包含…的行，将其中第一个…替换成rep1</span><br><span class="line">g/…/s//rep1/g    //把所有的…替换成rep1</span><br><span class="line">g/…/s/pat/rep1/  //对于包含…的行，将其中第一个pat替换成rep1</span><br><span class="line">v/^$/p           //打印所有非空行</span><br></pre></td></tr></table></figure></p><h4 id="移动，复制"><a href="#移动，复制" class="headerlink" title="移动，复制"></a>移动，复制</h4><p>命令格式：<br>m,nmd  m到n行移到d行之后。<br>m,ntd  m到n行拷贝到d行之后。<br>例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g/^/m0 //我的理解是把非空行移到0行之后，但是由于它先移动第一行到第0行，然后再移动第二行至第0行后，导致位置颠倒过来了。</span><br></pre></td></tr></table></figure></p><h2 id="sed——流编辑器"><a href="#sed——流编辑器" class="headerlink" title="sed——流编辑器"></a>sed——流编辑器</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>直接从ed发展而来，用于处理输出流，常用于管道中。</p><p>命令的一般形式 sed -[opt] ‘ed command1;ed command2’ file.    </p><p>sed从输入文件中依次读取每一行，按指定的ed命令处理，将结果送至标准输出。</p><p>例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/UNIX/Linux/g&#x27;</span> file    //将file中的UNIX替换成Linux显示在屏幕上，但不改变file本身。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">who</span> | sed <span class="string">&#x27;s/ .*//&#x27;</span>          //显示当前登录用户，只显示用户名。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">whoami</span> |sed <span class="string">&#x27;s/ .*//&#x27;</span>        //获取我的登录名.</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;10q&#x27;</span> file               //显示file文件的前10行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/pattern/d&#x27;</span> file        //不显示包含pattern的行。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -n <span class="string">&#x27;/pattern/p&#x27;</span> file     //仅显示包含pattern的行。sed默认显示每一行，-n选项关闭自动显示功能。</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -n ‘/pattern/p’ file     //具有过滤功能，与grep pattern file功能相同。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l  | sed -n <span class="string">&#x27;/^d/p&#x27;</span>      //长格式列出当前目录下的子目录</span></span><br></pre></td></tr></table></figure></p><p><strong>由于sed处理的是输入流，一旦读入一行，前面的行就过去了，无法再次取回，因此sed不具备行运算的能力。</strong></p><p>这里比较简略，只有简介，如果想系统学习推荐OSome平台（逃</p><p><a href="https://www.runoob.com/linux/linux-comm-sed.html">sed学习</a></p><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep pattern file                  //pattern: ed pattern</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">grep <span class="string">&#x27;^void&#x27;</span> sig.c                 //显示sig.c文件中以void开头的行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l  | grep <span class="string">&#x27;^d&#x27;</span>                 //列出当前目录下的子目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l  | grep <span class="string">&#x27;^d&#x27;</span> | sed <span class="string">&#x27;s/.* //&#x27;</span> //列出当前子目录名 .*后面的空格一定要有</span></span><br></pre></td></tr></table></figure><p><a href="https://www.runoob.com/linux/linux-comm-grep.html">grep学习</a></p><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> | <span class="built_in">sort</span>                          //默认排序，上面已经提到了，就是第一列Ascii</span></span><br></pre></td></tr></table></figure><h2 id="tail、head"><a href="#tail、head" class="headerlink" title="tail、head"></a>tail、head</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> file              //显示file的最后10行，实测确实是这样。</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">tail</span> -5 file           //显示file的最后5行</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> file              //显示file的前10行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">head</span> -5 file           //显示file的前5行</span></span><br></pre></td></tr></table></figure><h1 id="模式匹配与处理语言awk"><a href="#模式匹配与处理语言awk" class="headerlink" title="模式匹配与处理语言awk"></a>模式匹配与处理语言awk</h1><h2 id="一般使用"><a href="#一般使用" class="headerlink" title="一般使用"></a>一般使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;program&#x27;</span> filename</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">commd | awk <span class="string">&#x27;program &#x27;</span></span></span><br></pre></td></tr></table></figure><p>program的形式<br>pattern1 {action1} pattern2{action2}…… ，模式之间为“或”的关系<br>pattern:                               ，ed的正则表达式，逻辑表达式<br>action：                               ，如print、printf等</p><h2 id="缺省"><a href="#缺省" class="headerlink" title="缺省"></a>缺省</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;/pattern/&#x27;</span> file  //显示匹配模式的每一行，功能同grep</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;&#123;print&#125;&#x27;</span>         //显示每一行，功能同<span class="built_in">cat</span></span></span><br></pre></td></tr></table></figure><p>同样是一些例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;//&#x27; sig.c                                                    //输出sig.c全部内容</span><br><span class="line">awk &#x27;&#123;print&#125;&#x27; sig.c                                               //输出sig.c全部内容</span><br><span class="line">awk &#x27;//&#123;print&#125;/main/&#123;print &quot;----------------------------&quot;&#125;&#x27;sig.c  //输出全部内容的同时在main这一行下添加“-----”</span><br></pre></td></tr></table></figure></p><h2 id="记录、字段"><a href="#记录、字段" class="headerlink" title="记录、字段"></a>记录、字段</h2><p>每一行为一条记录，NR为记录数<br>每一个非空的字符串为一个字段，使用$1、$2、…标记，$0为整行，NF为字段数<br>一些例子：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;&#123;print NR, $0&#125;&#x27;</span> file    //显示file的每一行，并在行首加上行号</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;/^d/&#123;print&#125;&#x27;</span>    //长格式列出当前目录下的子目录</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;/^d/&#123;print $8&#125;&#x27;</span> //列出当前目录下的子目录</span></span><br></pre></td></tr></table></figure></p><h2 id="打印（显示）"><a href="#打印（显示）" class="headerlink" title="打印（显示）"></a>打印（显示）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;&#123;print NR, &quot;: &quot; $1, $8&#125;&#x27;</span>      //打印行号：第一列，第八列</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;&#123;printf(&quot;%d: %s\n&quot;, NR, $0)&#125; &#x27;</span>  sig.c //打印行号：整行</span></span><br></pre></td></tr></table></figure><p>有点像C语言的风格。</p><h2 id="pattern"><a href="#pattern" class="headerlink" title="pattern"></a>pattern</h2><h3 id="一般"><a href="#一般" class="headerlink" title="一般"></a>一般</h3><p>字段运算、模式表达式、逻辑表达式<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;$5~/.....*/&#x27;</span>       //列出长度超过999字节的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;$5 !~ /.....*/&#x27;</span>    //列出长度小于等于999字节的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;$5==&quot;4096&quot;&#x27;</span>        //列出长度为4096字节的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;length($5)&gt;3&#x27;</span>      //列出长度超过999字节的文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> -l | awk <span class="string">&#x27;!(length($5)&gt;3) &#x27;</span>  //列出长度小于等于999字节的文件</span></span><br></pre></td></tr></table></figure><br>第一个允许我好好解释一下，ls -l输出如下：<br><img src="ls.png" alt="ls"><br>$5，即对应第五列，表示字节数，‘~’表示正则表达式匹配运算。后面的表达式就是要求至少有4位。</p><p>而只有1000才是4位，所以这里实现了列出长度超过999字节的文件的效果。</p><p>后面的就比较直观啦~</p><h3 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h3><p>awk ‘BEGIN{初始化动作}’，表示在开始处理文件之前，要做的事情。<br>awk ‘END{结束动作}’，表示文件处理结束后，要做的事情。</p><h2 id="变量和运算"><a href="#变量和运算" class="headerlink" title="变量和运算"></a>变量和运算</h2><p>这里举个例子，打印某个文件的行数、单词数和字符数：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;&#123;</span></span></span><br><span class="line">nw += NF; </span><br><span class="line">nc +=length($0)+1;</span><br><span class="line">&#125;</span><br><span class="line">END&#123;</span><br><span class="line">print NR, nw,nc;</span><br><span class="line">&#125;&#x27;  sig.c   </span><br><span class="line">这段程序的功能与wc命令的功能完全一样。</span><br></pre></td></tr></table></figure><br>awk在执行时，遇到自己不认识的东西，比如nw,nc就会将其隐式声明为变量。所以nw就记录了总字段数，nc记录了总字符数。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>笔者用例子来解释，寻找文件中相同的相邻单词：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;NF&gt;0&#123;</span></span></span><br><span class="line">   if ($1==lastword)                                     //lastword为上一行最后一个单词</span><br><span class="line">      printf(&quot;double %s, line %d:\n%s\n&quot;, $1,NR,$0);     //特判第一个和上一行最后一个单词是否相等</span><br><span class="line">   for (i=2; i&lt;=NF; i++)                                 //循环判断本行后一个和前一个是否相等</span><br><span class="line">       if ($i==$(i-1))                                   //判断是否相等</span><br><span class="line">          printf(&quot;double %s, line %d:\n%s\n&quot;, $i,NR,$0); //输出相等的单词，行数，本行全部内容</span><br><span class="line">    lastword=$NF;                                        //记录本行最后一个单词</span><br><span class="line">&#125; &#x27; tmp                                                  //文件名为tmp</span><br></pre></td></tr></table></figure></p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>while语句：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (condition)&#123;</span><br><span class="line">    statement1</span><br><span class="line">    statement2</span><br><span class="line">    …</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>break:跳出循环<br>continue:下一个循环<br>next:下一条记录，回到awk程序开始<br>exit:跳转至END模式或结束</p><h2 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h2><p>FILENAME  当前输入文件名<br>RS    输入记录的分割符（默认为换行符）<br>FS    输入字段的分隔符（默认为空格、制表符）<br>NF    当前记录的字段数<br>NR    当前记录数<br>OFS   输出字段的分隔符（默认为空格）<br>ORS  输出记录的分隔符（默认为换行）</p><h2 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h2><p>cos(expr)  求余弦<br>exp(expr)  求自然指数<br>index(s1,s2)    是否字符串s2位于s1中<br>int(expr)          取整<br>length(s)   求字符串长度<br>log(expr)   求自然对数<br>sin(expr)    求正玄<br>split(s, a, c) 按分隔符c将s放入a[1],a[2],…中<br>substr(s,m,n) 求s的子串，从第m个字符开始，共n个字符。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">awk <span class="string">&#x27;&#123;line[NR] = $0&#125;</span></span></span><br><span class="line">          END&#123;</span><br><span class="line">                # do what you want</span><br><span class="line">                for (i=1; i&lt;=NR; i++) print line[i]</span><br><span class="line">                &#125; &#x27;</span><br></pre></td></tr></table></figure><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>流处理程序的约定，当给定文件名时，数据从文件中读取，否则从标准输入读取。这样便于管道和重定向的使用。</p><h2 id="具体学习"><a href="#具体学习" class="headerlink" title="具体学习"></a>具体学习</h2><p><a href="https://www.runoob.com/linux/linux-comm-awk.html">awk学习</a></p><h1 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h1><p>由BSD UNIX的作者Bill Joy编写<br>分两种工作模式：命令模式、编辑模式。a、i、o、O命令进入编辑模式，ESC退出编辑模式。<br>在命令模式下，可使用所有的ed命令。</p><h1 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h1><h2 id="特殊管理"><a href="#特殊管理" class="headerlink" title="特殊管理"></a>特殊管理</h2><h3 id="超级用户"><a href="#超级用户" class="headerlink" title="超级用户"></a>超级用户</h3><p>此为Ubuntu特有的管理：<br>每个UNIX系统都有一个默认的用户root，该用户为管理员，具有不受限制的权限，通常称为“超级用户”。在进行操作系统配置时使用该用户登录。为了安全，一般情况下，不使用该用户登录。</p><ul><li>为了安全，Ubuntu Linux默认禁用root用户。使用sudo命令可以提升权限，只是有些麻烦。</li><li>当然，也可以使用su命令。临时转换为超级用户身份，此时shell提示符会给出超级用户的提升符#。<div class="note pink no-icon flat"><p>那么如何打开Root用户？</p></div><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo vi /etc/gdm/gdm.conf  //首先提升权限，再利用vi打开gdm.conf</span> </span><br></pre></td></tr></table></figure>1.将其中一行“AllowRoot=false”改为“AllowRoot=true”，就可以成功打开Root用户。<br>当然，如果是具有图形界面的Ubuntu Linux，可以通过主菜单“系统”-&gt;“系统管理”-&gt;“登录窗口”进入“登录窗口首选项”，在“安全”选项页中选中“允许本地系统管理员登录”。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo passwd root  //更改root用户口令</span></span><br></pre></td></tr></table></figure>重启系统即可完成更改。<h3 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h3>有些时候，软件源在国外，下载速度简直逆天，我们需要更改国内的软件源来加快速度。</li><li>/etc/apt/sources.list是一个文本文件，其中记录了用于系统升级的软件源地址。由于用户所在的网络环境的不同，这些地址可能不是最优的。</li><li>使用搜索引擎（如百度）搜索“Ubuntu 教育网 软件源”会搜索出很多合适的地址。</li><li>vi /etc/apt/sources.list   修改软件源地址</li><li>apt-get update   软件源生效，下载更新列表信息</li></ul><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>计算机要实现网络通信，就必须要有一个用于快速定位的网络地址。IP地址就是计算机在网络中的唯一身份ID，与现实世界中快递的配送需要有具体的住宅地址是一个道理。</p><p>ip地址以圆点分隔号的四个十进制数字表示，每个数字从0到255，如某一台主机的ip地址为：128.20.4.1</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><strong>IP地址 = 网络地址 + 主机地址</strong><br><div class="note orange no-icon flat"><p>这就引入了一个新的问题，如果不指定位数，我怎么知道哪几位是网络地址，哪几位是主机地址呢？这就需要子网掩码</p></div></p><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网掩码又叫网络掩码、地址掩码、子网络遮罩，是一个 4 * 8bit（1字节）由 0/1 组成的数字串。</p><p>它的作用是屏蔽（遮住）IP地址的一部分以划分成网络地址和主机地址两部分，并说明该IP地址是在局域网上，还是在远程网上。</p><p>通过子网掩码，可以把网络划分成子网，即VLSM（可变长子网掩码），也可以把小的网络归并成大的网络即超网。（了解）</p><p>子网掩码不能单独存在，它必须结合IP地址一起使用。（了解）</p><h3 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a>默认网关</h3><div class="note orange no-icon flat"><p>什么是网关?</p></div><p>连接两个不同的网络的设备都可以叫网关设备；网关的作用就是实现两个网络之间进行通讯与控制。</p><p>网关设备可以是 交互机（三层及以上才能跨网络）、路由器、启用了路由协议的服务器、代理服务器、防火墙等</p><p>网关地址就是网关设备的IP地址。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>来一张电子包浆的图：<br><img src="网关.png" alt="网关"><br>要实现这两个网络之间的通信，则必须通过网关。</p><p>如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机（如附图所示）。网络A向网络B转发数据包的过程。</p><h3 id="修改这三者"><a href="#修改这三者" class="headerlink" title="修改这三者"></a>修改这三者</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi /etc/network/interfaces</span></span><br></pre></td></tr></table></figure><p>打开后文本如下：<br>auto eth0<br>iface eth0 inet static   # or dhcp<br>address xxx.xxx.xxx.xxx<br>netmask xxx.xxx.xxx.xxx<br>gateway xxx.xxx.xxx.xxx<br>第一行的意思是：eth0接口会在系统启动时被自动配置；<br>第二行的意思是：eth0接口具有一个静态的（static）IP配置；<br>第三行到第六行分别设置设置eth0接口的ip、网络号、掩码、广播地址和网关；</p><h3 id="域名服务器DNS"><a href="#域名服务器DNS" class="headerlink" title="域名服务器DNS"></a>域名服务器DNS</h3><p>我们访问一个网站的时候，往往使用的是域名（相对IP来说更加语义清晰、更加容易记忆，例如 www.baidu.com)。</p><p>域名是由一串用点分隔的名字组成的，通常包含组织名，而且始终包括两到三个字母的后缀，以指明组织的类型或该域所在的国家或地区。</p><p>然而计算机之间的通信网络通信是通过IP进行的， 因此需要将域名解析为对应的IP，DNS就是进行域名解析的服务器。</p><p>DNS 维护着 域名(domain name)和IP地址 (IP address)的对照表表，以解析消息的域名。</p><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><p>如图展示了DNS的查询过程：<br><img src="DNS.png" alt="DNS"></p><h4 id="修改本地"><a href="#修改本地" class="headerlink" title="修改本地"></a>修改本地</h4><p>/etc/resolv.conf是DNS客户机配置文件，用于设置DNS服务器的IP地址及DNS域名，还包含了主机的域名搜索顺序。</p><p>该文件是由域名解析 器（resolver，一个根据主机名解析IP地址的库）使用的配置文件。它的格式很简单，每行以一个关键字开头，后接一个或多个由空格隔开的参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi /etc/resolv.conf //使用vi打开resolv.conf文件</span></span><br></pre></td></tr></table></figure><p>有如下内容：<br>Generated by NetworkManager<br>nameserver xxx.xxx.xxx.xxx   //add it<br>nameserver xxx.xxx.xxx.xxx</p><p>添加完毕后，可以使用：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/etc/init.d/networking restart</span></span><br></pre></td></tr></table></figure><br>来重启网络，使得配置生效。<br>可使用ifconfig,route等命令查看配置结果。</p><h2 id="网络应用"><a href="#网络应用" class="headerlink" title="网络应用"></a>网络应用</h2><h3 id="创建WebServer"><a href="#创建WebServer" class="headerlink" title="创建WebServer"></a>创建WebServer</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-get install apache2</span></span><br></pre></td></tr></table></figure><p>使用：<a href="http://xxx.xxx.xxx.xxx(Ubuntu">http://xxx.xxx.xxx.xxx(Ubuntu</a> Host IP Address) 来访问</p><h3 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">apt-get install samba</span></span><br></pre></td></tr></table></figure><p>建一个共享文件夹，设权限为777，在文件管理器中使用鼠标右键共享之。</p><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>UNIX是多用户类型的操作系统，其多用户特征通过多个用户帐号来体现。每个用户可以获得不同的权限和资源，完成不同类型的工作</p><h3 id="用户账号管理"><a href="#用户账号管理" class="headerlink" title="用户账号管理"></a>用户账号管理</h3><ul><li>命令 useradd、adduser、userdel、usermod、passwd</li><li>使用图形界面</li><li>增、删、改、查。</li><li>修改用户密码、权限。</li></ul><div class="note orange no-icon flat"><p>useradd和adduser有什么区别？</p></div><p>1.在root权限下，useradd只是创建了一个用户名，如 （useradd +用户名 ），它并没有在/home目录下创建同名文件夹，也没有创建密码，因此利用这个用户登录系统，是登录不了的，为了避免这样的情况出现，可以用 （useradd -m +用户名）的方式创建，它会在/home目录下创建同名文件夹，然后利用（ passwd + 用户名）为指定的用户名设置密码。</p><p>2.可以直接利用adduser创建新用户（adduser +用户名）这样在/home目录下会自动创建同名文件夹</p><h2 id="组管理"><a href="#组管理" class="headerlink" title="组管理"></a>组管理</h2><ul><li>命令 groupadd、addgroup、groupdel、groupmod、gpasswd</li><li>使用图形界面</li><li>增、删、改、查。</li><li>修改组权限、成员。</li></ul><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>磁盘包括软盘、光盘、硬盘。设备文件分别为：/dev/fd[01]（标准输入、输出）、/dev/hd[abcd]（IDE硬盘）、/dev/sd[abcd]（SCSI硬盘）、/dev/cdrom（光盘）</p><p>硬盘必须分区和格式化才可使用。硬盘分区后，每个分区对应的设备名为“硬盘设备名”[1256]，例如/dev/sda1代表第一块SCSI硬盘的第一个分区。</p><h3 id="硬盘分区"><a href="#硬盘分区" class="headerlink" title="硬盘分区"></a>硬盘分区</h3><p>一块硬盘最多可分4个分区，需要分更多的区时，可分一个扩展分区，然后将扩展分区再分为若干逻辑分区。<br>管理硬盘分区的命令为fdisk。<br>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">fdisk /dev/sdb    //对第二块SCSI硬盘进行分区管理</span></span><br></pre></td></tr></table></figure><br><div class="note green no-icon flat"><p>sd代表SCSI硬盘，b代表第二块。</p></div></p><h3 id="格式化分区（创建文件系统）"><a href="#格式化分区（创建文件系统）" class="headerlink" title="格式化分区（创建文件系统）"></a>格式化分区（创建文件系统）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mkfs  分区名              //分区名：如/dev/sdb1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mkfs -t 文件格式 分区名   //指定文件格式，默认文件格式为ext2</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mount  分区名  路径       //将某硬盘分区挂载到某个目录下，通常该目录为空目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">umount  分区名或路径      //将某硬盘分区和挂载点脱钩</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">df</span>                       //查看分区挂载情况</span></span><br></pre></td></tr></table></figure><div class="note purple no-icon flat"><p>这里用#不是用$是因为这些命令只能在超级用户下进行</p></div><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><p>进程：简单地说，就是一个正在运行的程序。（很不精确的说法）<br>进程包括系统核心进程、系统服务进程和普通用户进程<br>进程可强制结束</p><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps             //查看当前终端启动的进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -t  终端名  //显示某个终端启动的进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -u 用户名   //显示某个用户启动的进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -e         //显示所有进程</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps -f         //显示进程完整信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ps –ef |grep <span class="string">&#x27;pattern&#x27;</span> //显示你想看到的进程</span></span><br></pre></td></tr></table></figure><h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><p>kill命令语法 kill [-signal] pid<br>用来给一个进程发信号，但常用的功能是结束某个进程（发一个可以结束某个进程的信号）。<br>kill -l  //列出可用的信号选项<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -2 pid</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -14 pid</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">kill</span> -9 pid</span>         </span><br></pre></td></tr></table></figure><br><div class="note purple no-icon flat"><p>在这里需要注意的是，并不是所有的负数都可以kill掉进程，有些负数可以被用作他用，但-9是一定可以杀死进程的，这个信号无法被用作他用。</p></div></p>]]></content>
      
      
      <categories>
          
          <category> Unix &amp; Linux 系统学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆留存 </tag>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System Verilog语法记录</title>
      <link href="/posts/23273/"/>
      <url>/posts/23273/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>System Verilog作为Verilog HDL的升级，对于我们开发FPGA是有非常大的帮助的，可以大大减轻码量，减少错误的产生。</p><p>由于龙芯杯的缘故，我们小组在商议后决定使用System Verilog来开发CPU，所以在此重拾计组，学习System Verilog并记录，方便后续翻看和为后来人抛砖引玉。<br><blockquote><p>TIPS:学习这篇博客需要默认会Verilog HDL</p></blockquote></p><h1 id="logic"><a href="#logic" class="headerlink" title="logic"></a>logic</h1><p>对verilog的初学者来说，我们常常面临两种数据类型的选择——wire和reg，也常常纠结于在特定情况下选择哪一种数据类型比较合适的问题。</p><p>并且reg变量好像暗指用时序逻辑的触发器搭建的硬件“寄存器”，然而实际上，reg变量跟推断出的硬件没有任何关系,这种不一致也常常有着误导作用。</p><p>System Verilog使用更直观的logic关键字来描述通用的针对硬件的数据类型。我们将会看到你可以在过去verilog中用reg型或是wire型的地方用logic型来代替。编译器可自动推断logic是reg还是wire。</p><p>即logic是对reg，wire数据类型的改进，使得它除了作为一个变量之外，还可以被连续赋值、门单元和模块所驱动，显然，logic是一个更合适的名字。</p><p>但以上的等同是在单驱动的情况下，因为logic只允许一个输入,wire则无此限制。所以如果是多驱动的情况下，logic和wire就不等同了。</p><p style="color: #FF0000;">省流:你可以简单认为logic是Verilog中wire和reg的平替。</p><h1 id="新状态"><a href="#新状态" class="headerlink" title="新状态"></a>新状态</h1><p>两态:0和1.<br>四态:0，1，x和z.<br>在Verilog中，所有的变量和数据类型都是四态。<br>在System Verilog中，则作出了区分。<br>四态的变量或数据类型可以接受两态的变量或数据类型。<br>两态的变量或数据类型也可以接受四态的变量或数据类型，只不过x,z会变为0.</p><h1 id="新变量"><a href="#新变量" class="headerlink" title="新变量"></a>新变量</h1><p>bit——1位两态整数。<br>byte——8位两态整数，类似于C语言的char。<br>shortint——16位两态整数，类似于C语言的short。<br>int——32位两态整数，类似于C语言的int。<br>longint——64位两态整数，类似于C语言的longlong。</p><h1 id="always"><a href="#always" class="headerlink" title="always"></a>always</h1><p>在旧版本的Verilog中只有一个通用的always过程块，System Verilog中追加了三个具有更明确目的专用always块：always_ff, always_comb, always_latch.<br>与原始的always块一样，这三个新的东西也是无限循环过程块,即每一个仿真周期都执行。<br><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>那可能就有小问号要问了? 这System Verilog开发者是不是在梦游，这不多此一举吗？</p></div><br>那当然是有合理性的，三个新的always块是专门针对可综合性RTL逻辑建模而定义的：<br>always_comb用于可综合组合逻辑的建模<br>always_ff用于可综合时序逻辑的建模<br>always_latch用于锁存器的建模<br>这样从名字就可以清楚地知道设计者的设计意图。人和各种EDA工具都可以更准确地理解代码并作出正确而相互一致的判断。从而编译器可以根据你的always块的不同帮你判断是否存在一些问题。比如在always_comb里面失误被编译出了锁存器，这是为了你硬件设计少出问题的考虑。</p><p style="color: #FF0000;">省流:你可以简单认为always_comb是always @(*)的平替，always_ff @(posedge clk)是always @(posedge clk)的平替</p><h1 id="改进的case语句"><a href="#改进的case语句" class="headerlink" title="改进的case语句"></a>改进的case语句</h1><p>Verilog的case语句允许在多个选项中选择一个逻辑分支。<br>在System Verilog中，我们当然可以继续使用case语句，但是这里也引入了两种新的case语句：<br>unique case和priority case。</p><h2 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h2><p>该语句指定：<br>1.只有一个条件选项与条件表达式匹配。<br>2.必须有一个条件选项与条件表达式匹配。<br><div class="note warning flat"><p>这并不意味着我们不再需要default语句，相反，由于在复杂工程下我们很可能忘掉某些条件选项，所以default反而是必须的。这也同时为了防止锁存器的出现。</p></div><br>在这种语句下，每一个选项可以被并行执行判断，极大的提高了判断的效率。（简直是卷性能必备x）</p><h2 id="priority"><a href="#priority" class="headerlink" title="priority"></a>priority</h2><p>该语句指定：<br>1.至少有一个条件选项的值与条件表达式匹配。<br>2.如果有多个条件选项的值与条件表达式匹配，必须执行第一个匹配分支。<br>写法方面，由于这个和一般的case有所区别，所以给出样例：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always_comb</span></span><br><span class="line">    <span class="keyword">priority</span> <span class="keyword">case</span> (<span class="number">1&#x27;b1</span>)</span><br><span class="line">        irq0: irq = <span class="number">4&#x27;b0001</span>;</span><br><span class="line">        irq1: irq = <span class="number">4&#x27;b0010</span>;</span><br><span class="line">        irq2: irq = <span class="number">4&#x27;b0100</span>;</span><br><span class="line">        irq3: irq = <span class="number">4&#x27;b1000</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br></pre></td></tr></table></figure> <p>可以看出，常量取代了原来case中变量的位置，反而是变量取代了case中常量的位置。<br>这个可以取代对一个变量进行if,else if,else if,else的判断过程，（同样是卷性能必备x）</p><h1 id="全面C语言化"><a href="#全面C语言化" class="headerlink" title="全面C语言化"></a>全面C语言化</h1><p>System Verilog加入了很多十分类C的语句：</p><h2 id="break"><a href="#break" class="headerlink" title="break"></a>break</h2><p>类似于C语言,会立即终止循环的执行。</p><h2 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h2><p>类似于C语言,会跳转到循环的结尾然后执行循环控制。</p><h2 id="return"><a href="#return" class="headerlink" title="return"></a>return</h2><p>类似于C语言,用来从非空函数返回或从空函数或任务中跳出。</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>System Verilog新增内容<br>基本格式为： typedef 已有类型 新类型<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span>[<span class="number">31</span>:<span class="number">0</span>] word_t;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">logic</span>[<span class="number">31</span>:<span class="number">0</span>] entry_t;</span><br><span class="line"><span class="keyword">typedef</span> entey_t[<span class="number">31</span>:<span class="number">0</span>] table_t; <span class="comment">//数组来了</span></span><br></pre></td></tr></table></figure></p><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>System Verilog新增内容<br>结构体struct可以描述一组相关的数据。<br>以译码器为例，按以前Verilog写法，可能需要这样写：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] alufunc;</span><br><span class="line"><span class="keyword">logic</span> mem_read;</span><br><span class="line"><span class="keyword">logic</span> mem_write;</span><br><span class="line"><span class="keyword">logic</span> regwrite;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">6</span>:<span class="number">0</span>] control;</span><br><span class="line"><span class="keyword">assign</span> control = &#123;alufunc,mem_read,mem_write,regwrite&#125;;</span><br></pre></td></tr></table></figure><br>在System Verilog中，利用Struct我们可以这样写：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] alufunc;</span><br><span class="line">    <span class="keyword">logic</span> mem_read;</span><br><span class="line">    <span class="keyword">logic</span> mem_write;</span><br><span class="line">    <span class="keyword">logic</span> regwrite;</span><br><span class="line">&#125; control_t;</span><br><span class="line"></span><br><span class="line">control_t control = &#x27;&#123;<span class="number">4&#x27;b1111</span>,<span class="number">1&#x27;b0</span>,<span class="number">1&#x27;b1</span>,<span class="number">1&#x27;b1</span>&#125;; <span class="comment">//赋值</span></span><br><span class="line">control_t control = &#x27;&#123;alufenc : <span class="number">4&#x27;b1111</span>,mem_read : <span class="number">1&#x27;b0</span>, mem_write: <span class="number">1&#x27;b1</span>,regwrite : <span class="number">1&#x27;b1</span>&#125;; <span class="comment">//另一种赋值</span></span><br><span class="line"><span class="keyword">logic</span> regwrite;</span><br><span class="line"><span class="keyword">assign</span> regwrite = control<span class="variable">.regwrite</span>; <span class="comment">//使用</span></span><br></pre></td></tr></table></figure><br>从上面例子我们需要注意，System Verilog使用’{}符号包含数值列表，与{}拼接符作出区分。<br>第一种赋值方法需要我们按照结构体中元素定义顺序进行赋值，第二种则随意。</p><p>如果不用typedef进行包装struct，在System Verilog中则认为生成了一个这样的结构体变量，而不是定义。</p><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><p>System Verilog新增内容<br>枚举类型用来帮助编码<br>以状态机为例，按以前Verilog写法，可能需要这样写：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">define</span> start 4&#x27;d1</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> add 4&#x27;d2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> (State)</span><br><span class="line">    start: <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    add: <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure><br>在System Verilog中，我们可以利用enum这样写：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] &#123;</span><br><span class="line">    start,add</span><br><span class="line">&#125; State;</span><br><span class="line"></span><br><span class="line">State state;</span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">    start: <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    add: <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure><br>enum类型的变量，赋值时只能用枚举项,枚举项名字不能相同。<br>enum类型定义时，如果不显示说明某一枚举项的值，则会从上到下从左到右对应0，1，2，3….<br><div class="note primary flat"><p>enum类型的变量，在Vivado仿真里会显示枚举项，比看magic number强多了。（debug必备啊）</p></div></p><h2 id="union"><a href="#union" class="headerlink" title="union"></a>union</h2><p>System Verilog新增内容<br>用于多周期处理器，节省空间<br>但我个人感觉不管是在C还是在System Verilog里面，它都挺没存在感的。<br>使用方法样例：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">        <span class="keyword">logic</span> zero;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] aluout;</span><br><span class="line">    &#125; alu;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">        <span class="keyword">logic</span> branch_taken;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] pcbranch;</span><br><span class="line">    &#125; branch;</span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">        <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr;</span><br><span class="line">        <span class="keyword">logic</span> mem_read;</span><br><span class="line">    &#125; memory;</span><br><span class="line">&#125; result_t;</span><br><span class="line"></span><br><span class="line">result_t res;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr,aluout;</span><br><span class="line"><span class="keyword">assign</span> addr = res<span class="variable">.memory</span><span class="variable">.addrl</span> <span class="comment">//assign addr = res[32:1];</span></span><br><span class="line"><span class="keyword">assign</span> aluout = res<span class="variable">.alu</span><span class="variable">.aluout</span> <span class="comment">//assign aluout = res[31:0];</span></span><br></pre></td></tr></table></figure><br>需要注意的是，对每个Union里面的元素，必须要求位宽相同，这就是为什么在结构体alu里面我会补一个logic zero的原因。<br>对union类型的变量进行赋值时，要注意多驱动，因为赋值的可能是同一位。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>System Verilog还有很多很多零碎而又强大的功能提升，笔者以上所写为常用到的语法内容，更多的还请自行查阅，因为笔者也不会QAQ.当然,如果后面有好用的我还会更新的~</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《SystemVerilog 硬件设计及建模》，北航图书馆就有，不过目前都在我们小组手上（逃<br><a href="https://www.bilibili.com/video/BV1XA41177of?p=12&amp;vd_source=ad41fc34282c1cadb72db3b9627f64c7">bilibili大学</a></p>]]></content>
      
      
      <categories>
          
          <category> 龙芯 NSCSCC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 记忆留存 </tag>
            
            <tag> 语言学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lab0实验报告</title>
      <link href="/posts/37212/"/>
      <url>/posts/37212/</url>
      
        <content type="html"><![CDATA[<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="Thinking-0-1"><a href="#Thinking-0-1" class="headerlink" title="Thinking 0.1"></a>Thinking 0.1</h3><p>首先陈述结论，执行cat Modified.txt的结果和第一次执行add命令之前的status不一样:  </p><p>执行Untracked:  </p><p><img src="Untracked.png" alt="1"><br>执行Modified:   </p><p><img src="Modified.png" alt="2"><br>在第一次执行add命令之前，README.txt刚刚被创建，我们并没有输入任何有关于它的git指令，因而它处于未跟踪状态。所以它会出现在未跟踪的文件一栏。<br>在经历过对其进行的种种操作后，README.txt处于已经被跟踪但修改还未暂存的阶段，所以它会出现在尚未暂存以备提交的变更一栏。</p><h3 id="Thinking-0-2"><a href="#Thinking-0-2" class="headerlink" title="Thinking 0.2"></a>Thinking 0.2</h3><p>Add The File: git add 文件名    </p><p>Stage The File:git add 文件名   </p><p>commit:git commit -m “message”  </p><h3 id="Thinking-0-3"><a href="#Thinking-0-3" class="headerlink" title="Thinking 0.3"></a>Thinking 0.3</h3><p>1.代码文件 print.c 被错误删除时，应当使用什么命令将其恢复？     </p><p>答：使用git checkout — print.c     </p><p>2.代码文件 print.c 被错误删除后，执行了 git rm print.c 命令，此时应当使用什么命令将其恢复？<br>答：使用 git reset HEAD print.c 和 git checkout — print.c      </p><p>3.无关文件 hello.txt 已经被添加到暂存区时，如何在不删除此文件的前提下将其移出暂存区？   </p><p>答：git rm —cached hello.txt   </p><h3 id="Thinking-0-4"><a href="#Thinking-0-4" class="headerlink" title="Thinking 0.4"></a>Thinking 0.4</h3><p>1.提交三次后，提交说明为3的哈希值和提交日志如下：   </p><p><img src="提交三次.png" alt="1"><br>2.执行git reset —hard HEAD^后提交日志如下：    </p><p><img src="回退一次.png" alt="2"><br>会发现第三次提交的提交日志消失了，这是由于目前处于第二次提交的版本阶段。    </p><p>3.执行git reset —hard hash 回到第一次提交的版本，这里的哈希值为第一次提交的哈希值，提交日志如下：  </p><p><img src="第一次提交.png" alt="3"><br>会发现提交日志只剩下了第一次提交，这是由于目前处于第一次提交的版本阶段。    </p><p>4.执行git reset —hard hash 回到最新的版本，这里的哈希值为之前记录下的提交说明为3的哈希值。提交日志如下：   </p><p><img src="提交三次.png" alt="4"><br>会发现提交日志回到和最初的样子。这是由于目前处于最新提交的版本阶段。    </p><h3 id="Thinking-0-5"><a href="#Thinking-0-5" class="headerlink" title="Thinking 0.5"></a>Thinking 0.5</h3><p>1.执行echo first 效果如下：     </p><p><img src="第一条指令.png" alt="1"><br>first直接输出在了shell上。      </p><p>2.执行echo second &gt; output.txt效果如下：    </p><p><img src="第二条指令.png" alt="2"><br>使用vim output.txt打开文件发现,second被重定向输出到了output.txt中<br>3.执行echo third &gt; output.txt效果如下：     </p><p><img src="第三条指令0.png" alt="3"><br>使用vim output.txt打开文件发现，third被重定向输出到了output.txt中，之前的second不见了，这是由于使用“&gt;”输出内容会直接重写文件。<br>4.执行echo forth &gt;&gt; output.txt效果如下：        </p><p><img src="第四条指令.png" alt="4"><br>使用vim output.txt打开文件发现，forth被重定向输出到了output.txt中，之前的third仍然存在，这是由于使用“&gt;&gt;”输出内容会将内容追加到文件末尾。        </p><h3 id="Thinking-0-6"><a href="#Thinking-0-6" class="headerlink" title="Thinking 0.6"></a>Thinking 0.6</h3><p>command文件内容如下：       </p><p><img src="command内容.png" alt="1"><br>采用脚本创建test文件    </p><p>result文件内容如下：        </p><p><img src="result内容.png" alt="2"><br>test文件内容如下：      </p><p><img src="test内容.png" alt="3"></p><h4 id="解释说明："><a href="#解释说明：" class="headerlink" title="解释说明："></a>解释说明：</h4><p>command生成了用来生成result文件的命令序列test   </p><p>test生成了result文件    </p><p>将test作为批处理文件后，test成为了一个shell脚本，其内容会按shell语法被系统所理解，其中定义了三个变量，a,b的值均直接赋值，分别为1，2，c的值由a,b加和得到。echo后面跟着指令，且没有用’’包裹时，会展开命令并运行。所以之后执行了$c&gt;file1,$b&gt;file2,$a&gt;file3指令，将a,b,c的值分别保存在了file1,file2,file3中，之后又用cat指令取出这三个文件的内容，即a,b,c的值，追加到了result的末尾。最终得到了result文件。</p><h4 id="效果区别"><a href="#效果区别" class="headerlink" title="效果区别"></a>效果区别</h4><p><img src="区别.png" alt="4"><br>使用单引号时(‘’)时，将保留引号中包含的每个字符的字面值。变量和命令将不会展开。</p><h2 id="难点分析"><a href="#难点分析" class="headerlink" title="难点分析"></a>难点分析</h2><p><img src="难点分析.png" alt="5"><br>lao0整体下来的一个感觉就是知识点多而杂，还有就是对一切新事物的不熟悉与不适应，接下来需要在不断使用中建立记忆，熟能生巧。    </p><p>其次本人总觉得makefile在shell脚本上功能总是有着重合的一部分，查阅了一圈互联网，可能makefile更注重生成目标文件这块吧，他可以自动选择编译修改过的文件比shell更加适合编译或者生成文件。而shell则是可以自动化万物。</p><h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux:"></a>Linux:</h3><p>从小到大一直听过的一个概念，也在上学期和寒假尝试做龙芯杯任务时一直被灌输Linux的交叉编译和仿真速度快。也尝试使用过Linux，但直接被wsl2的Liunx系统完完全全的shell界面所劝退。在这学期竟然不得不使用Linux，在入门之后确实能体会到Linux给程序员带来的效率提升。也终于理解了为什么一个连图形界面都不是必须有的系统可以流行这么久的原因。</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git:"></a>Git:</h3><p>在上学期OO Pre时候初步使用，寒假搭建github博客时进一步使用，在OS上得到了较为系统的学习，逐渐理解了之前自己一直在机械执行的命令的意义，印象更加深刻。也深深反思了为什么备份博客的时候不用Git…..<br><img src="博客.png" alt="3"></p><h3 id="Shell脚本和Makefile"><a href="#Shell脚本和Makefile" class="headerlink" title="Shell脚本和Makefile"></a>Shell脚本和Makefile</h3><p>作为提升工作效率的程序，在作业中深深体会到了它们的强大与方便，也进一步体会到了用Liunx的快乐。</p><h3 id="Sed，Awk与Grep"><a href="#Sed，Awk与Grep" class="headerlink" title="Sed，Awk与Grep"></a>Sed，Awk与Grep</h3><p>作为Linux操作文本的三剑客，只能说方便是方便，但对于我来说仍然需要一些时间去理解，接下来会自己做一些练习加深对它们的理解。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>lab0正如其名，是实验的开始，也是实验的Pre，只有掌握好lab0所学，我们才能顺畅的使用Linux做我们的操作系统实验，才能为后面的学习打下坚实的基础。笔者接下来也会自己上网了解更多相关内容，尽快适应Linux的使用。</p>]]></content>
      
      
      <categories>
          
          <category> 北航操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS学习 </tag>
            
            <tag> 记忆留存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPU扩展设计--AXI总线接口实现</title>
      <link href="/posts/14266/"/>
      <url>/posts/14266/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="同步-异步读介绍"><a href="#同步-异步读介绍" class="headerlink" title="同步/异步读介绍"></a>同步/异步读介绍</h2><blockquote><p>《CPU设计实战》有这样一句话：在大多数真实的计算机系统中,CPU通过总线与系统中的内存、外设进行交互,没有总线,CPU就是个“光杆司令”,什么工作也做不了。</p></blockquote><p>也因此，我们需要在CPU上设计总线接口，让我们的CPU能与总线进行交互，不再是孤岛。  </p><p style="color: #FF0000;">还记得我们在P3-P7设计的取指和取值吗？</p><p>我们的地址在本周期发出，指令或者值便可以在本周期取回。这是一种<i>异步读</i>。这种设计现在看来大大帮助我们减轻了CPU设计的负担，但是所谓凡事皆有利弊，这种设计也在另一方面加剧了FPGA板子资源的消耗。  </p><p>FPGA板子上有各种IP核（固化好的Ram资源等），如果我们这样设计，我们的CPU将不能利用这些高速资源，而是会用触发器层层叠搭，搭出一个异步读的Ram,这种方式导致了资源的浪费和速度的降低。    </p><p>这些IP核的读取都是<i>同步读</i>，即地址在本周期发出，数据返回在下一周期或者更后面的某一周期。</p><h2 id="Sram接口"><a href="#Sram接口" class="headerlink" title="Sram接口"></a>Sram接口</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>也因此，我们在P8进行板级验证的时候，不得不对我们的CPU做出修改，实现了当时不知道名字，现在知道它叫Sram接口的一种总线接口。   </p><p>这种接口表现为CPU地址本周期发出，数据一定在下一周期返回。这种接口使得我们可以利用FPGA上的IP核，节省了资源，提速了CPU，让我们得以完成板级验证。  </p><p>这种接口设计也较为简单。适合我们进行计组学习。</p><p style="color: #0000FF;"><del>当时不觉得</del></p>    <h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>我们需要考虑这样一个问题，CPU的运算速度是远远高于RAM的读取速度的，如果采用Sram接口我们需要考虑一个问题：</p><p style="color: #FF00FF;">我们的每个周期时长要怎么设计才能保证数据一定在发出地址的下一周期返回呢？</p> <p>显然，我们的CPU周期需要大于等于RAM的读取周期。但绝大多数情况下，CPU的运算是远远快于RAM的，所以采用这种接口，我们速度就直接受限于RAM的速度。也因此，我们需要寻求一种新的总线接口，让CPU的周期与RAM的周期脱钩，读取一次数据需要多个周期才能返回，让CPU飞起来————AXI总线接口</p><h1 id="AXI设计"><a href="#AXI设计" class="headerlink" title="AXI设计"></a>AXI设计</h1><h2 id="学习策略"><a href="#学习策略" class="headerlink" title="学习策略"></a>学习策略</h2><p>在《CPU设计实战》中，有相关的学习章节，但是笔者认为设计实战这本书忽视了很多细节上的东西，这也是笔者写这篇博客的初心，笔者将重点讲一些设计细节。 </p><p>大家利用《CPU设计实战》辅以本篇博客学习就好。</p><p><a href="https://pan.baidu.com/s/1fT7P4KpxFxTDesbLHxSVFQ?pwd=k79h">《CPU设计实战》分享</a><br>提取码：k79h </p><h2 id="方法选择"><a href="#方法选择" class="headerlink" title="方法选择"></a>方法选择</h2><p>设计AXI总线接口我们有两条路可走：   </p><p style="color: #0000FF;">1.改造CPU的SRAM接口为类SRAM接口，之后搭建类Sram转AXI的转接桥，与CPU一起封装，使得CPU在外观上表现为AXI接口</p>   <p style="color: #FF00FF;">2.直接设计CPU的AXI接口</p><p>考虑到直接设计AXI还是比较有难度的，毕竟这种协议已经是比较新的协议了QAQ。所以笔者采用了第一种，先加深一下对AXI的理解，后续有时间再选择方法2。(挖坑√)</p><h2 id="类Sram设计"><a href="#类Sram设计" class="headerlink" title="类Sram设计"></a>类Sram设计</h2><h3 id="握手机制"><a href="#握手机制" class="headerlink" title="握手机制"></a>握手机制</h3><p>还是前面那句话，凡事皆有利弊，一旦CPU的周期和RAM的周期脱钩，那么每次我们向RAM请求读取数据时，数据的返回时刻就已经不再是固定在几周期后，而是随机的了，那RAM怎么知道哪一个周期的地址是有效的呢？或者说CPU怎么才能知道数据什么时候返回呢？这就需要master(CPU端)与slave(RAM端)互相握手，在地址传递过来的时候，和RAM握个手，告诉RAM当前地址有效。在数据传过来的时候，和CPU握个手,告诉CPU当前周期数据有效。</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p><img src="https://s1.ax1x.com/2023/02/11/pS4hjPS.png" alt="信号"></p><p>我们对比一下Sram信号：  </p><p><img src="Sram信号.png" alt="SRAM信号"></p><p>我们发现信号其实大差不差，多出来的信号就是由于握手机制的引入。一次读写一共握手两次。我们解释一下req,size,addr_ok,data_ok信号：    </p><p>size:来源于AXI总线协议，功能在信号中已经提到，我们不提，我们说一下为什么这个信号会引入，这其实是为了方便AXI的设计，在AXI的设计中，有arsize和awsize信号，我们生成size信号是为了方便生成这两个信号。</p><p>req:来源于握手机制，master向slave端传递，传递本周期地址信号有效的信息。表示需要对该地址进行取值。</p><p>addr_ok:来源于握手机制，slave向master端传递，用于和req信号一起完成读写请求的握手。表示slave端已经收到正确的addr。</p><p>data_ok:来源于握手机制，slave向master端传递，有两种含义，在读RAM中这个信号有效保证当前周期读出的数据有效。在写RAM中表示写入完成。</p><p style="color: #0000FF;">以上解释只解释了一次握手，为req和addr_ok的握手，那另一个握手在哪呢？</p> <blockquote><p>其实是与data_ok相关的一个握手，大家想一想，slave向master发出信号(addr_ok)说当前数据有效，讲道理master是不是也应该给slave发出一个信号表示数据收到？但在类sram接口中，我们认为master是时刻准备好接受信号的,所以一旦addr_ok有效，master端（CPU端)就会将数据存起来。也因此这个握手就不需要了。不过你也可以认为这是一个隐形的握手，只不过matser一直在伸手，只等slave伸手（addr_ok）</p></blockquote><h3 id="读写时序"><a href="#读写时序" class="headerlink" title="读写时序"></a>读写时序</h3><p>读RAM时序：<br><img src="类SRAM读.png" alt="SRAM读时序"></p><p>写RAM时序：<br><img src="类SRAM写.png" alt="SRAM写时序"></p><p>可以结合一下各个信号的功能进行理解。尤其是Req,Addr_ok,Data_ok。</p><h3 id="设计细节"><a href="#设计细节" class="headerlink" title="设计细节"></a>设计细节</h3><h4 id="多重读写干扰"><a href="#多重读写干扰" class="headerlink" title="多重读写干扰"></a>多重读写干扰</h4><p>既然读写需要多周期完成，那么在一次读或写的中途，是否可以又来一个读写请求呢？当然是可以的：  </p><p>在写中读：<br><img src="连续写读.png" alt="连续写读">   </p><p>在读中写：<br><img src="连续读写.png" alt="连续读写"></p><p>也就是说，在这种接口的情况下，可能会出现这样的序列：<br>$$({\rm{re}}q1\& addr\_ok1) \to ({\rm{re}}q2\& addr\_ok2) \to (req3\& addr\_ok3) \to ..... \to data\_ok1$$</p><p><p style="color: #0000FF;">那有人就要问了，这么复杂？中间有多少个序列都是不确定的，那怎么写?</p><br>遇事不决摆大烂，这是我的回答，我们直接拒绝这种情况的发生，我们可以引入一个Undone信号，在一次读取的addr_ok直至data_ok之中，使其一直有效，然后利用它表示一次读写还没有完成。那么只要没有完成，我们就统统拒绝新请求，这是不是得到了解决?   </p><p>当然,你也可以去写相关逻辑去实现多重读写，但或许我们需要考虑投入与产出，也就是性价比。</p><h4 id="取值取值干扰"><a href="#取值取值干扰" class="headerlink" title="取值取值干扰"></a>取值取值干扰</h4><p>在Sram接口中，取值和取指是两套接口，为了便于完成Sram接口到类Sram接口的转化，所以我们也分别改造这两套接口为两套类Sram接口：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//inst sram-like </span></span><br><span class="line"><span class="keyword">input</span>         inst_req     ,</span><br><span class="line"><span class="keyword">input</span>         inst_wr      ,</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">1</span> :<span class="number">0</span>] inst_size    ,</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] inst_addr    ,</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] inst_wdata   ,</span><br><span class="line"><span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] inst_rdata   ,</span><br><span class="line"><span class="keyword">output</span>        inst_addr_ok ,</span><br><span class="line"><span class="keyword">output</span>        inst_data_ok ,</span><br><span class="line"></span><br><span class="line"><span class="comment">//data sram-like </span></span><br><span class="line"><span class="keyword">input</span>         data_req     ,</span><br><span class="line"><span class="keyword">input</span>         data_wr      ,</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">1</span> :<span class="number">0</span>] data_size    ,</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] data_addr    ,</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] data_wdata   ,</span><br><span class="line"><span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] data_rdata   ,</span><br><span class="line"><span class="keyword">output</span>        data_addr_ok ,</span><br><span class="line"><span class="keyword">output</span>        data_data_ok ,</span><br></pre></td></tr></table></figure> <p>但是在AXI总线中，这两套接口将公用一套接口（后续会讲到），所以如果一套接口的Undone阶段，另一套接口也发起了请求，那么在AXI公用的接口上，就可能（注意是可能）会表现出前一细节所提到的多重读写问题，所以我们需要同样利用两套接口的Undone信号避免出现多重读写。                       </p><h4 id="CPU运行逻辑"><a href="#CPU运行逻辑" class="headerlink" title="CPU运行逻辑"></a>CPU运行逻辑</h4><h5 id="取指未完成"><a href="#取指未完成" class="headerlink" title="取指未完成"></a>取指未完成</h5><p>在这种情况下，显然CPU是无法工作的，但是D级及以后的已经取好的指令是可以正常工作的，这是不是很像我们之前实现的暂停？</p><p>是的，我们正是要实现这种暂停。但是如果我们只是简单的将其加入暂停信号。也不是不行，但我们可以想想，这种暂停意味着：  </p><blockquote><p>在IF级的PC等待接口取回指令，取好后一起送到ID级运行。这是不是就是我们P7之前的实现方法，在逻辑上等同于异步读，或者换句话说，逻辑上等同与在IF_ID级加回了我们已经短接的ID_Instr这个流水线寄存器。这样是可以正常跑的，但是会带来效率问题：</p></blockquote><p>如果性能拉满，即当周期发出请求，当周期提示addr_ok，下周期返回data_ok，相当于Sram取指，那么这种ID_Instr寄存器会导致必定暂停一周期。这是我们需要考虑的点。</p><p>所以为了避免这种潜在的效率浪费，我们可以实现这种特殊的暂停（也是我个人的实现方法）：</p><blockquote><p>设置两个暂停信号，ID_Addr_Stall和ID_Data_Stall。控制不同部件的暂停。ID_Addr_Stall无效（即不暂停）对应取指地址Ok（Addr_ok有效)，在这种情况下，将IF的地址送到ID级。<br>ID_Data_Stall无效（即不暂停）对应取指地址Ok（Data_ok有效)。在这种情况下，将IF的指令送到ID级。<br>ID集齐正确的PC与指令，直接发车。<br>这两个暂停共同构成了IF阶段的暂停。这种异步方式可以保证性能拉满的情况下不会暂停一周期。</p></blockquote><h5 id="取值未完成"><a href="#取值未完成" class="headerlink" title="取值未完成"></a>取值未完成</h5><p>与取指令实现思路类似。但暂停是一种更为特殊的暂停，我愿意称其为冻结。一旦进入取值的Undone状态，整个CPU都会被冻结，所有流水级都将停止流水。毕竟，MEM级已经被卡住了，总不能让后面的跑上来吧。  </p><p>这里本来是有一个细节的，就是假如不考虑取值和取指的相互影响，那么在取值的Undone状态，取指的请求也可能在Undone之前已经发出，数据在Undone之中返回，那么我们就需要一个寄存器将其存在D级当中，等待冻结结束和D级PC一起发车。但如果我们设计了取值和取指的相互影响。这个也就不存在了。取值一定不取指。取指一定不取值。</p><h4 id="跳转处理"><a href="#跳转处理" class="headerlink" title="跳转处理"></a>跳转处理</h4><p>考虑这么一种情况：<br>由于IF取指要多周期，而一旦ID级集齐了PC和指令，ID就会发车,那么这个跳转信号只会持续一周期。那么就极有可能产生当IF读取下一地址时。由于ID级已经不是跳转指令导致了IF错误读取PC+4。<br><blockquote><p>因此我们需要在ID阶段设计一个寄存器保存每一次跳转指令的目标PC值。并保存一个标记信号。一旦有跳转产生，就将信号置为有效。直到确认addr_ok读取到了这个保存的PC值。再将其置为无效。等待下一跳转指令。</p></blockquote></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset) <span class="keyword">begin</span></span><br><span class="line">        Memory_BJ_Sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        Memory_BJ_Addr &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(D_is_JAB) <span class="keyword">begin</span></span><br><span class="line">        Memory_BJ_Sign &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        Memory_BJ_Addr &lt;= NPC;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(F_PC_Real == Memory_BJ_Addr) <span class="keyword">begin</span></span><br><span class="line">        Memory_BJ_Sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure> <h4 id="异常中断处理"><a href="#异常中断处理" class="headerlink" title="异常中断处理"></a>异常中断处理</h4><h5 id="取指未完成-1"><a href="#取指未完成-1" class="headerlink" title="取指未完成"></a>取指未完成</h5><p>由于在我们的设计中，取指暂停的只是IF级。ID级之后是可以正常运行的，所以很有可能出现在取指的Undone阶段，MEM的CP0读取到了异常/中断。那么我们需要手动丢弃这一次的取指，因为由精确控制我们知道，我们认为MEM之前的指令都未发生，MEM之后的指令都已经完成。</p><blockquote><p>为了解决这个问题，我在ID_Instr上新增了一层逻辑，称为ID_Instr_Real。并引入一个新的信号Sram_clear_sign。该信号在Req（异常信号）信号有效时根据Undone是否有效决定自身的有效状态。并保持状态。直到IF取出指令。我们利用该信号在ID_Instr_Real上做三目运算。如果Sram_clear_sign有效，我们就传空泡（Nop），掩盖住ID_Instr的真实值。</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(reset) <span class="keyword">begin</span></span><br><span class="line">        Delay_Stall_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">Delay_Req_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        ID_Instr_MEM &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">        Sram_Clear_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(Req) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(inst_Undone || inst_addr_ok) <span class="keyword">begin</span></span><br><span class="line">            Sram_Clear_sign &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        Delay_Stall_sign &lt;= Delay_Stall_sign;</span><br><span class="line">Delay_Req_sign &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        ID_Instr_MEM &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Stall_sign)  <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(Delay_Stall_sign) <span class="keyword">begin</span></span><br><span class="line">ID_Instr_MEM &lt;=  ID_Instr_MEM; </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">ID_Instr_MEM &lt;= ID_Instr_Real;  </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">        Delay_Stall_sign &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        Delay_Stall_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">Delay_Req_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span>(inst_data_ok) <span class="keyword">begin</span></span><br><span class="line">        Sram_Clear_sign &lt;=<span class="number">1&#x27;b0</span>;</span><br><span class="line">        ID_Instr_MEM &lt;= ID_Instr_Wire; </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> ID_Instr_Real =  (F_PC == <span class="number">32&#x27;hBFC0_0000</span> || Delay_Req_sign || Sram_Clear_sign || ID_PC[<span class="number">1</span>:<span class="number">0</span>]!=<span class="number">2&#x27;b0</span>) ? <span class="number">32&#x27;d0</span> :</span><br><span class="line">(Delay_Stall_sign) ? ID_Instr_MEM :</span><br><span class="line">                                        (Memory_Inst_Sign) ? Memory_Inst_Cont : ID_Instr_Wire;</span><br></pre></td></tr></table></figure><h5 id="取值未完成-1"><a href="#取值未完成-1" class="headerlink" title="取值未完成"></a>取值未完成</h5><p>这个是不存在的，CP0在MEM级，若Store和load有问题，那么就设计一下让其不产生请求。其余的指令本来就不会产生请求。</p><h4 id="Eret处理"><a href="#Eret处理" class="headerlink" title="Eret处理"></a>Eret处理</h4><p>Eret是一种特殊的跳转，没有延迟槽的跳转。如果我们将其简单视为跳转指令的一员。归入跳转处理，那么会导致延迟槽的出现。</p><blockquote><p>且会有这样一个问题：由于Eret没有延迟槽，那么假如Eret的目标PC对应的指令也为跳转指令，就会导致Memory_BJ_sign的错误处理。（本来是关闭Eret的Memory_BJ_sign，结果一同关闭了跳转指令的sign，导致跳转失效），所以我们要单独为其开辟一个新寄存器和信号。<br>但处理思路是类似的，仍然需要保存。除此之外，我们还需要仿照前一细节产生IF_PC_Real信号，一旦Eret来到D级,直接越过IF_PC这个模块直接更改PC的值，防止延迟槽的产生。</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(reset) <span class="keyword">begin</span></span><br><span class="line">        Memory_Eret_Sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        Memory_Eret_Addr &lt;= <span class="number">32&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(D_is_Eret) <span class="keyword">begin</span></span><br><span class="line">        Memory_Eret_Sign &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        Memory_Eret_Addr &lt;= NPC;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(inst_addr_ok) <span class="keyword">begin</span></span><br><span class="line">        Memory_Eret_Sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] F_PC_Real = (D_is_Eret|| Memory_Eret_Sign) ? M_EPCOut : F_PC;</span><br></pre></td></tr></table></figure><h3 id="AXI基本原理"><a href="#AXI基本原理" class="headerlink" title="AXI基本原理"></a>AXI基本原理</h3><h4 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h4><p>在Sram或者类Sram中，我们的读写频道是合并在一起的，要么读要么写，两者不能并行，但是在AXI总线协议中，实现了读写频道的分离，这里借助一下AMBA官方的AXI协议文档的图帮助大家理解：</p><p>读频道：</p><p><img src="读频道.png" alt="AXI读频道"></p><p>我们将读请求作为一个频道，对应的一套信号为AXI读请求通道。<br>数据返回作为了另一个频道，对应的一套信号为AXI读响应通道。</p><p>写频道：</p><p><img src="写频道.png" alt="AXI写频道"></p><p>我们将读请求作为一个频道，对应的一套信号为AXI写请求通道。<br>数据写入作为了另一个频道，对应的一套信号为AXI写数据通道。<br>响应返回作为了另一个频道，对应的一套信号为AXI写响应通道。</p><p>为什么写有3个频道而读只有两个频道？</p><blockquote><p>只是因为写需要Master端提供数据，所以需要多一个频道。</p></blockquote><h4 id="信号及解释"><a href="#信号及解释" class="headerlink" title="信号及解释"></a>信号及解释</h4><p>信号有很多，但不要望而生畏，在我们没有实现cache之前，很多都是用不上的固定值。</p><p>AXI全局信号：</p><p><img src="AXI全局信号.png" alt="AXI全局信号"></p><p>AXI读请求通道：</p><p><img src="读请求通道.png" alt="AXI读请求通道"></p><p>arid：在AXI总线协议中，我们可以设计乱序发射CPU，这就需要一个ID号来与读响应通道进行对应，让我们知道我们发射的哪个请求对应哪个数据，不过我们目前还用不到这么高级的CPU设计方法，可以忽略。恒为0即可。(相同ID内响应不能乱序；不同ID间可以乱序)</p><p>arlen：这个是实现cache会用到的，一次读数据，同时将周围的数据都读进来，现在不需要，置为0。</p><p>arsize：按表格理解即可.</p><p>arburst: 突发传输，也和cache有关，目前未实现cache固定为1即可。</p><p>arlock: 与访问机制有关，目前固定为0.</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AXI3:</span><br><span class="line"><span class="number">2</span>’<span class="number">00</span>(Normal access);<span class="number">2</span>‘b01(Exclusive access);</span><br><span class="line"><span class="number">2</span>’b10(Locked access);<span class="number">2</span>’b11(Reserved);</span><br><span class="line">AXI4:</span><br><span class="line"><span class="number">1</span>’b0(Normal access);<span class="number">1</span>’b1(Exclusive access)</span><br></pre></td></tr></table></figure><p>AXI读响应通道：</p><p><img src="读响应通道.png" alt="AXI读相应通道"></p><p>rid:与arid对应，含义相同。</p><p>rlast: 这个其实是在突发传输中用于标记最后一个传输值，告诉Master本次传输结束。也与cache有关，而且我们这里一次只传输一个值，所以直接固定为有效即可。</p><p>AXI写请求通道：</p><p><img src="写请求通道1.png" alt="AXI写请求通道"></p><p><img src="写请求通道2.png" alt="AXI写请求通道"></p><p>AXI写数据通道：</p><p><img src="写数据通道.png" alt="AXI写数据通道"></p><p>AXI写响应通道：</p><p><img src="写响应通道.png" alt="AXI写响应通道"></p><p>写通道与读通道信号类似，不再赘述。</p><h4 id="详细学习"><a href="#详细学习" class="headerlink" title="详细学习"></a>详细学习</h4><p>参照AMBA AXI总线协议</p><p><a href="https://pan.baidu.com/s/1FkOCZiUiKC_EcGPS94R6Sg?pwd=cb1g">AMBA协议分享</a><br>提取码：cb1g </p><h3 id="转接桥搭建"><a href="#转接桥搭建" class="headerlink" title="转接桥搭建"></a>转接桥搭建</h3><p>其实到了这一步，知道每个信号的含义，我们就已经能写出从Sram到AXI的各个信号对应了。在这里笔者分享一个龙芯官方的AXI转接桥（侵删），大家可以参照学习一下。这个部分不是很难，思路对了就对了，不像前面改接口那样需要注意很多细节。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> cpu_axi_interface</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">input</span>         clk,</span><br><span class="line">    <span class="keyword">input</span>         resetn, </span><br><span class="line"></span><br><span class="line">    <span class="comment">//inst sram-like </span></span><br><span class="line">    <span class="keyword">input</span>         inst_req     ,</span><br><span class="line">    <span class="keyword">input</span>         inst_wr      ,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">1</span> :<span class="number">0</span>] inst_size    ,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] inst_addr    ,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] inst_wdata   ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] inst_rdata   ,</span><br><span class="line">    <span class="keyword">output</span>        inst_addr_ok ,</span><br><span class="line">    <span class="keyword">output</span>        inst_data_ok ,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//data sram-like </span></span><br><span class="line">    <span class="keyword">input</span>         data_req     ,</span><br><span class="line">    <span class="keyword">input</span>         data_wr      ,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">1</span> :<span class="number">0</span>] data_size    ,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] data_addr    ,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] data_wdata   ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] data_rdata   ,</span><br><span class="line">    <span class="keyword">output</span>        data_addr_ok ,</span><br><span class="line">    <span class="keyword">output</span>        data_data_ok ,</span><br><span class="line"></span><br><span class="line">    <span class="comment">//axi</span></span><br><span class="line">    <span class="comment">//ar</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span> :<span class="number">0</span>] arid         ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] araddr       ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span> :<span class="number">0</span>] arlen        ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span> :<span class="number">0</span>] arsize       ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span> :<span class="number">0</span>] arburst      ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span> :<span class="number">0</span>] arlock        ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span> :<span class="number">0</span>] arcache      ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span> :<span class="number">0</span>] arprot       ,</span><br><span class="line">    <span class="keyword">output</span>        arvalid      ,</span><br><span class="line">    <span class="keyword">input</span>         arready      ,</span><br><span class="line">    <span class="comment">//r           </span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span> :<span class="number">0</span>] rid          ,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">31</span>:<span class="number">0</span>] rdata        ,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">1</span> :<span class="number">0</span>] rresp        ,</span><br><span class="line">    <span class="keyword">input</span>         rlast        ,</span><br><span class="line">    <span class="keyword">input</span>         rvalid       ,</span><br><span class="line">    <span class="keyword">output</span>        rready       ,</span><br><span class="line">    <span class="comment">//aw          </span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span> :<span class="number">0</span>] awid         ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] awaddr       ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">7</span> :<span class="number">0</span>] awlen        ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span> :<span class="number">0</span>] awsize       ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span> :<span class="number">0</span>] awburst      ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">1</span> :<span class="number">0</span>] awlock       ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span> :<span class="number">0</span>] awcache      ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span> :<span class="number">0</span>] awprot       ,</span><br><span class="line">    <span class="keyword">output</span>        awvalid      ,</span><br><span class="line">    <span class="keyword">input</span>         awready      ,</span><br><span class="line">    <span class="comment">//w          </span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span> :<span class="number">0</span>] wid          ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] wdata        ,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span> :<span class="number">0</span>] wstrb        ,</span><br><span class="line">    <span class="keyword">output</span>        wlast        ,</span><br><span class="line">    <span class="keyword">output</span>        wvalid       ,</span><br><span class="line">    <span class="keyword">input</span>         wready       ,</span><br><span class="line">    <span class="comment">//b           </span></span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">3</span> :<span class="number">0</span>] bid          ,</span><br><span class="line">    <span class="keyword">input</span>  [<span class="number">1</span> :<span class="number">0</span>] bresp        ,</span><br><span class="line">    <span class="keyword">input</span>         bvalid       ,</span><br><span class="line">    <span class="keyword">output</span>        bready       </span><br><span class="line">);</span><br><span class="line"><span class="comment">//addr</span></span><br><span class="line"><span class="keyword">reg</span> do_req;</span><br><span class="line"><span class="keyword">reg</span> do_req_or; <span class="comment">//req is inst or data;1:data,0:inst</span></span><br><span class="line"><span class="keyword">reg</span>        do_wr_r;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span> :<span class="number">0</span>] do_size_r;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] do_addr_r;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] do_wdata_r;</span><br><span class="line"><span class="keyword">wire</span> data_back;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> inst_addr_ok = !do_req&amp;&amp;!data_req;</span><br><span class="line"><span class="keyword">assign</span> data_addr_ok = !do_req;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    do_req     &lt;= !resetn                       ? <span class="number">1&#x27;b0</span> : </span><br><span class="line">                  (inst_req||data_req)&amp;&amp;!do_req ? <span class="number">1&#x27;b1</span> :</span><br><span class="line">                  data_back                     ? <span class="number">1&#x27;b0</span> : do_req;</span><br><span class="line">    do_req_or  &lt;= !resetn ? <span class="number">1&#x27;b0</span> : </span><br><span class="line">                  !do_req ? data_req : do_req_or;</span><br><span class="line"></span><br><span class="line">    do_wr_r    &lt;= data_req&amp;&amp;data_addr_ok ? data_wr :</span><br><span class="line">                  inst_req&amp;&amp;inst_addr_ok ? inst_wr : do_wr_r;</span><br><span class="line">    do_size_r  &lt;= data_req&amp;&amp;data_addr_ok ? data_size :</span><br><span class="line">                  inst_req&amp;&amp;inst_addr_ok ? inst_size : do_size_r;</span><br><span class="line">    do_addr_r  &lt;= data_req&amp;&amp;data_addr_ok ? data_addr :</span><br><span class="line">                  inst_req&amp;&amp;inst_addr_ok ? inst_addr : do_addr_r;</span><br><span class="line">    do_wdata_r &lt;= data_req&amp;&amp;data_addr_ok ? data_wdata :</span><br><span class="line">                  inst_req&amp;&amp;inst_addr_ok ? inst_wdata :do_wdata_r;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//inst sram-like</span></span><br><span class="line"><span class="keyword">assign</span> inst_data_ok = do_req&amp;&amp;!do_req_or&amp;&amp;data_back;</span><br><span class="line"><span class="keyword">assign</span> data_data_ok = do_req&amp;&amp; do_req_or&amp;&amp;data_back;</span><br><span class="line"><span class="keyword">assign</span> inst_rdata   = rdata;</span><br><span class="line"><span class="keyword">assign</span> data_rdata   = rdata;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---axi</span></span><br><span class="line"><span class="keyword">reg</span> addr_rcv;</span><br><span class="line"><span class="keyword">reg</span> wdata_rcv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_back = addr_rcv &amp;&amp; (rvalid&amp;&amp;rready||bvalid&amp;&amp;bready);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    addr_rcv  &lt;= !resetn          ? <span class="number">1&#x27;b0</span> :</span><br><span class="line">                 arvalid&amp;&amp;arready ? <span class="number">1&#x27;b1</span> :</span><br><span class="line">                 awvalid&amp;&amp;awready ? <span class="number">1&#x27;b1</span> :</span><br><span class="line">                 data_back        ? <span class="number">1&#x27;b0</span> : addr_rcv;</span><br><span class="line">    wdata_rcv &lt;= !resetn        ? <span class="number">1&#x27;b0</span> :</span><br><span class="line">                 wvalid&amp;&amp;wready ? <span class="number">1&#x27;b1</span> :</span><br><span class="line">                 data_back      ? <span class="number">1&#x27;b0</span> : wdata_rcv;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">//ar</span></span><br><span class="line"><span class="keyword">assign</span> arid    = <span class="number">4&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> araddr  = do_addr_r;</span><br><span class="line"><span class="keyword">assign</span> arlen   = <span class="number">8&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> arsize  = do_size_r;</span><br><span class="line"><span class="keyword">assign</span> arburst = <span class="number">2&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> arlock  = <span class="number">2&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> arcache = <span class="number">4&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> arprot  = <span class="number">3&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> arvalid = do_req&amp;&amp;!do_wr_r&amp;&amp;!addr_rcv;</span><br><span class="line"><span class="comment">//r</span></span><br><span class="line"><span class="keyword">assign</span> rready  = <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aw</span></span><br><span class="line"><span class="keyword">assign</span> awid    = <span class="number">4&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> awaddr  = do_addr_r;</span><br><span class="line"><span class="keyword">assign</span> awlen   = <span class="number">8&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> awsize  = do_size_r;</span><br><span class="line"><span class="keyword">assign</span> awburst = <span class="number">2&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> awlock  = <span class="number">2&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> awcache = <span class="number">4&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> awprot  = <span class="number">3&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> awvalid = do_req&amp;&amp;do_wr_r&amp;&amp;!addr_rcv;</span><br><span class="line"><span class="comment">//w</span></span><br><span class="line"><span class="keyword">assign</span> wid    = <span class="number">4&#x27;d0</span>;</span><br><span class="line"><span class="keyword">assign</span> wdata  = do_wdata_r;</span><br><span class="line"><span class="keyword">assign</span> wstrb  = do_size_r==<span class="number">2&#x27;d0</span> ? <span class="number">4&#x27;b0001</span>&lt;&lt; do_addr_r[<span class="number">1</span>:<span class="number">0</span>] :</span><br><span class="line">                do_size_r==<span class="number">2&#x27;d1</span> ? <span class="number">4&#x27;b0011</span>&lt;&lt; do_addr_r[<span class="number">1</span>:<span class="number">0</span>] : <span class="number">4&#x27;b1111</span>;</span><br><span class="line"><span class="keyword">assign</span> wlast  = <span class="number">1&#x27;d1</span>;</span><br><span class="line"><span class="keyword">assign</span> wvalid = do_req&amp;&amp;do_wr_r&amp;&amp;!wdata_rcv;</span><br><span class="line"><span class="comment">//b</span></span><br><span class="line"><span class="keyword">assign</span> bready  = <span class="number">1&#x27;b1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>新建一个Verilog文件，将CPU和转接桥作为模块写在这个文件中，我们就得到了一个封装好的，外观上看起来是AXI接口的CPU。</p><blockquote><p>2023年2月14日挖坑：或许实现了Cache会回来更新，只是或许，对吧？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 龙芯 NSCSCC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AXI总线 </tag>
            
            <tag> CPU接口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/posts/5009/"/>
      <url>/posts/5009/</url>
      
        <content type="html"><![CDATA[<h1 id="问题模型"><a href="#问题模型" class="headerlink" title="问题模型"></a>问题模型</h1><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>有一个数组arr，下标从1到n，现在有w次修改，q次查询，修改的话是修改数组中某一个元素的值；查询的话是查询数组中任意一个区间的和。规模在50w左右</p><h2 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h2><p>修改直接修改数组对应元素，时间复杂度为O（1），查询时直接相加，时间复杂对度O（n），总复杂度为O（wn).</p><h2 id="前缀和解法"><a href="#前缀和解法" class="headerlink" title="前缀和解法"></a>前缀和解法</h2><p>修改需要修改前缀和数组对应点后的所有值，时间复杂度为O（n)，查询时只需一次查询，时间复杂度为O（1），时间复杂度为O(qn).</p><blockquote><p>可见暴力解法和前缀和解法时间复杂度其实大差不差.</p></blockquote><h2 id="寻找新解法"><a href="#寻找新解法" class="headerlink" title="寻找新解法"></a>寻找新解法</h2><p>有没有一种做法可以综合一下这两种朴素做法，然后整体时间复杂度可以降一个数量级呢？有——树状数组。</p><h1 id="树状数组思想"><a href="#树状数组思想" class="headerlink" title="树状数组思想"></a>树状数组思想</h1><p>假设一个C数组，弃掉0下标不用，对于该数组每个下标所存内容，由如下规则决定：<br>将下标转为二进制表示，求出该二进制表示最低一个1所表示的值，记为lowbit：<br>该下标所存内容为arr数组中的(下标-lowbit,下标]的内容。<br>eg:6的二进制表示为（110），那么6的lowbit的二进制表示为10，即为2，所以下标6所存内容为arr数组中的（4,6]的和。 </p><p style="color: #FF0000;">这样做的根据在哪里？我们以求前6项和举例：</p>   $$\eqalign{  & \sum\limits_{{\rm{i}} = 1}^6 {arr[i] = (arr[1] + arr[2] + arr[3] + arr[4]) + (arr[5] + arr[6])}   \cr   & {110_2} = {100_2} + {10_2} \cr} $$<p>按照如上规则，我们分析C[4]所存内容，是不是如下：</p>$$\eqalign{  & \sum\limits_{{\rm{i}} = 1}^4 {arr[i] = (arr[1] + arr[2] + arr[3] + arr[4])}   \cr   } $$<p>C[6]所存内容，是不是如下：</p>$$\sum\limits_{{\rm{i}} = 5}^6 {arr[i] = (arr[5] + arr[6])} $$<p>所以：</p>$$\eqalign{  & \sum\limits_{{\rm{i}} = 1}^6 {arr[i] = C[4] + C[6]}   \cr   & {110_2} = {100_2} + {10_2} \cr} $$<p>也就是我们根据二进制拆分了前n项和，C数组的各种表示也由此而来。</p><h2 id="lowbit求法"><a href="#lowbit求法" class="headerlink" title="lowbit求法"></a>lowbit求法</h2><h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>对x减1即可消掉二进制中最低的1个1，并且最低1所在位的后面所有位都会与原数对应位不同。<p style="color: #FF0000;">为什么不同？</p> </p><blockquote><p>答：考虑借位，由于在找到最低1前面，低位一直再向高位借1，一直借不到，所以所有的0会变为1，直到找到那个1，借1成功，1变为0.</p></blockquote><p>再与原数x做与运算即可得到去掉最低位1的数，再用原数与其相减即可得到lowbit。</p><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>6的二进制表示：<br>$${6_{_{10}}} = {110_2}$$<br>6-1二进制表示：<br>$${5_{_{10}}} = {101_2}$$<br>（6-1）与原数（6）做与运算：<br>$${101_2}\& {110_2} = {100_2} = {4_{10}}$$<br>原数与其相减：<br>$${6_{10}} - {4_{10}} = {2_{10}}$$<br>2即为所求。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - (x &amp; (x - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>结合求负数补码的方法。直接x&amp;(-x)</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4>$$\eqalign{  & ( - {6_{10}}) = 1\_{0010_2}  \cr   & ( + {6_{10}}) = 0\_{0110_2}  \cr   & ( - {6_{10}})\& ( + {6_{10}}) = 0\_{010_2} = {2_{10}} \cr} $$<p>所以6&amp;(-6)即为lowbit</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(x)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="树状数组实现"><a href="#树状数组实现" class="headerlink" title="树状数组实现"></a>树状数组实现</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这里说的查询是查询任一区间的和，由于区间和具有可加减性，故转化为求前缀和：<br>查询前缀和刚刚在树状数组的思想中已经说过了，就是把大区间分成几段长度不等的小区间，然后求和。区间的个数为O(logn)，所以查询的时间复杂度为O(logn)。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//i为下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt;= <span class="number">1</span>; k -= <span class="built_in">lowbit</span>(k))</span><br><span class="line">&#123;</span><br><span class="line">sum += crr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>需要对被影响到的C数组元素都进行修改：</p><p><img src="https://s1.ax1x.com/2023/02/03/pSrbe91.png" alt="树状数组"></p><p>这就是C数组的含义，我们也由此可以得到一个性质：</p><ul><li>下一层后缀和只要补上自己后缀和的长度就可以得到上面层的后缀和  </li></ul><p>这个性质就是更新操作的依据，我们由此得到如下规则：</p><p>假设修改下标为x的内容，我们同时需要修改下标为：<br>$$\eqalign{  & x + lowbit(x)  \cr   & x + lowbit(x) + lowbit(x + lowbit(x))  \cr   & ............. \cr} $$<br>直到超出我们所需要的边界n.修改的时间复杂度也为O（logn）</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> y ,<span class="type">int</span> n)</span> <span class="comment">//位置为i,更新量为y,数目为n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= n; k += <span class="built_in">lowbit</span>(k))</span><br><span class="line">&#123;</span><br><span class="line">crr[k] += y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>n个小朋友站成一排。现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。<br>每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是 0。<br>如果某个小朋友第一次被要求交换，则他的不高兴程度增加 1，如果第二次要求他交换，则他的不高兴程度增加 2（即不高兴程度为 3），依次类推。当要求某个小朋友第 k 次交换时，他的不高兴程度增加k。<br>请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。<br>如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入的第一行包含一个整数 n，表示小朋友的个数。<br>第二行包含 n 个整数,${H_1},{H_2},...$,分别表示小朋友的身高。其中：<br>$$1 \le n \le {10^5},0 \le {H_i} \le {10^6}$$</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>对于这样的一个序列：<br>$$5,3,4,1,2$$<br>考虑中间的一般性情况，对于数字4代表的小朋友，他的交换次数取决于左边比他大的有多少，右边比他小的有多少，所以我们将身高作为C数组的下标,该身高的人数作为值，便加边查,从左边一次,重置后从右边一次,例如从左边边加边查查到4时,我们可以用getSum(4)得到当前加入的（5，3，4）中比4小或者相等的有2个，所以我们可以得到比4大的有3-2=1个，得到左边的值:1…依次类推我们可以得到每一位小朋友需要与左边的人交换的次数。   </p><p>之后重置C数组,从右边加进来边加边查,可以得到每一位小朋友需要与右边的人交换的次数,两个加和可得每一位小朋友需要交换的次数。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><blockquote><p>下标文中加1是因为身高会有0的情况，而C数组是弃0不同的,所以我们整体+1。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> crr[<span class="number">10000005</span>];</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1000005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cnt[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> i &amp; -i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> y ,<span class="type">int</span> n)</span> <span class="comment">//位置为i,更新量为y,数目为n</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt;= n; k += <span class="built_in">lowbit</span>(k))</span><br><span class="line">&#123;</span><br><span class="line">crr[k] += y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = i; k &gt;= <span class="number">1</span>; k -= <span class="built_in">lowbit</span>(k))</span><br><span class="line">&#123;</span><br><span class="line">sum += crr[k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> maxH = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; maxH)</span><br><span class="line">&#123;</span><br><span class="line">maxH = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">update</span>(arr[i] + <span class="number">1</span>, <span class="number">1</span>, maxH + <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">getSum</span>(arr[i] + <span class="number">1</span>);</span><br><span class="line">cnt[i] = i + <span class="number">1</span> - sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(crr, <span class="number">0</span>, <span class="built_in">sizeof</span>(crr));</span><br><span class="line"><span class="comment">//右边</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">update</span>(arr[i] + <span class="number">1</span>, <span class="number">1</span>, maxH + <span class="number">1</span>);</span><br><span class="line">cnt[i] += <span class="built_in">getSum</span>(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans += (cnt[i] * (cnt[i] + <span class="number">1</span>)) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> ]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++不常见但很好用的Api整理</title>
      <link href="/posts/25567/"/>
      <url>/posts/25567/</url>
      
        <content type="html"><![CDATA[<p>本帖持续更新</p><h1 id="algorithm库"><a href="#algorithm库" class="headerlink" title="algorithm库"></a>algorithm库</h1><h2 id="全排列函数"><a href="#全排列函数" class="headerlink" title="全排列函数"></a>全排列函数</h2><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation()"></a>next_permutation()</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>对于next_permutation函数，其函数原型为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(iterator start,iterator end)</span></span></span><br></pre></td></tr></table></figure> <p>当当前序列不存在下一个排列时，函数返回false，否则返回true（字典升序）</p><h3 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation()"></a>prev_permutation()</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>next_permutation() 是按照字典升序的方式生成的排列。当我们想以降序的方式生成排列时，可以使用 prev_permutation()</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p style="color: #FF0000;">下一个排列的基准以当前容器的元素顺序为准</p>   <h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; arr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">char</span>&gt;::iterator it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a b c</span><br><span class="line">a c b</span><br><span class="line">b a c</span><br><span class="line">b c a</span><br><span class="line">c a b</span><br><span class="line">c b a</span><br></pre></td></tr></table></figure> <h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span></span></span><br></pre></td></tr></table></figure> <h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string ans</span></span><br><span class="line"><span class="function"><span class="title">reverse</span><span class="params">(ans.begin(), ans.end())</span></span>;</span><br></pre></td></tr></table></figure> <p>具体参看<a href="https://foreveryolo.github.io/posts/65270/">高精度模板</a></p><h1 id="sstream库"><a href="#sstream库" class="headerlink" title="sstream库"></a>sstream库</h1><h2 id="定行不定列输入"><a href="#定行不定列输入" class="headerlink" title="定行不定列输入"></a>定行不定列输入</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>n为行数，每行有不止一个数字输入，所以用Getline得到一行数据，用空格分割<p style="color: #FF0000;">Getline有自动分割的同名函数，但输入流不能是键盘，所以我们需要用到istringstream,让Getline从isttringstream中得到数据</p> </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">//吃掉n后面的回车</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s); <span class="comment">//getline会自动吃掉回车</span></span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">string tmp;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(iss, tmp, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; tmp;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">ss &gt;&gt; a;</span><br><span class="line">arr.<span class="built_in">push_back</span>(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">stringstream s</span><br><span class="line">s&lt;&lt;<span class="type">int</span></span><br><span class="line">s&gt;&gt;string</span><br></pre></td></tr></table></figure> <h2 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">stringstream s</span><br><span class="line">s&lt;&lt;string</span><br><span class="line">s&gt;&gt;<span class="type">int</span></span><br></pre></td></tr></table></figure> <blockquote><p>2022年2月2日 0:11 记：这种C++风格的转换性能上弱于C风格的Atoi</p></blockquote><h1 id="string库"><a href="#string库" class="headerlink" title="string库"></a>string库</h1><h2 id="find-first-not-of"><a href="#find-first-not-of" class="headerlink" title="find_first_not_of()"></a>find_first_not_of()</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">( <span class="type">const</span> basic_string &amp;str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, size_type index, size_type num )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">( <span class="type">char</span> ch, size_type index = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure> <h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nops<br>在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始，最多查找num个字符。如果没找到就返回string::nops<br>在字符串中查找第一个与ch不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nops</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>) 找到第一个不是<span class="number">0</span>的位置</span><br></pre></td></tr></table></figure> <p>具体参看<a href="https://foreveryolo.github.io/posts/65270/">高精度模板</a></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>使用string ans(数量, ‘0’)可以直接初始化asn为数量长，全部填充0</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇技淫巧 </tag>
            
            <tag> 高级语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正整数C++高精度模板</title>
      <link href="/posts/65270/"/>
      <url>/posts/65270/</url>
      
        <content type="html"><![CDATA[<h1 id="前置函数"><a href="#前置函数" class="headerlink" title="前置函数"></a>前置函数</h1><h2 id="数学取模"><a href="#数学取模" class="headerlink" title="数学取模"></a>数学取模</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">i2s</span><span class="params">(<span class="type">int</span>&amp; x,string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; x;</span><br><span class="line">    ss &gt;&gt; s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用代码模拟小学所学的竖式加/减<br>将乘除转化为加/减</p><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Myadd</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a = a.substr(a.find_first_not_of(&#x27;0&#x27;));</span></span><br><span class="line">    <span class="comment">//b = b.substr(b.find_first_not_of(&#x27;0&#x27;));</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        len = a.<span class="built_in">length</span>() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = b.<span class="built_in">length</span>() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">string <span class="title">ans</span><span class="params">(len, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; b.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += (ans[i] - <span class="string">&#x27;0&#x27;</span>) + (b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans[i] = tmp % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp += (ans[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans[i] = tmp % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans.<span class="built_in">substr</span>(ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Mysub</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(a, b)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a = a.substr(a.find_first_not_of(&#x27;0&#x27;));</span></span><br><span class="line">    <span class="comment">//b = b.substr(b.find_first_not_of(&#x27;0&#x27;));</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        len = a.<span class="built_in">length</span>() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = b.<span class="built_in">length</span>() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">string <span class="title">ans</span><span class="params">(len, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; b.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += (ans[i] - <span class="string">&#x27;0&#x27;</span>) - (b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans[i] = <span class="built_in">Mod</span>(tmp,<span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            tmp = (tmp - <span class="number">9</span>) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp += (ans[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans[i] = <span class="built_in">Mod</span>(tmp, <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            tmp = (tmp - <span class="number">9</span>) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>) - <span class="number">1</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans.<span class="built_in">substr</span>(ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Mymul</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string cnt;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (cnt != b)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">Myadd</span>(ans, a);</span><br><span class="line">        cnt = <span class="built_in">Myadd</span>(cnt, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Mydiv</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cmp</span>(a, b) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">Mysub</span>(a, b);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="built_in">i2s</span>(cnt, ans);</span><br><span class="line">    ans.<span class="built_in">append</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">101</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        a.<span class="built_in">append</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(a, b) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">append</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            ans.<span class="built_in">append</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(a, b) &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             a = <span class="built_in">Mysub</span>(a, b);</span><br><span class="line">             t++;</span><br><span class="line">        &#125;</span><br><span class="line">        string t_str;</span><br><span class="line">        <span class="built_in">i2s</span>(t, t_str);</span><br><span class="line">        ans.<span class="built_in">append</span>(t_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Mymod</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cmp</span>(a, b) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">Mysub</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级语言 </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由波动数列对高级语言取模的思考</title>
      <link href="/posts/54458/"/>
      <url>/posts/54458/</url>
      
        <content type="html"><![CDATA[<h1 id="波动数列"><a href="#波动数列" class="headerlink" title="波动数列"></a>波动数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>观察这个数列：</p>$$1,3,0,2, - 1,1, - 2$$<p>这个数列中后一项总是比前一项增加2或者减少3。<br>栋栋对这种数列很好奇，他想知道长度为n或为s而且后一项总是比前一项增加a或者减少b的整数数列可能有多少种呢？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入的第一行包含四个整数n,s,a,b,含义如前面所述，其中：</p>$$1 \le n \le 1000, - {10^{^9}} \le s \le {10^9},1 \le a,b \le {10^6}$$<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一行，包含一个整数，表示满足条件的方案数。由于这个数很大，请输出方案数除以 $ {10^8}{\rm{ + }}7 $ 的余数。</p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="第一层（10分）"><a href="#第一层（10分）" class="headerlink" title="第一层（10分）"></a>第一层（10分）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑极限情况：</p>$$\eqalign{  & {\rm{x,x}} + a,x + 2a,x + 3a,...x + (n - 1)a = nx + {{n(n - 1)} \over 2}a = s  \cr   & x,x - b,x - 2b,x - 3b,...x - (n - 1)b = nx - {{n(n - 1)} \over 2}b = s \cr} $$<p>一式中x为最小值，二式中x为最大值，由此得到x的范围，进而可以枚举每一个x进行DFS</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, s, a, b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cnt, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum == s)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans &gt; MOD)</span><br><span class="line">&#123;</span><br><span class="line">ans %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(x + a, cnt + <span class="number">1</span>, sum + x + a);</span><br><span class="line"><span class="built_in">dfs</span>(x - b, cnt + <span class="number">1</span>, sum + x - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x1 = s / n - a * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x2 = <span class="number">1</span> + s / n + b * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = x1; x &lt;= x2; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs</span>(x, <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">slove</span>();</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="第二层（20分）"><a href="#第二层（20分）" class="headerlink" title="第二层（20分）"></a>第二层（20分）</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对枚举数量进行缩减，将a,b一同看为p,原式合并为：</p>$${\rm{x,x}} + p,x + 2p,x + 3p,...x + (n - 1)p = nx + {{n(n - 1)} \over 2}p = s$$<p>所以a,b共有${{n(n - 1)} \over 2}$个，选定x,在DFS前枚举a的个数,如果所有a都不能满足$nx + {t_a}a - ({{n(n - 1)} \over 2} - {t_a})b = s$，则不进行对此x的DFS。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, s, a, b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cnt, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum == s)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans &gt; MOD)</span><br><span class="line">&#123;</span><br><span class="line">ans %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(x + a, cnt + <span class="number">1</span>, sum + x + a);</span><br><span class="line"><span class="built_in">dfs</span>(x - b, cnt + <span class="number">1</span>, sum + x - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x1 = s / n - a * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x2 = <span class="number">1</span> + s / n + b * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = x1; x &lt;= x2; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cntA = <span class="number">0</span>; cntA &lt;= t; cntA++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cal = x * n + cntA * a - (t - cntA) * b;</span><br><span class="line"><span class="keyword">if</span> (cal == s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs</span>(x, <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> (x % n + n) % n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">slove</span>();</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="第三层（100分）"><a href="#第三层（100分）" class="headerlink" title="第三层（100分）"></a>第三层（100分）</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>令：</p>$${{n(n - 1)} \over 2}p = z$$<p>原式解出x:</p>$$x = {{s - z} \over n}$$<p>由于x作为首项，必为整数，所以得到：</p>$$s = z(\bmod n)$$<p>即s与z同余。<br>现在我们将p再次转化为f[i]={a,b},原式可写为：<br>$$x,x + f[1],x + f[1] + f[2],x + f[1] + f[2] + f[3],...,x + f[1] + ... + f[n - 1]$$</p><p>合并后为：</p>$$nx + (n - 1)f[1] + (n - 2)f[2] + ... + f[n - 1] = s$$<p>由前面同余的关系，两边取模：</p>$$( - f[1] - 2f[2]... - f[n - 1])\% n = s\% n$$ <p>取反：</p>$$( f[1] + 2f[2]... + f[n - 1])\% n = (-s)\% n$$ <p>因此我们可以对f[1]-f[n-1]进行动态规划：</p>$$dp[i][j] = dp[i][j - i \times a] + dp[i][j + i \times b]$$<p>dp[i][j]表示前i项余数为j的组合数。<br>最后我们取dp[n-1][(-s)%n]即可得解。</p><h3 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h3><h4 id="取模异常"><a href="#取模异常" class="headerlink" title="取模异常"></a>取模异常</h4><p>笔者在查阅题解时发现题解中对于取模并不是直接取模，而是进行了这样的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (x % n + n) % n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>而使用Python3的选手则是像思路那样直接取模。</p><p>笔者对此十分的不理解，起初认为是忽略了题目的条件，经过几个小时的查阅笔者找到了这样做的理由：与数学取模保持一致/维护数组下标大于0。</p><h4 id="数学取模"><a href="#数学取模" class="headerlink" title="数学取模"></a>数学取模</h4><p>定义：如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数q和r，满足a = qd+r 且（0 &lt;= r &lt; d&gt;。其中，q被称为商,r被称为余数。<br>所以对于（-7）%3,答案应该是2。  </p><p style="color: #FF0000;">但高级语言并不一定为2</p>    <p>C++：cout&lt;&lt;(-7)%3;//输出为-1    </p><p>Java:System.out.println((-7)%3);//输出为-1      </p><p>Python:print((-7)%3)//输出为2   </p><p>结果让我大跌眼镜，查阅资料得知，C++和Java通常会让<b>商大一点</b>，Python通常会让<b>商小一点</b>。所以C++和Java商为-2.Python为-3，进而导致了结果的不同。 </p><p>所以，为了和我们的认知——数学取模保持一致，我们利用Mod(int x)这个函数让C++的取模和Python和数学取模保持了一致。这也就回答了为什么C++有一种多此一举的感觉。    </p><p>但是其实，从另一个角度想，就算C++不这样取模，难道答案就会错吗？有没有可能这样做只是为了维护下标大于0？<p style="color: #FF0000;">确实会错</p>  </p><p>这是在C++下直接取模（下标同+1000）：</p><p><img src="错误答案.png" alt="错误答案">   </p><p>这是在C++下函数取模：<br><img src="正确答案.png" alt="正确答案"></p><p>所以，做题还是严格按照数学取模来叭</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">3</span>,mod=<span class="number">1e8</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x%n+n)%n;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> s,a,b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;s,&amp;a,&amp;b);</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">dp[i][j]=(dp[i<span class="number">-1</span>][<span class="built_in">Mod</span>(j-a*i)]+dp[i<span class="number">-1</span>][<span class="built_in">Mod</span>(j+b*i)])%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n<span class="number">-1</span>][<span class="built_in">Mod</span>(s)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级语言 </tag>
            
            <tag> 算法学习 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——数论整理</title>
      <link href="/posts/2344/"/>
      <url>/posts/2344/</url>
      
        <content type="html"><![CDATA[<p>本帖持续更新<br><strong><font size = 5>这是编程算法计算加速总结</font></strong></p><h1 id="快速乘法"><a href="#快速乘法" class="headerlink" title="快速乘法"></a>快速乘法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设当前计算a*b,应用二进制，将a,b中较大的一位数转化为二进制表示，例如11转化为1011，然后类比利用竖式计算乘法那样，用较小的数乘以每一位代表的2次幂，最后相加。</p><h2 id="加速点"><a href="#加速点" class="headerlink" title="加速点"></a>加速点</h2><p>乘法转为logn量级的乘法+加法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="无取模"><a href="#无取模" class="headerlink" title="无取模"></a>无取模</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Imul</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = x + a;</span><br><span class="line">&#125;</span><br><span class="line">a = a * <span class="number">2</span>;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Imul</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> b,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = (x + a) % mod;</span><br><span class="line">&#125;</span><br><span class="line">a = (a * <span class="number">2</span>) % mod;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>类似于快速乘法，同样利用二进制，这里利用的是幂次的二进制位。<br>例如： $ 7^{11} $ ,幂次的二进制位为:1011，因而可以拆分为：  ${7^8} \times {7^2} \times 7$  ，而这些幂次都可通过7的不断自乘得到。只需乘6次即可得到结果。</p><h2 id="加速点-1"><a href="#加速点-1" class="headerlink" title="加速点"></a>加速点</h2><p>利用二进制的特性，直接不断自乘本身即可得到结果，可以跳过一些次幂的运算。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">M* <span class="title">Mpow</span><span class="params">(M* m, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">M* ans = <span class="keyword">new</span> <span class="built_in">M</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">Mmul</span>(ans, m, mod);</span><br><span class="line">&#125;</span><br><span class="line">m = <span class="built_in">Mmul</span>(m, m, mod);</span><br><span class="line">n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="快速斐波那契数列"><a href="#快速斐波那契数列" class="headerlink" title="快速斐波那契数列"></a>快速斐波那契数列</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2>$$\left[ {\matrix{   {f(2)} & {f(1)}  \cr    0 & 0  \cr  } } \right] \times {\left[ {\matrix{   1 & 1  \cr    1 & 0  \cr  } } \right]^{n - 2}} = \left[ {\matrix{   {f(n)} & {f(n - 1)}  \cr    0 & 0  \cr  } } \right]$$ <p>其中， ${\left[ {\matrix{   1 & 1  \cr    1 & 0  \cr  } } \right]^{n - 2}}$可以用快速幂计算</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">fib</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">M* A = <span class="keyword">new</span> <span class="built_in">M</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">M* B = <span class="keyword">new</span> <span class="built_in">M</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">M* ans = <span class="built_in">Mmul</span>(A, <span class="built_in">Mpow</span>(B, i - <span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> ans-&gt;data[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="快速斐波那契求和"><a href="#快速斐波那契求和" class="headerlink" title="快速斐波那契求和"></a>快速斐波那契求和</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2>$$\sum\limits_{i = 1}^n {f(i)}  = f(n + 2) - 1$$<h1 id="买不到的数目"><a href="#买不到的数目" class="headerlink" title="买不到的数目"></a>买不到的数目</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小明开了一家糖果店。他别出心裁：把水果糖包成 4 颗一包和 7 颗一包的两种。糖果不能拆包卖。<br>小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。<br>你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是 17。大于 17 的任何数字都可以用 4 和 7 组合出来。<br>本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="对于方程"><a href="#对于方程" class="headerlink" title="对于方程"></a>对于方程</h3><script type="math/tex; mode=display">{\rm{ax}} + by = c</script><p>1.a,b互质，一定有解且解的数目无穷<br>2.C是gcd(a,b)的倍数，方程一定有解，且有无穷多解    </p><h3 id="对于本题"><a href="#对于本题" class="headerlink" title="对于本题"></a>对于本题</h3><p>最大不能组合出的数字：n*m-n-m</p><h1 id="公约数公倍数"><a href="#公约数公倍数" class="headerlink" title="公约数公倍数"></a>公约数公倍数</h1><h2 id="公约数——欧几里得法"><a href="#公约数——欧几里得法" class="headerlink" title="公约数——欧几里得法"></a>公约数——欧几里得法</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>假如x,y有最大公约数T，根据最大公约数的定义，则x,y都可以被T整除。同时也有这样一个数学规律:<br>$$C = {\rm{mx}} \pm {\rm{ny}}$$<br>这样的C也是可以被最大公约数T整除的。那么假设：<br>$$\eqalign{  & x > y,x \div y = a...b  \cr   & {\rm{b}} = x - a \times y \cr} $$<br>那么b也是可以被T整除的，这个b小于y,那么我们得到新的两个数，新的x（较大的这个）为y（旧y），新的y为b，这两个的数仍然可以被T整除，且这两个数均小于原数。<br>我们这样一直重复，会使得x,y越来越小，越接近T，最后成为T：<br>$$x\% y = 0$$<br>此时x=y为最大公约数。</p><h2 id="公倍数——公约间接法"><a href="#公倍数——公约间接法" class="headerlink" title="公倍数——公约间接法"></a>公倍数——公约间接法</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>假设x,y为两数，T为最大公约数，M为最小公倍数，有这样的数学公式：<br>$$xy = TM$$</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> m,n,r;  </span><br><span class="line">   <span class="keyword">if</span>(a&lt;b) <span class="built_in">swap</span>(&amp;a,&amp;b);</span><br><span class="line">   m=a;n=b;r=a%b;</span><br><span class="line">   <span class="keyword">while</span>(r!=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    a=b;b=r;</span><br><span class="line">    r=a%b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);  <span class="comment">// 最大公约数 </span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,m*n/b);  <span class="comment">// 最小公倍数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux指令操作记录</title>
      <link href="/posts/1949/"/>
      <url>/posts/1949/</url>
      
        <content type="html"><![CDATA[<p>本文用来记录笔者学习OS过程中掌握的Linux指令</p><h1 id="查看命令详细用法"><a href="#查看命令详细用法" class="headerlink" title="查看命令详细用法"></a>查看命令详细用法</h1><h2 id="man-命令名"><a href="#man-命令名" class="headerlink" title="man (命令名)"></a>man (命令名)</h2><h1 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h1><h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><h3 id="cd-1"><a href="#cd-1" class="headerlink" title="cd ~"></a>cd ~</h3><p>访问当前用户主目录 一般为/home/用户<br>OS实测：/home/git</p><h3 id="cd-2"><a href="#cd-2" class="headerlink" title="cd ."></a>cd .</h3><p>访问当前目录(原地踏步)，常常结合其他目录使用</p><h3 id="cd-3"><a href="#cd-3" class="headerlink" title="cd /"></a>cd /</h3><p>访问根目录</p><h3 id="绝对访问"><a href="#绝对访问" class="headerlink" title="绝对访问"></a>绝对访问</h3><p>cd /文件/……</p><h3 id="相对访问"><a href="#相对访问" class="headerlink" title="相对访问"></a>相对访问</h3><p>cd 文件<br>cd 文件/</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>转自os平台<br><img src="cd测试.png" alt="cd"></p><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><h3 id="ls-a"><a href="#ls-a" class="headerlink" title="ls -a"></a>ls -a</h3><p>查看当前目录下包括隐藏文件的所有文件</p><h3 id="ls-l"><a href="#ls-l" class="headerlink" title="ls -l"></a>ls -l</h3><p>一行呈现一个文件</p><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><h3 id="tree-选项-目录名"><a href="#tree-选项-目录名" class="headerlink" title="tree [选项] [目录名]"></a>tree [选项] [目录名]</h3><p>更高级的ls,可视化表达目录结构</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>-a              列出全部文件（包含隐藏文件）。<br>-d              只列出目录。</p><h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><h3 id="mkdir-选项-目录名称"><a href="#mkdir-选项-目录名称" class="headerlink" title="mkdir [选项] 目录名称"></a>mkdir [选项] 目录名称</h3><p>在当前目录下创建新目录</p><h2 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h2><h3 id="rmdir-选项-目录名称"><a href="#rmdir-选项-目录名称" class="headerlink" title="rmdir [选项] 目录名称"></a>rmdir [选项] 目录名称</h3><p>删除当前目录下对应名称的目录，只能是空目录</p><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>查看当前目录的绝对路径</p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><h3 id="touch-选项-文件名"><a href="#touch-选项-文件名" class="headerlink" title="touch [选项] 文件名"></a>touch [选项] 文件名</h3><p>当文件存在时更新文件的时间戳，当文件不存在时创建新文件</p><h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><h3 id="rm-r-文件"><a href="#rm-r-文件" class="headerlink" title="rm -r 文件"></a>rm -r 文件</h3><p>递归删除目录及其内容，删除非空目录必须有此选项，否则无法删除。</p><h3 id="rm-f-文件"><a href="#rm-f-文件" class="headerlink" title="rm -f 文件"></a>rm -f 文件</h3><p>强制删除，不提示用户确认，忽略不存在的目录。</p><h3 id="rm-i-文件"><a href="#rm-i-文件" class="headerlink" title="rm -i 文件"></a>rm -i 文件</h3><p>逐一提示用户确认每个将要被删除的文件。</p><h3 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h3><p>转自OS平台<br><img src="rm测试.png" alt="rm测试"></p><p><p style="color: #FF0000;">中间的 rm -rf * 为删除本机所有文件</p><br>笔者当时在OS测试机上打了这个，看着刷屏的删除文件以为OS就要当场结束了（悲），还好没权限，不说了，先去换条裤子T-T。</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><h3 id="cp-选项-源文件-目标路径"><a href="#cp-选项-源文件-目标路径" class="headerlink" title="cp [选项] 源文件 目标路径"></a>cp [选项] 源文件 目标路径</h3><p>将源文件（也可以是目录）复制为目标路径对应的文件（如果目标路径是文件）或复制到目标路径（如果目标路径是目录）。</p><h3 id="cp-r-源文件-目标路径"><a href="#cp-r-源文件-目标路径" class="headerlink" title="cp -r 源文件 目标路径"></a>cp -r 源文件 目标路径</h3><p>递归复制目录及其子目录内的所有内容</p><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><h3 id="mv-选项-源文件-目标路径"><a href="#mv-选项-源文件-目标路径" class="headerlink" title="mv [选项] 源文件 目标路径"></a>mv [选项] 源文件 目标路径</h3><p>将源文件（也可以是目录）移动为目标路径对应的文件（如果目标路径是文件）或移动到目标路径（如果目标路径是目录）。</p><h3 id="mv-r-源文件-目标路径"><a href="#mv-r-源文件-目标路径" class="headerlink" title="mv -r 源文件 目标路径"></a>mv -r 源文件 目标路径</h3><p>递归移动目录及其子目录内的所有内容。</p><h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><h3 id="diff-b-文件1-文件2"><a href="#diff-b-文件1-文件2" class="headerlink" title="diff -b 文件1 文件2"></a>diff -b 文件1 文件2</h3><p>不检查空白字符的不同。</p><h3 id="diff-B-文件1-文件2"><a href="#diff-B-文件1-文件2" class="headerlink" title="diff -B 文件1 文件2"></a>diff -B 文件1 文件2</h3><p>不检查空行。</p><h3 id="diff-q-文件1-文件2"><a href="#diff-q-文件1-文件2" class="headerlink" title="diff -q 文件1 文件2"></a>diff -q 文件1 文件2</h3><p>仅显示有无差异，不显示详细信息。</p><h1 id="Vim操作"><a href="#Vim操作" class="headerlink" title="Vim操作"></a>Vim操作</h1><h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><p>vim 文件名（同目录下）<br>vim 绝对路径</p><h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><p>按I</p><h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>1.ESC<br>2.左shift+;</p><h2 id="保存退出"><a href="#保存退出" class="headerlink" title="保存退出"></a>保存退出</h2><p>输入:wq</p><h1 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h1><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h3 id="find-路径-lt-选项-gt"><a href="#find-路径-lt-选项-gt" class="headerlink" title="find [路径] &lt;选项&gt;"></a>find [路径] &lt;选项&gt;</h3><p>在给定路径下递归地查找文件，输出符合要求的文件的路径。如果没有给定路径，则在当前目录下查找。</p><h3 id="find-路径-name-lt-文件名-gt"><a href="#find-路径-name-lt-文件名-gt" class="headerlink" title="find [路径] -name &lt;文件名&gt;"></a>find [路径] -name &lt;文件名&gt;</h3><p>指定查找文件名字</p><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><p>根据文件属性找文件</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><h3 id="grep-选项-PATTERN-FILE"><a href="#grep-选项-PATTERN-FILE" class="headerlink" title="grep [选项] PATTERN FILE"></a>grep [选项] PATTERN FILE</h3><p>（PATTERN是匹配字符串，FILE是文件或目录的路径）</p><h3 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a>选项</h3><p>-a              不忽略二进制数据进行搜索。<br>-i              忽略大小写差异。<br>-r              从目录中递归查找。<br>-n              显示行号。</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>Ctrl+C 终止当前程序<br>Ctrl+Z 挂起当前程序<br>Ctrl+D 终止当前输入<br>Ctrl+L 清屏<br>Ctrl+S 暂停终端<br>Ctrl+Q 恢复终端</p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>创建Makefile文件<br>文件格式如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target: dependencies</span><br><span class="line">    command <span class="number">1</span></span><br><span class="line">    command <span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    command n</span><br></pre></td></tr></table></figure><br>例如，构建HelloWorld:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">all: hello</span><br><span class="line"></span><br><span class="line">hello: hello.c</span><br><span class="line">    gcc -o hello hello.c</span><br></pre></td></tr></table></figure></p><h1 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h1><p>ctags 是一个方便代码阅读的工具，我们用到的功能是代码跳转功能。</p><h2 id="食用方法"><a href="#食用方法" class="headerlink" title="食用方法"></a>食用方法</h2><p>转自OS教程：<br>hello.c:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ctags_test.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pair</span> p;</span><br><span class="line">    p.a = <span class="number">1</span>;</span><br><span class="line">    p.b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ctags_test.h:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ctags_test.h&quot;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>保存并退出 Vim，执行命令 ctags -R *，就会发现在该目录下出现了新的文件 tags——这是 ctags 为我们创建的符号名索引文件。此时我们就能使用 ctags 的功能了.<br>使用 Vim 打开 hello.c 文件，将光标移动到 a 或 b 上，按下 Ctrl+]，就可以跳转到结构体中 a或 b 的定义处。再按下 Ctrl+O就可以返回跳转前的位置。</p><h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><h2 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h2><p>输入tmux</p><h2 id="左右分屏"><a href="#左右分屏" class="headerlink" title="左右分屏"></a>左右分屏</h2><p>Ctrl+B后%</p><h2 id="上下分屏"><a href="#上下分屏" class="headerlink" title="上下分屏"></a>上下分屏</h2><p>Ctrl+B后”</p><h2 id="切换窗格"><a href="#切换窗格" class="headerlink" title="切换窗格"></a>切换窗格</h2><p>Ctrl+B后上下左右</p><h2 id="关闭窗格"><a href="#关闭窗格" class="headerlink" title="关闭窗格"></a>关闭窗格</h2><p>Ctrl+B后X</p><h2 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h2><p>Ctrl+B后D</p><h2 id="查看会话"><a href="#查看会话" class="headerlink" title="查看会话"></a>查看会话</h2><p>tmux ls</p><h2 id="恢复会话"><a href="#恢复会话" class="headerlink" title="恢复会话"></a>恢复会话</h2><p>tmux a -t 会话名称</p><h1 id="Git常用"><a href="#Git常用" class="headerlink" title="Git常用"></a>Git常用</h1><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>把当前目录变成一个空的 Git 仓库</p><h2 id="git-clone-URL"><a href="#git-clone-URL" class="headerlink" title="git clone (URL)"></a>git clone (URL)</h2><p>克隆一个已有的储存库到当前目录下</p><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>查看当前分支的状态</p><h2 id="git-add-filename"><a href="#git-add-filename" class="headerlink" title="git add (filename)"></a>git add (filename)</h2><p>一个新文件或者已经修改过的文件加入暂存区中<br>一般用：git add .（全部添加）</p><h2 id="git-restore"><a href="#git-restore" class="headerlink" title="git restore"></a>git restore</h2><p>git restore (filename)  来撤销文件修改，回退上一个commit。 (未add)<br>git restore —staged (filename)  取消暂存。 (已add)</p><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>git checkout 分支名称<br>切换分支</p><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>git commit -m <message> 将暂存区的修改提交到储存库中</p><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>本地的 commit 推送到一个远程仓库</p><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>将远程新建的分支下载到本地并合并</p><h1 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h1><h2 id="添加运行权限"><a href="#添加运行权限" class="headerlink" title="添加运行权限"></a>添加运行权限</h2><p>chmod +x 文件名</p><h2 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h2><h3 id="第一行"><a href="#第一行" class="headerlink" title="第一行"></a>第一行</h3><p>指定脚本的默认运行程序<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br></pre></td></tr></table></figure><br>这里指定Bash</p><h3 id="第二行"><a href="#第二行" class="headerlink" title="第二行"></a>第二行</h3><p>可选注释</p><h3 id="第三行"><a href="#第三行" class="headerlink" title="第三行"></a>第三行</h3><p>正文程序</p><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>无需指定类型<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var_name=value</span><br></pre></td></tr></table></figure></p><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\$var_name</span><br></pre></td></tr></table></figure><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>$1,$2,$3……<br>$# 传递的参数个数<br>$* 一个字符串，内容是传递的全部参数</p><h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1</span><br><span class="line">then</span><br><span class="line">    command11</span><br><span class="line">    command12</span><br><span class="line">    ......</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    command21</span><br><span class="line">    command22</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    command31</span><br><span class="line">    command32</span><br><span class="line">    ......</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">fun_name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    body...</span><br><span class="line">    <span class="keyword">return</span> int_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>function 和 () 可以省略其中一个。<br>返回语句可选，一般返回[0,255]之间的整数。</p><h4 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun_name param1 param2 ... paramN</span><br></pre></td></tr></table></figure><h1 id="重定向和管道"><a href="#重定向和管道" class="headerlink" title="重定向和管道"></a>重定向和管道</h1><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><h3 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h3><p>> 是 1&gt; 的简写<br>>覆盖原文<br>>&gt;追加原文最后</p><h3 id="标准错误输出"><a href="#标准错误输出" class="headerlink" title="标准错误输出"></a>标准错误输出</h3><p>使用2&gt;</p><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 | command2 | command3 | ...</span><br></pre></td></tr></table></figure><p>以上内容是将 command1 的输出传给 command2 的输入，command2 的输出传给 command3 的输入，以此类推….</p><h1 id="Sed"><a href="#Sed" class="headerlink" title="Sed"></a>Sed</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>sed [选项] ‘命令’ 输入文本</p><h2 id="选项-2"><a href="#选项-2" class="headerlink" title="选项"></a>选项</h2><p>-n：安静模式，只显示经过sed处理的内容。否则显示输入文本的所有内容。<br>-i：直接修改读取的档案内容，而不是输出到屏幕。否则，只输出不编辑。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>&lt;行号&gt;a&lt;内容&gt;： 新增，在行号后新增一行相应内容。行号可以是“数字”，在这一行之后新增，也可以是“起始行，终止行”，在其中的每一行后新增。当不写行号时，在每一行之后新增。使用$表示最后一行。后面的命令同理。<br>&lt;行号&gt;c&lt;内容&gt;：取代。用内容取代相应行的文本。<br>&lt;行号&gt;i&lt;内容&gt;：插入。在当前行的上面插入一行文本。<br>&lt;行号&gt;d：删除当前行的内容。<br>&lt;行号&gt;p：输出选择的内容。通常与选项-n一起使用。<br>s/(re)/(string)：将(re)（正则表达式）匹配的内容替换为(string)。</p>]]></content>
      
      
      <categories>
          
          <category> Unix &amp; Linux 系统学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> OS学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIPS微系统设计注意事项</title>
      <link href="/posts/39608/"/>
      <url>/posts/39608/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P8的一些注意事项</font></strong></p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>如果大家是以P8课下的身份来到这个，笔者首先恭喜大家来到P8，计组实验最终回。<br>P8，是笔者认为debug de起来最痛苦的一个Project,没有之一。这是因为<font color="red">P8作为板级验证的Project，是最接近硬件的一个Project,而硬件Bug一般是难以定位的。</font> </p><font color="purple">特别是ISE十分万恶，有些不可综合的语句不会给你做出相关警报，只会一声不吭的切割掉整个CPU,然后让你的CPU上板则寄，笔者被活活折磨了好几天</font></br><font color="green">因此，笔者认为出一篇注意事项的博客是很有必要的，话不多说，Here We Go!</font>    <h1 id="不可综合"><a href="#不可综合" class="headerlink" title="不可综合"></a>不可综合</h1><p>在Verilog中，有很多语句是不可综合的，我们在P8要避免出现这种情况。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>（1）不使用initial。</strong><br>（2）不使用#10。<br>（3）不使用循环次数不确定的循环语句，如forever、while等。<br>（4）不使用用户自定义原语（UDP元件）。<br>（5）尽量使用同步方式设计电路。<br>（6）除非是关键路径的设计，一般不采用调用门级元件来描述设计的方法，建议采用行为语句来完成设计。<br><strong>（7）用always过程块描述组合逻辑，应在敏感信号列表中列出所有的输入信号。</strong><br>（8）所有的内部寄存器都应该能够被复位，在使用FPGA实现设计时，应尽量使用器件的全局复位端作为系统总的复位。<br><strong>（9）对时序逻辑描述和建模，应尽量使用非阻塞赋值方式。对组合逻辑描述和建模，既可以用阻塞赋值，也可以用非阻塞赋值。但在同一个过程块中，最好不要同时用阻塞赋值和非阻塞赋值。</strong><br><strong>（10）不能在一个以上的always过程块中对同一个变量赋值。而对同一个赋值对象不能既使用阻塞式赋值，又使用非阻塞式赋值。</strong><br>（11）如果不打算把变量推导成锁存器，那么必须在if语句或case语句的所有条件分支中都对变量明确地赋值。<br>（12）避免混合使用上升沿和下降沿触发的触发器。<br>（13）同一个变量的赋值不能受多个时钟控制，也不能受两种不同的时钟条件（或者不同的时钟沿）控制。<br><strong>（14）避免在case语句的分支项中使用x值或z值。</strong></p><h2 id="不可综合语句"><a href="#不可综合语句" class="headerlink" title="不可综合语句"></a>不可综合语句</h2><p>（1）initial<br>只能在test bench中使用，不能综合。<br>（2）events<br>event在同步test bench时更有用，不能综合。<br>（3）real<br>不支持real数据类型的综合。<br>（4）time<br>不支持time数据类型的综合。<br>（5）force 和release<br>不支持force和release的综合。<br>(6）assign 和deassign<br>不支持对reg 数据类型的assign或deassign进行综合，支持对wire数据类型的assign或deassign进行综合。<br>(7) fork join<br>不可综合，可以使用非块语句达到同样的效果。<br>(8) primitives<br>支持门级原语的综合，不支持非门级原语的综合。<br>(9) table<br>不支持UDP 和table的综合。<br><strong>(10) 敏感列表里同时带有posedge和negedge</strong><br>如：always @(posedge clk or negedge clk) begin…end<br>这个always块不可综合。<br>(11) 同一个reg变量被多个always块驱动<br>(12) 延时<br>以#开头的延时不可综合成硬件电路延时，综合工具会忽略所有延时代码，但不会报错。<br>如：a=#10 b;<br>这里的#10是用于仿真时的延时，在综合的时候综合工具会忽略它。也就是说，在综合的时候上式等同于a=b;<br><strong>(13) 与X、Z的比较</strong><br>可能会有人喜欢在条件表达式中把数据和X(或Z)进行比较，殊不知这是不可综合的，综合工具同样会忽略。所以要确保信号只有两个状态：0或1。</p><font color="green">这个是最坑的，笔者就是死在了这里，一定不能用“!==”和“===”，这个综合错误ISE不会报出，因此极难De出</font> <h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>以上转载自<a href="https://zhuanlan.zhihu.com/p/146034068">https://zhuanlan.zhihu.com/p/146034068</a> ，侵删</p><h1 id="回显少值"><a href="#回显少值" class="headerlink" title="回显少值"></a>回显少值</h1><p><img src="回显少值.png" alt="数据示意1"><br>本来是4个5，但回显只有3个5，有时候有4个5，这个bug也是比较难以处理，经过对于UART_tx和UART_rx的研究，意识到丢5的可能性只能在于我原先的设计中，命令UART_tx发送的开始信号只有一周期，不管UART_tx什么状态，所以可能出现UART_tx不处于IDLE状态而给UART_tx一个开始信号，这时候这个开始信号将被忽略，导致本次发送被忽略，所以更改代码，利用UART_avi信号，开始信号将一直置高，直到UART_avi有效，这时候可以表明这个开始信号一定会被接收，所以可以放心置0，解决了这个问题。</p><h1 id="强制板子下线"><a href="#强制板子下线" class="headerlink" title="强制板子下线"></a>强制板子下线</h1><p>（然后这个板子就会消失在可选列表中10-15分钟不等）<br><strong>注意</strong>，此种现象的发生并非网络问题，而是源于串口短时间内回显大量数据，炸掉了串口缓冲区导致的板子崩溃下线，之所以发生这个问题是由于，Req处理的不合理导致的，如图：<br><img src="问题出现.png" alt="数据示意1"><br>仔细观察，会发现D_PC为0x4180时，会出现两条指令，若前面那条指令没有在D级执行的操作，则无需考虑，反正到E级时候会被清掉，但若此指令如图中一般是在D级就有操作的beq指令，则该beq仍会执行，而众所周知beq的跳转其实只是相对位置，所以他会在0x4180上进行错误跳转，导致程序出错，为了解决这个问题，我同样同步化了Req信号用来控制ID_Instr_Real，代码如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">reg</span> Delay_Stall_sign;</span><br><span class="line">    <span class="keyword">reg</span> Delay_Req_sign;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(reset||Req) <span class="keyword">begin</span></span><br><span class="line">        Delay_Stall_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">  Delay_Req_sign &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        ID_Instr_MEM &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Stall_sign)  <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(Delay_Stall_sign) <span class="keyword">begin</span></span><br><span class="line">ID_Instr_MEM &lt;=  ID_Instr_MEM; </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">ID_Instr_MEM &lt;= ID_Instr_Wire;  </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">        Delay_Stall_sign &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        ID_Instr_MEM &lt;= ID_Instr_Wire; </span><br><span class="line">        Delay_Stall_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">  Delay_Req_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] ID_Instr_Wire;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] ID_Instr_MEM;</span><br><span class="line">    <span class="keyword">assign</span> ID_Instr_Wire = F_Instr;</span><br><span class="line">    <span class="keyword">assign</span> ID_Instr_Real =  (F_PC == <span class="number">32&#x27;h3000</span> || Delay_Req_sign) ? <span class="number">32&#x27;d0</span> :</span><br><span class="line">(Delay_Stall_sign) ? ID_Instr_MEM : ID_Instr_Wire;</span><br><span class="line">解决后如图，在进入异常处理程序时，第一个错误指令将被抹除，变为<span class="number">32&#x27;d0</span>：</span><br></pre></td></tr></table></figure><br><img src="问题解决.png" alt="数据示意1"> </p><h1 id="回显异常和计时器异常冲突"><a href="#回显异常和计时器异常冲突" class="headerlink" title="回显异常和计时器异常冲突"></a>回显异常和计时器异常冲突</h1><p>在实现计时器功能时，若采用TC模块，则不得不考虑一个问题，由于UART回显必须全过程支持，所以回显通过异常实现，当接受完毕时，UART模块产生中断信号执行回显指令，但TC也会在每一秒产生中断信号，在异常处理程序中实现计数减1，输出到数码管等工作，但异常程序入口只有一个，那就是0x4180，若不做处理，则不管谁发出中断信号，两个中断处理程序都将处理一遍，那么现在就需要一个信号甄别这个中断到底是谁引起的，环顾CP0，发现没有这种信号，唯一有可能的HWINT是每周期都会更新，根本来不及接受它的值，所以，我对CP0进行了<strong>魔改</strong>，将HWINT转变为了只会在进入异常程序时更新，这样，我们可以通过Cause寄存器哪一位置为1找出当前中断是谁引起的，用beq进行区分，防止中断进行互相干扰，有了区分的数据，我们的问题便得到了解决。<br><img src="魔改CP0.png" alt="数据示意1"> </p><h1 id="接入乘除法器与外设驱动模块注意事项"><a href="#接入乘除法器与外设驱动模块注意事项" class="headerlink" title="接入乘除法器与外设驱动模块注意事项"></a>接入乘除法器与外设驱动模块注意事项</h1><h2 id="接入乘除法器"><a href="#接入乘除法器" class="headerlink" title="接入乘除法器"></a>接入乘除法器</h2><p>删去原有的MDU中乘除执行语句，主要是包含“<em>“与“/”的语句，因为他们不可综合，之后将教程所给的乘除按<strong>E_MDU-&gt;MulDivUnit-&gt;MulUnit</strong>和<em>*E_MDU-&gt;MulDivUnit-&gt;DivUnit</em></em>的结构生成模块并复制导入，如图：<br><img src="层次结构.png" alt="数据示意1"><br>之后则根据接口进行连线，将顶层MulDivUnit所需信号在E_MDU生成接入即可，如图：<br><img src="E_MDU.png" alt="数据示意1"><br>连线的时候其实无需做太大的改动，只需意识到原来乘法除法语句让MulDivUnit模块执行，相当于一个等价替换，即可做最小的改动。</p><h2 id="接入外设驱动模块"><a href="#接入外设驱动模块" class="headerlink" title="接入外设驱动模块"></a>接入外设驱动模块</h2><p>P7已经做下了很好的铺垫，只需继续在系统桥上添加新接口即可，如图：<br><img src="系统桥.png" alt="数据示意1"><br>我们要做的不过是延长代码,但事情显然不会这么简单，注意到DM也是接在Bridge上的，但DM已经今非昔比，它变成了一个时序模块，即需要Clk信号，<br><img src="总图.png" alt="数据示意1"><br>在上升沿才能读出数据，如果只是按原来的处理，其余外设正常工作，DM会出问题，因为他的读已经区别于了其他模块，为了消除这种区别，我直接将所有的模块读全部变为了同步读。实现如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(reset) <span class="keyword">begin</span></span><br><span class="line">TC1_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">UART_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">Digital_Tube_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">Switch_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">User_Key_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">LED_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">HitTC1_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitDM_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitUART_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitDigital_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitSwitch_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitUserKey_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitLED_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">TC1_RD_S &lt;= TC1_RD;</span><br><span class="line">UART_RD_S &lt;= UART_RD;</span><br><span class="line">Digital_Tube_RD_S &lt;= Digital_Tube_RD;</span><br><span class="line">Switch_RD_S &lt;= Switch_RD;</span><br><span class="line">User_Key_RD_S &lt;= User_Key_RD;</span><br><span class="line">LED_RD_S &lt;= LED_RD;</span><br><span class="line">HitTC1_S &lt;= HitTC1;</span><br><span class="line">HitDM_S &lt;= HitDM;</span><br><span class="line">HitUART_S &lt;= HitUART;</span><br><span class="line">HitDigital_S &lt;= HitDigital;</span><br><span class="line">HitSwitch_S &lt;= HitSwitch;</span><br><span class="line">HitUserKey_S &lt;= HitUserKey;</span><br><span class="line">HitLED_S &lt;= HitLED;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>我将所有HitXX信号都存了一周期，将除了DM的读出数据都存了一周期，让本来在上一周期读出的数据读出在了下一周期，这样人为的将除了DM之外的外设变成了同步读，和DM行为同步，保证了系统桥稳定正确工作。<br>唯一特殊的就是UART，但类似于MDU的处理，生成了<strong>UART-&gt;UART_TX</strong>和<strong>UART-&gt;UART_RX</strong>的结构，连线在UART完成，即可归一化解决UART的问题。如图：<br><img src="UART.png" alt="数据示意1"> </p><h1 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h1><h3 id="1-拒绝过度优化"><a href="#1-拒绝过度优化" class="headerlink" title="1.拒绝过度优化"></a>1.拒绝过度优化</h3><p>如果实在是害怕优化使得CPU功能出现错误，可以加入(*KEEP = “TRUE”*)在寄存器，wire前面，则综合时不管这个寄存器或者线路多没用，综合器也不会将其优化掉。<br><img src="KEEP.png" alt="数据示意1"></p><h3 id="2-调教（bushi-ISE"><a href="#2-调教（bushi-ISE" class="headerlink" title="2.调教（bushi)ISE"></a>2.调教（bushi)ISE</h3><p><img src="ISE设置.png" alt="数据示意1"><br>如上所示，右键XST将优化调整如上可以保留层次结构，避免一些不同层次相同命名去掉层次结构时可能引起的冲突问题。</p><h1 id="自动生成IP核可用-coe文件"><a href="#自动生成IP核可用-coe文件" class="headerlink" title="自动生成IP核可用.coe文件"></a>自动生成IP核可用.coe文件</h1><p>这是一个用Python实现的小玩意，运行此程序可以将同一目录下的test.asm转换成IP核可用的test.coe，且直接存放到ipcore_dir目录下，便于选择。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>更改dir_name_3目录为自己CPU的ipcore_dir即可</p><h2 id="代码呈现"><a href="#代码呈现" class="headerlink" title="代码呈现"></a>代码呈现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> filestools</span><br><span class="line"><span class="keyword">from</span> filediff.diff <span class="keyword">import</span> file_diff_compare</span><br><span class="line">dir_name_3 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P8\\The End\\FlowCpu\\ipcore_dir\\&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mar</span>(<span class="params">test_order</span>):</span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText a dump .text HexText machine.txt nc test.asm&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText a dump 0x00004180-0x00006000 HexText handler.txt nc test.asm&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;机器码合成.exe&quot;</span>)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;code.coe&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name_3 + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.coe&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText nc db lg ex me 65536 test.asm &gt; mar.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_mar(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="Mar代码"><a href="#Mar代码" class="headerlink" title="Mar代码"></a>Mar代码</h1><p>2022年P8要求实现功能：在一个Mars文件中同时实现计算器，计时器并全程带有串口回显功能。代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">#PC 初始值0x3000</span><br><span class="line">#异常中断入口0x4180</span><br><span class="line">#数据存储器0x0000 - 0x2FFF</span><br><span class="line">#指令存储器0x3000 - 0x6FFF</span><br><span class="line">#定时器        0x7F00 - 0x7F0B</span><br><span class="line">#UART        0x7F30 - 0x7F3F</span><br><span class="line">#数码管        0x7F50 - 0x7F57</span><br><span class="line">#拨码开关       0x7F60 - 0x7F67</span><br><span class="line">#按键开关        0x7F68 - 0x7F6B</span><br><span class="line">#LED        0x7F70 - 0x7F73</span><br><span class="line">.text</span><br><span class="line">#打开中断</span><br><span class="line">ori $t1,0x1100</span><br><span class="line">sw $t1,0x7F70($0)</span><br><span class="line">nop</span><br><span class="line">ori $t3,0XFC01</span><br><span class="line">mtc0 $t3,$12</span><br><span class="line"></span><br><span class="line">#模式切换</span><br><span class="line">lw $s3,0x7F68($0)</span><br><span class="line">andi $s6,$s3,3</span><br><span class="line">li $s0,1</span><br><span class="line">li $s1,2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bne $s6,$s0,cal</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">tim:</span><br><span class="line">#计时器模式</span><br><span class="line">li $t7,0</span><br><span class="line">li $t3,25000000 #配置1s</span><br><span class="line">sw $t3,0x7F04($0) #配置1s</span><br><span class="line">li $t3,0xB #配置计时器</span><br><span class="line">sw $t3,0x7F00($0) #配置计时器</span><br><span class="line">lw $s4,0x7F60($0) #读入计时数据</span><br><span class="line">move $t4,$s4 #复制计时数据</span><br><span class="line">andi $s7,$s3,4</span><br><span class="line">beq $s7,$0,Adda_1</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#减法最大数</span><br><span class="line">Suba_1:</span><br><span class="line">sw $s4,0x7F50($0)</span><br><span class="line">jal wait</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#加法最大数</span><br><span class="line">Adda_1:</span><br><span class="line">sw $0,0x7F50($0)</span><br><span class="line">jal wait</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#判断初值是否改变</span><br><span class="line">Judge:</span><br><span class="line">lw $s7,0x7F60($0)</span><br><span class="line">beq $s7,$s4,wait</span><br><span class="line">nop</span><br><span class="line">jal tim</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#等待中断</span><br><span class="line">wait:</span><br><span class="line">beq $0,$0,wait</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#计时结束</span><br><span class="line">jal end_time</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#结束标志</span><br><span class="line">end_time:</span><br><span class="line">ori $t1,$0,1</span><br><span class="line">sw $t1,0x7F70($0)</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#结尾循环</span><br><span class="line">end_1:beq $0,$0,end_1</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cal:</span><br><span class="line">bne $s6,$s1,end</span><br><span class="line">nop</span><br><span class="line">#计算器模式</span><br><span class="line">calc:</span><br><span class="line">andi $s6,$s3,0XFC</span><br><span class="line">addu $a1,$s6,$0</span><br><span class="line">lw $t1,0x7F64($0)</span><br><span class="line">lw $t2,0x7F60($0)</span><br><span class="line">#加</span><br><span class="line">addd:</span><br><span class="line">li $a0,4</span><br><span class="line">bne $s6,$a0,subb</span><br><span class="line">nop</span><br><span class="line">addu $t3,$t1,$t2</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#减</span><br><span class="line">subb:</span><br><span class="line">li $a0,8</span><br><span class="line">bne $s6,$a0,multt</span><br><span class="line">nop</span><br><span class="line">subu $t3,$t1,$t2</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#乘</span><br><span class="line">multt:</span><br><span class="line">li $a0,16</span><br><span class="line">bne $s6,$a0,divv</span><br><span class="line">nop</span><br><span class="line">mult $t1,$t2</span><br><span class="line">mflo $t3</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#除</span><br><span class="line">divv:</span><br><span class="line">li $a0,32</span><br><span class="line">bne $s6,$a0,andd</span><br><span class="line">nop</span><br><span class="line">div $t1,$t2</span><br><span class="line">mflo $t3</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#与</span><br><span class="line">andd:</span><br><span class="line">li $a0,64</span><br><span class="line">bne $s6,$a0,orr</span><br><span class="line">nop</span><br><span class="line">and $t3,$t1,$t2</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#或</span><br><span class="line">orr:</span><br><span class="line">li $a0,128</span><br><span class="line">bne $s6,$a0,end_cal</span><br><span class="line">nop</span><br><span class="line">or $t3,$t1,$t2</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#输出结果</span><br><span class="line">output:</span><br><span class="line">sw $t3,0x7F50($0)</span><br><span class="line"></span><br><span class="line">#计算结束</span><br><span class="line">end_cal:</span><br><span class="line">lw $s3,0x7F68($0)</span><br><span class="line">andi $s6,$s3,0XFC</span><br><span class="line">beq $s6,$a1,nochange</span><br><span class="line">nop</span><br><span class="line">beq $s6,$0,nochange</span><br><span class="line">nop</span><br><span class="line">jal calc</span><br><span class="line">nop</span><br><span class="line">nochange:</span><br><span class="line">beq $0,$0,end_cal</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#全程序结束</span><br><span class="line">end:</span><br><span class="line">beq $0,$0,end</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.ktext 0x4180 #魔改CP0 INT</span><br><span class="line">#判断异常类型</span><br><span class="line">mfc0 $s5,$13</span><br><span class="line">andi $s5,$s5,0x400</span><br><span class="line">beq $s5,$0,UART</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#计时模块</span><br><span class="line"></span><br><span class="line">Timing:</span><br><span class="line"></span><br><span class="line">#回退检测</span><br><span class="line">mfc0 $k0,$14</span><br><span class="line">addi $k0,$k0,-20</span><br><span class="line">mtc0 $k0,$14</span><br><span class="line"></span><br><span class="line">#判断增减</span><br><span class="line">andi $s7,$s3,4</span><br><span class="line">beq $s7,$0,Adda</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#减</span><br><span class="line">Suba:</span><br><span class="line">sub $t4,$t4,$s0</span><br><span class="line">sw $t4,0x7F50($0)</span><br><span class="line">beq $t4,$0,endtime</span><br><span class="line">nop</span><br><span class="line">jal Endhandler</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#增</span><br><span class="line">Adda:</span><br><span class="line">addi $t7,$t7,1</span><br><span class="line">sw $t7,0x7F50($0)</span><br><span class="line">beq $t7,$s4,endtime</span><br><span class="line">nop</span><br><span class="line">jal Endhandler</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#计时结束</span><br><span class="line">endtime:</span><br><span class="line">sw $0,0x7F00($0)</span><br><span class="line">mfc0 $k0,$14</span><br><span class="line">addi $k0,$k0,24</span><br><span class="line">mtc0 $k0,$14</span><br><span class="line">jal Endhandler</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#回显模块</span><br><span class="line">UART:</span><br><span class="line">lw $a2,0x7F30($0)</span><br><span class="line">sw $a2 0x7F30($0)</span><br><span class="line"></span><br><span class="line">Endhandler:</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">eret</span><br></pre></td></tr></table></figure></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>更多信息查看我的Github仓库-&gt; <a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P8">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P8</a><br>这是最后一个Project,相信走到这里的各位一定都很有所感触，笔者在这里祝大家武运昌隆！</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断支持流水线CPU设计文档（Verilog）</title>
      <link href="/posts/14079/"/>
      <url>/posts/14079/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Verilog 异常中断支持流水线CPU设计文档</center></font></strong></p><h1 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h1><h2 id="总体设计综述"><a href="#总体设计综述" class="headerlink" title="总体设计综述"></a>总体设计综述</h2><p>使用Verilog开发一个流水线CPU,总体概述如下：<br>1.此流水线CPU为32位CPU<br>2.此CPU为流水线设计<br>3.此CPU支持的指令集为:{add,sub,and,or,slt,sltu,addi,andi,ori,lb,lh,lw,sb,sh,sw,mult,multu,div,divu,mfhi,mflo,mthi,mtlo,beq,bne,lui,jal,jr,nop,mtc0,mfc0,syscall}<br>4.nop的机器码为0x0000000<br>5.该CPU支持对来自计数器和外部的中断进行处理<br>6，该CPU支持对于部分异常进行处理，例如字不对齐，存取位置异常，溢出异常等</p><h2 id="关键模块定义"><a href="#关键模块定义" class="headerlink" title="关键模块定义"></a>关键模块定义</h2><h3 id="IM-外置"><a href="#IM-外置" class="headerlink" title="IM(外置)"></a>IM(外置)</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i_inst_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">需要进行取指操作的流水级 PC（一般为 F 级）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i_inst_rdata[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">i_inst_addr 对应的 32 位指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">取指</td><td style="text-align:center">利用PC取出对应位置处的指令</td></tr></tbody></table></div><h3 id="F-PC"><a href="#F-PC" class="headerlink" title="F_PC"></a>F_PC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前PC值</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">更改PC值</td><td style="text-align:center">利用NPC更改PC值</td></tr></tbody></table></div><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">A3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其作为RD的写入地址</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位写入数据</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A2指定寄存器的32位数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号，清零32个寄存器中的数据</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">同步复位</td><td style="text-align:center">时钟上升沿到来时，若RESET信号有效，则将32个寄存器中的数据全部清除</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A1与A2所存地址对应的寄存器的数据读出到RD1和RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD写入到A3所存地址对应的寄存器中</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">转发数据</td><td style="text-align:center">当A3\==A2或A3\==A1且WE有效，A3!=0时，将WD中的数据作为RD1或RD2的输出</td></tr></tbody></table></div><h3 id="IF-ID-REG"><a href="#IF-ID-REG" class="headerlink" title="IF_ID_REG"></a>IF_ID_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">IF_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段机器码</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">IF_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">ID阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">O</td><td style="text-align:center">扩展类型信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">O</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RegWrite</td><td style="text-align:center">O</td><td style="text-align:center">寄存器写使能信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MemWrite</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">MemToReg[2:0]</td><td style="text-align:center">O</td><td style="text-align:center">Reg写入数据类型信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">RegDest[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">A3寄存器选择信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ALUop[3:0]</td><td style="text-align:center">O</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">O</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">O</td><td style="text-align:center">Jr信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">RegSrc</td><td style="text-align:center">O</td><td style="text-align:center">ALU数据来源选择信号</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">imm16[15:0]</td><td style="text-align:center">O</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">imm26[25:0]</td><td style="text-align:center">O</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">rs[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rs寄存器编号</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">rt[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rt寄存器编号</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">rd[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rd寄存器编号</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">load</td><td style="text-align:center">O</td><td style="text-align:center">是否为lw指令</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">store</td><td style="text-align:center">O</td><td style="text-align:center">是否为sw指令</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">cal_r</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_r类指令</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">cal_i</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_i类指令</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">jal</td><td style="text-align:center">O</td><td style="text-align:center">是否为jal指令</td></tr></tbody></table></div><p>(2)真值表</p><div class="table-container"><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">add</th><th style="text-align:center">sub</th><th style="text-align:center">ori</th><th style="text-align:center">lw</th><th style="text-align:center">sw</th><th style="text-align:center">lui</th><th style="text-align:center">beq</th><th style="text-align:center">Jal</th><th style="text-align:center">Jr</th></tr></thead><tbody><tr><td style="text-align:center">OP</td><td style="text-align:center">000000</td><td style="text-align:center">000000</td><td style="text-align:center">001101</td><td style="text-align:center">100011</td><td style="text-align:center">101011</td><td style="text-align:center">001111</td><td style="text-align:center">000100</td><td style="text-align:center">000011</td><td style="text-align:center">000000</td></tr><tr><td style="text-align:center">FC</td><td style="text-align:center">100000</td><td style="text-align:center">100010</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">001000</td></tr><tr><td style="text-align:center">ALUop</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0011</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0100</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">Jump</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">RegWrite</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemWrite</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemToReg</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegDest</td><td style="text-align:center">01</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegSrc</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Branch</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jreg</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">B[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Equal</td><td style="text-align:center">O</td><td style="text-align:center">A==B？1：0</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">比较</td><td style="text-align:center">比较操作数A与B是否相等，相等则Equal有效</td></tr></tbody></table></div><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">F_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段的PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段的PC值</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Beq指令</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jal指令</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jr指令</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Jal_imm26[25:0]</td><td style="text-align:center">I</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">D_GRF_Jr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">Jr目标寄存器数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">Beq_imm16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">Equal</td><td style="text-align:center">I</td><td style="text-align:center">D_CMP两操作数是否相等</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">PC的下一值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">计算下一PC的值</td><td style="text-align:center">根据指令和当前PC值计算下一PC值</td></tr></tbody></table></div><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">经过扩展后的32位立即数</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">I</td><td style="text-align:center">选择扩展类型信号  0：符号扩展 1：无符号扩展</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">符号扩展</td><td style="text-align:center">将16位立即数符号扩展为32位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">无符号扩展</td><td style="text-align:center">将16位立即数无符号扩展为32位立即数</td></tr></tbody></table></div><h3 id="ID-EX-REG"><a href="#ID-EX-REG" class="headerlink" title="ID_EX_REG"></a>ID_EX_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_RD1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">D_imm32[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段32位立即数</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">EX_RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">EX_imm32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段32位立即数</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">EX阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ALUControl[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">运算结果</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">判断两个操作数是否相等</td><td style="text-align:center">相等则Bigger输出1否则为0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">加运算</td><td style="text-align:center">res=SrcA+SrcB</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">减运算</td><td style="text-align:center">res=SrcA-SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">与运算</td><td style="text-align:center">res=SrcA$SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">或运算</td><td style="text-align:center">res=SrcB或SrcB</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">加载高位运算</td><td style="text-align:center">res={SrcB[15:0],16’h0}</td></tr></tbody></table></div><h3 id="E-MDU"><a href="#E-MDU" class="headerlink" title="E_MDU"></a>E_MDU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">start</td><td style="text-align:center">I</td><td style="text-align:center">开始信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MDUop[2:0]</td><td style="text-align:center">I</td><td style="text-align:center">MDU功能选择信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">HIWrite</td><td style="text-align:center">I</td><td style="text-align:center">HI寄存器写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">LOWrite</td><td style="text-align:center">I</td><td style="text-align:center">LO寄存器写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">HIRead</td><td style="text-align:center">I</td><td style="text-align:center">读HI寄存器信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">LORead</td><td style="text-align:center">I</td><td style="text-align:center">读LO寄存器信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">HI[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">HI寄存器</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">LO[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">LO寄存器</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">busy</td><td style="text-align:center">O</td><td style="text-align:center">MDU模块忙信号</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">MDU_res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MDU结果信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">无符号乘</td><td style="text-align:center">{HI_temp,LO_temp} = SrcA * SrcB</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">符号乘</td><td style="text-align:center">{HI_temp,LO_temp} = $signed(SrcA) * $signed(SrcB)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">符号除</td><td style="text-align:center">HI = $signed(SrcA) % $signed(SrcB)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">符号除</td><td style="text-align:center">LO = $signed(SrcA) \ $signed(SrcB)</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">无符号除</td><td style="text-align:center">HI = SrcA % SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">无符号除</td><td style="text-align:center">LO = SrcA \ SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">读写HI寄存器</td><td style="text-align:center">mfhi读，mthi写</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">读写LO寄存器</td><td style="text-align:center">mflo读，mflo写</td></tr></tbody></table></div><h3 id="EX-MEM-REG"><a href="#EX-MEM-REG" class="headerlink" title="EX_MEM_REG"></a>EX_MEM_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">MEM_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">MEM阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="DM（外置）"><a href="#DM（外置）" class="headerlink" title="DM（外置）"></a>DM（外置）</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">m_data_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">m_data_rdata[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">32位数据输出</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">m_data_wdata[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位数据输入</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">m_inst_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">M级PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">m_inst_byteen[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">字节使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">写入数据</td><td style="text-align:center">当时钟上升沿到来时，根据字节使能信号中的有效位将WD中的数据写入到A所存地址所对应的位处</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A所存地址对应位置的数据读出到RD</td></tr></tbody></table></div><h3 id="M-CP0"><a href="#M-CP0" class="headerlink" title="M_CP0"></a>M_CP0</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">en</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">CP0Add[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">寄存器选择信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">CP0In[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">读入数据</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CP0Out[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">读出数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">VPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">受害PC</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">BDIn</td><td style="text-align:center">I</td><td style="text-align:center">延迟槽指令信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ExcCodeIn[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">异常类型</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">HWInt[5:0]</td><td style="text-align:center">I</td><td style="text-align:center">中断信号输入</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">EXLClr</td><td style="text-align:center">I</td><td style="text-align:center">EXL复位信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">EPCOut[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EPC值</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">Req</td><td style="text-align:center">O</td><td style="text-align:center">进入处理程序请求</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">配置异常</td><td style="text-align:center">根据EXL Cause SR信号不同位决定中断能否产生</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">记录异常</td><td style="text-align:center">利用SR Cause EPC记录异常信息</td></tr></tbody></table></div><h3 id="M-BE"><a href="#M-BE" class="headerlink" title="M_BE"></a>M_BE</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[1:0]</td><td style="text-align:center">I</td><td style="text-align:center">DM地址的低两位</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">DM读出数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Op[2:0]</td><td style="text-align:center">I</td><td style="text-align:center">BE功能选择</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">BE数据输出</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">处理DM数据</td><td style="text-align:center">根据A和OP处理数据，使其符合指令行为</td></tr></tbody></table></div><h3 id="MEM-WB-REG"><a href="#MEM-WB-REG" class="headerlink" title="MEM_WB_REG"></a>MEM_WB_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">MEM_DM_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段DM读出数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WB_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WB_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">WB_DM_RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段DM读出数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">WB_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">WB阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Stall"><a href="#Stall" class="headerlink" title="Stall"></a>Stall</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">D_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Stall</td><td style="text-align:center">O</td><td style="text-align:center">阻塞信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">阻塞功能</td><td style="text-align:center">判断当前流水线是否需要在ID阶段阻塞</td></tr></tbody></table></div><p>(3)判断方法——AT法</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">rsTuse</th><th style="text-align:center">rtTuse</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">slt</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sltu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">addi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">andi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lb</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lh</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sb</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">sh</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">bne</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">mult</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">multu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">div</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">divu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">mthi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mtlo</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">0</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mtc0</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">E_Tnew</th><th style="text-align:center">M_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">slt</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sltu</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">addi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">andi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">lh</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">lb</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sh</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sb</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mfhi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">mflo</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">bne</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mfc0</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><h4 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h4><pre><code>Stall_eret = (D_eret) &amp;&amp; ((E_mtc0 &amp;&amp; E_rd == 5&#39;d14) || (M_mtc0 &amp;&amp; M_rd == 5&#39;d14));</code></pre><h3 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">W_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_Forward</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">MEM_Forward</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">WB_Forward</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段数据是否可以转发信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">转发信号</td><td style="text-align:center">判断每个阶段是否可以为前面转发数据</td></tr></tbody></table></div><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><p>(1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">PrAddr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">CPU地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">PrRD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">读出到CPU的数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">PrWD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">读入到外设的数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">DevAddr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">外设地址</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">DevWD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">输出到外设的数据</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">TC1_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">来自TC1的数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">TC2_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">来自TC2的数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">DM_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">来自DM的数据</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">PrWe</td><td style="text-align:center">I</td><td style="text-align:center">桥写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">TC1_WE</td><td style="text-align:center">O</td><td style="text-align:center">TC1写使能信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">TC2_WE</td><td style="text-align:center">O</td><td style="text-align:center">TC2写使能信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">DM_WE</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">信息交换</td><td style="text-align:center">用于CPU和外设之间的信息交换</td></tr></tbody></table></div><p>19.TC</p><p>(1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Addr[31:2]</td><td style="text-align:center">I</td><td style="text-align:center">地址数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">读入数据</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">读出数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">IRQ</td><td style="text-align:center">O</td><td style="text-align:center">计时器中断信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">定时产生中断信号</td><td style="text-align:center">通过计数模式定期产生中断信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">模式0</td><td style="text-align:center">计数为0时，若不复位，持续产生IRQ信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">模式1</td><td style="text-align:center">计数为0时，产生一周期IRQ信号后重新计数</td></tr></tbody></table></div><h1 id="转发暂停控制"><a href="#转发暂停控制" class="headerlink" title="转发暂停控制"></a>转发暂停控制</h1><h2 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h2><pre><code>wire Stall_eret = (D_eret) &amp;&amp; ((E_mtc0 &amp;&amp; E_rd == 5&#39;d14) || (M_mtc0 &amp;&amp; M_rd == 5&#39;d14));wire Stall_MDU = busy &amp;&amp; ( D_MDU_c || D_MDU_f || D_MDU_t );wire Stall_rs_E = (E_RegDest == D_rs) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rs &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_rt_E = (E_RegDest == D_rt) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rt &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_E = Stall_rs_E || Stall_rt_E;wire Stall_rs_M = (M_RegDest == D_rs) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rs &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_rt_M = (M_RegDest == D_rt) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rt &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_M = Stall_rs_M || Stall_rt_M;assign Stall = Stall_M || Stall_E || Stall_MDU;     </code></pre><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><pre><code>wire [31:0] D_Forward_rs = (D_rs == 0)? 0 :            ((E_RegDest == D_rs) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :        ((M_RegDest == D_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD1;wire [31:0] D_Forward_rt = (D_rt == 0)? 0 :            ((E_RegDest == D_rt) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :            ((M_RegDest == D_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD2;wire [31:0] E_Forward_rs =   (E_rs == 0) ? 0 :        ((M_RegDest == E_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rs) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD1;wire [31:0] E_Forward_rt =   (E_rt == 0) ? 0 :        ((M_RegDest == E_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rt) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD2;wire [31:0] M_WD_Forward = (M_rt == 0) ? 0 :        ((W_RegDest == M_rt) &amp;&amp; (WB_Forward) &amp;&amp; (W_RegWrite)) ? W_MemToReg : MEM_RD2;</code></pre><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>为<strong>自动化测试，测试异常部分</strong>：<br>共随机生成1000组数据包括handler<br><img src="微信截图_20221106010804.png" alt="数据示意1"><br>并生成1000组比对文件<br><img src="微信截图_20221106010955.png" alt="数据示意2"><br>和一个总体结果文件<br><img src="微信截图_20221106011047.png" alt="数据示意3"></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="请查阅相关资料，说明鼠标和键盘的输入信号是如何被-CPU-知晓的？"><a href="#请查阅相关资料，说明鼠标和键盘的输入信号是如何被-CPU-知晓的？" class="headerlink" title="请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？"></a>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</h3><p>答：鼠标和键盘产生信息，这些信息或是被读到内存，或是被读到CPU的寄存器中，并同时产生中断信号，中断当前CPU的运行，CPU进入中断状态执行中断处理程序读入键盘和鼠标的信息进行处理。</p><h3 id="请思考为什么我们的-CPU-处理中断异常必须是已经指定好的地址？如果你的-CPU-支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）"><a href="#请思考为什么我们的-CPU-处理中断异常必须是已经指定好的地址？如果你的-CPU-支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）" class="headerlink" title="请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）"></a>请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</h3><p>答：我认为依旧可以实现，无非是需要更改一下CPU中当出现异常或中断时要跳转到的异常处理程序地址，之后由用户提供的程序依旧可以对中断和异常进行处理。但入口常常变动会导致该CPU的适用性降低，换个执行指令段执行可能就需要换个入口。</p><h3 id="为何与外设通信需要-Bridge？"><a href="#为何与外设通信需要-Bridge？" class="headerlink" title="为何与外设通信需要 Bridge？"></a>为何与外设通信需要 Bridge？</h3><p>答：外设实在是太多了，如果每个外设都要针对CPU做单独处理那么时间与经济成本实在是过于昂贵且没必要了，所以采用Bridge方式，通过一个 CPU 视图下的内存地址，读写相应数据即可达到与外设沟通的目的，统一化了外设，DM处理起来十分方便，且扩展性好，新加外设在系统桥进行添加即可，无需单独为其设计一套读写逻辑。</p><h3 id="请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。"><a href="#请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。" class="headerlink" title="请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。"></a>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</h3><p>答：相同之处：在允许计数的情况下，都是从初值寄存器中获取初数值到计数值寄存器中开始计数，两种模式都受控制寄存器的控制<br>区别之处：模式0在计数结束后，会一直提供中断信号，直到IM或者EN被修改使其禁止中断或停止计数，模式1在计数结束后，只会提供一周期的中断信号，然后自动再次赋初值开始计数，知道IM或者EN被修改行为才会被改变。<br><img src="模式零.jpg" alt="数据示意3"><br><img src="模式一.jpg" alt="数据示意3"></p><h3 id="倘若中断信号流入的时候，在检测宏观-PC-的一级如果是一条空泡（你的-CPU-该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在-P7-中，清空流水线产生的空泡指令应该保留原指令的哪些信息？"><a href="#倘若中断信号流入的时候，在检测宏观-PC-的一级如果是一条空泡（你的-CPU-该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在-P7-中，清空流水线产生的空泡指令应该保留原指令的哪些信息？" class="headerlink" title="倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？"></a>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</h3><p>答：会发生宏观PC出现0的情况，这显然是不合理的，所以应该保留原PC值。</p><h3 id="为什么-jalr-指令为什么不能写成-jalr-31-31？"><a href="#为什么-jalr-指令为什么不能写成-jalr-31-31？" class="headerlink" title="为什么 jalr 指令为什么不能写成 jalr 31,31？"></a>为什么 jalr 指令为什么不能写成 jalr 31,31？</h3><p>答：根据英文指令集的解释，该寄存器的rs和rd不能相等，因为这样的指令在重新执行时不会有相同的效果，执行这种指令的结果是UB，如果这样做了，假如延迟槽指令出现了异常，那么该异常是无法通过重新执行jalr来恢复执行的，因为$31寄存器的值已改变。</p><h3 id="请详细描述你的测试方案及测试数据构造策略。"><a href="#请详细描述你的测试方案及测试数据构造策略。" class="headerlink" title="请详细描述你的测试方案及测试数据构造策略。"></a>请详细描述你的测试方案及测试数据构造策略。</h3><p>答：本次P7我全覆盖测试了异常的产生，对于中断则测试了计时器中断，外部中断只能是找人对拍，Mars没有暴露外部中断的API，对于异常的产生，由于异常种类数量可以接受，为了保证覆盖率，我对于每种情况都在代码生成里进行了特定的判定，确保一但判断生效，则生成的代码必定会出现异常，例如随机一个判定，若判断为1，我会采取如下的方式构造PC异常：<br><img src="异常.png" alt="数据示意3"><br>这种构造保证了PC不对齐，PC溢出的问题一定会生成，且保证了PC的随机性，因为PC的值是随机的，提高测试强度。之后的一些诸如AdEL.AdEs都是采取这种半随机半特判的方式生成，主要是为了兼顾覆盖性与完备性。</p><p>其次我专门对延迟槽进行了构造处理，保证一个测试文件中至少有一个会出现延迟槽异常，其实也很简单，在延迟槽中加入syscall即可，<br><img src="异常2.png" alt="数据示意3"><br>再其次我也没有丢掉P6的数据生成，这些异常将夹杂在P6的正常代码生成之中生成，目的是防止在对CPU进行P7修改时破坏了P6的体系完整，利用这样的代码生成可以直接测出这个问题。</p><p>然后是一些特殊处理，我也在生成器中加入了会连续出现异常的可能性，便于测试该CPU能否连续处理异常，提高测试的完备性。SUB构造如图：<br><img src="异常3.png" alt="数据示意3"><br>最后我也实现了handler（异常处理模块）的生成，主题思路为，前面固定生成对于各类异常的处理，后面则是一些随机指令，注意这些随机指令中add用addu代替，sub用subu代替，addi用addiu代替，load,store确保不会溢出或字不对齐，目的是防止在异常处理程序中再次出现异常，使程序循环执行。<br>对于各类异常的处理，采用if思想的beq，若PC不对齐，则取其[31:2]位，若PC越界，则直接将EPC改为末尾的无限自循环PC值，结束程序，之后考虑若为延迟槽，则EPC+8,若不为延迟槽，则EPC+4，这些固定化的模块保证了异常得到妥善处理，并顺利结束程序。<br>eret后面有一个指令，用于测试eret的无延迟槽性。<br><img src="异常4.png" alt="数据示意3"><br>之后则是一些机器码的生成，另写了一个.cpp文件用于text和ktext的合并，中间则用Nop填充，最终实现了如同P6一般只需输入测试次数即可一键测试的效果。       </p><p>整体思路大概就是这样，如有不合适之处还请斧正，谢谢！具体实现可以参看我的CPU自动化提交文件中的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断支持流水线CPU全自动测试思路（Verilog）</title>
      <link href="/posts/47414/"/>
      <url>/posts/47414/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P7的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><font color="purple">由于P7是P6的迭代开发，因此本次工作将主要体现在数据生成上，而且由于Mars的局限性，我们将编写两个测试程序<b>（一个对拍Mars，一个对拍CPU）</b>，分别用于测试功能/异常和中断</font><h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><h2 id="导出0x4180位置处的机器码"><a href="#导出0x4180位置处的机器码" class="headerlink" title="导出0x4180位置处的机器码"></a>导出0x4180位置处的机器码</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars.jar mc LargeText a dump <span class="number">0</span>x00004180-<span class="number">0</span>x00006000 HexText handler.txt nc test.asm</span><br></pre></td></tr></table></figure><p>在Mars中，我们是无法导出0x4180位置的机器码的，但我们可以通过命令行进行导出，上面的命令行就是以16进制导出test.asm中的0x4180-0x6000位置处的机器码，导出到handler.txt文件中。  </p><h2 id="限制Mars运行指令数"><a href="#限制Mars运行指令数" class="headerlink" title="限制Mars运行指令数"></a>限制Mars运行指令数</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars.jar mc LargeText nc db lg ex me <span class="number">65536</span> test.asm &gt; mar.txt</span><br></pre></td></tr></table></figure><p>在P7中，最起码对于笔者来说，是经常会将程序指引向一个死循环的，所以我们需要给Mars设置指令条数上限，这样Mars才能结束运行，否则将会一直运行。指令中65536就是运行上限。</p><h1 id="机器码合成"><a href="#机器码合成" class="headerlink" title="机器码合成"></a>机器码合成</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在P7中，机器码被分为了两部分，正常程序部分从0x3000开始，异常处理部分从0x4180部分开始，但我们<strong>只能给CPU输入一个文件</strong>，所以我们就需要进行合成。<br>但合成仍然有一个问题，我们<strong>如何保证异常处理代码位于0X4180处？</strong>，毕竟很少有正常程序可以填充满0x3000-0x4180。在这种情况下直接合成则异常程序会低于0x4180。<br>因此我们需要添加Nop在正常程序后面，直到填充到0x4180位置，然后拼接异常处理机器码。 </p><h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> IM[<span class="number">5000</span>][<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* in;</span><br><span class="line">in = fopen(<span class="string">&quot;machine.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">fscanf</span>(in, <span class="string">&quot;%s&quot;</span>, IM[i])) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">fclose(in);</span><br><span class="line">FILE* handler;</span><br><span class="line">handler = fopen(<span class="string">&quot;handler.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">int</span> j = <span class="number">1120</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">fscanf</span>(handler, <span class="string">&quot;%s&quot;</span>, IM[j])) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">fclose(handler);</span><br><span class="line">freopen(<span class="string">&quot;code.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">5000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (IM[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;00000000\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, IM[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Python实现（数据执行器）"><a href="#Python实现（数据执行器）" class="headerlink" title="Python实现（数据执行器）"></a>Python实现（数据执行器）</h1><h2 id="异常-功能正确性测试"><a href="#异常-功能正确性测试" class="headerlink" title="异常/功能正确性测试"></a>异常/功能正确性测试</h2><font color="red">需要修改，全部修改是更改命令行为上述命令行，修改比较简单，示例就不放了</font><h2 id="中断正确性测试"><a href="#中断正确性测试" class="headerlink" title="中断正确性测试"></a>中断正确性测试</h2><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><font color="red">需要修改，主要修改是将对拍对象由Mars改成另一个CPU，将Mars生成的机器码给两个CPU吃，然后对比这两个CPU的文件是否相同</font><h3 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h3><p>友情提醒：代码段可以点击右上角收起<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> filestools</span><br><span class="line"><span class="keyword">from</span> filediff.diff <span class="keyword">import</span> file_diff_compare</span><br><span class="line">p_road = <span class="string">&quot;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\FlowCpu&quot;</span></span><br><span class="line">d_road = <span class="string">&quot;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7jbw&quot;</span></span><br><span class="line">run_time = <span class="string">&quot;100us&quot;</span></span><br><span class="line">xilinx_path = <span class="string">&quot;G:\\ISE\\14.7\\ISE_DS\\ISE&quot;</span></span><br><span class="line">dir_name = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\测试记录\\mars文件\\&#x27;</span></span><br><span class="line">dir_name_3 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\测试记录\\机器码文件\\&#x27;</span></span><br><span class="line">dir_name_1 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\测试记录\\比较文件\\&#x27;</span></span><br><span class="line">dir_name_2 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\测试记录\\&#x27;</span></span><br><span class="line">error = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成指令中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    command = <span class="string">&quot;C语言.exe&quot;</span></span><br><span class="line">    os.system(command)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;test.asm&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.asm&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mar</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成机器码中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText a dump .text HexText machine.txt nc test.asm&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText a dump 0x00004180-0x00006000 HexText handler.txt nc test.asm&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;机器码合成.exe&quot;</span>)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;code.txt&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name_3 + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.txt&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line">    <span class="comment"># print(&quot;生成标准答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText nc db lg ex me 65536 test.asm &gt; mar.txt&quot;</span>)</span><br><span class="line"><span class="comment"># 循环结尾 os.system(&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc db me 65536  test.asm &gt; mar.txt&quot;)</span></span><br><span class="line"><span class="comment"># 延迟槽 os.system(&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc db test.asm &gt; mar.txt&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ise_p</span>():</span><br><span class="line">    <span class="comment"># print(&quot;运行ise中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(p_road):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">                file_list.append(file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">            prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + p_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">        tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">    prj.close()</span><br><span class="line">    tcl.close()</span><br><span class="line">    os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path</span><br><span class="line">    os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + p_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_txt &gt; compile_log.txt&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + p_road + <span class="string">&quot;\\mips.tcl&gt; raw_out_p.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ise_d</span>():</span><br><span class="line">    <span class="comment"># print(&quot;运行ise中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(d_road):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">                file_list.append(file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(d_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">            prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + d_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(d_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">        tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">    prj.close()</span><br><span class="line">    tcl.close()</span><br><span class="line">    os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path</span><br><span class="line">    os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + d_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_txt &gt; compile_log.txt&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + d_road + <span class="string">&quot;\\mips.tcl&gt; raw_out_d.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_p</span>():</span><br><span class="line">    <span class="comment"># print(&quot;转换ise答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out_p.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">        mymem = mymem + myfriendmem[i]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog_p.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(mymem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_d</span>():</span><br><span class="line">    <span class="comment"># print(&quot;转换ise答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out_d.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">        mymem = mymem + myfriendmem[i]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog_d.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(mymem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_file</span>(<span class="params">name, target_road</span>):</span><br><span class="line">    f_1 = <span class="built_in">open</span>(name, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(target_road + <span class="string">&quot;\\&quot;</span> + name, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_cmp</span>(<span class="params">test_order</span>):</span><br><span class="line">    co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    co.write(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog_p.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> out_1:</span><br><span class="line">        out_std = out_1.readlines()</span><br><span class="line">        <span class="comment"># out_std.remove(&#x27;\n&#x27;)</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog_d.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> out_2:</span><br><span class="line">        out_test = out_2.readlines()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.\\log.txt&quot;</span>.<span class="built_in">format</span>(test_order), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(out_std) &gt; <span class="built_in">len</span>(out_test):</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out_std)):</span><br><span class="line">                <span class="keyword">if</span> out_std[i] != out_test[i]:</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    log.write(<span class="string">&quot;error in line &#123;&#125;\n expected output is &#123;&#125;\nyour outout is &#123;&#125;\n\n&quot;</span>.<span class="built_in">format</span>(i, out_std[i], out_test[i]))</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Wrong Answer!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Wrong Answer!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="comment"># os.makedirs(&quot;.\\test_log_file\\log_&#123;&#125;\\&quot;.format(i))</span></span><br><span class="line">            <span class="comment"># copy_file(&quot;log.txt&quot;, &quot;.\\test_log_file\\log_&#123;&#125;&quot;.format(i))</span></span><br><span class="line">            <span class="comment"># copy_file(&quot;test.asm&quot;, &quot;.\\test_log_file\\log_&#123;&#125;&quot;.format(i))</span></span><br><span class="line">            <span class="comment"># copy_file(&quot;mar.txt&quot;, &quot;.\\test_log_file\\log_&#123;&#125;&quot;.format(i))</span></span><br><span class="line">            <span class="comment"># copy_file(&quot;verilog.txt&quot;, &quot;.\\test_log_file\\log_&#123;&#125;&quot;.format(i))</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Accepted!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Accepted!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    co.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> f.readlines()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: 没有找到文件:%s或读取文件失败！&quot;</span> % filename)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_file</span>(<span class="params">file1, file2, out_file</span>):</span><br><span class="line">    file1_content = read_file(file1)</span><br><span class="line">    file2_content = read_file(file2)</span><br><span class="line">    d = difflib.HtmlDiff()</span><br><span class="line">    result = d.make_file(file1_content, file2_content)</span><br><span class="line">    fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    fb.write(result)</span><br><span class="line">    <span class="comment"># with open(dir_name + out_file, &#x27;w&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     f.writelines(result)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zip</span>(<span class="params">test_order</span>):</span><br><span class="line">    os.system(<span class="string">&quot;\&quot;C:\\Program Files (x86)\\360\\360zip\\360zip.exe\&quot; -ar code.txt C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\压缩文件\\P7_Q&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;.zip&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入测试次数:&quot;</span>)</span><br><span class="line">test_times =<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">co.write(<span class="string">&quot;测试次数:&quot;</span>+<span class="built_in">str</span>(test_times)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">co.close()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">    generate(i+<span class="number">1</span>)</span><br><span class="line">    run_mar(i+<span class="number">1</span>)</span><br><span class="line">    run_ise_p()</span><br><span class="line">    run_ise_d()</span><br><span class="line">    process_p()</span><br><span class="line">    process_d()</span><br><span class="line">    <span class="comment"># zip(i+1)</span></span><br><span class="line">    <span class="comment"># print(&quot;比较答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    compare_file(<span class="string">r&#x27;verilog_p.txt&#x27;</span>, <span class="string">r&#x27;verilog_d.txt&#x27;</span>, <span class="string">&#x27;result&#x27;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">    file_cmp(i+<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="数据生成器迭代思路"><a href="#数据生成器迭代思路" class="headerlink" title="数据生成器迭代思路"></a>数据生成器迭代思路</h1><h2 id="P7指令集"><a href="#P7指令集" class="headerlink" title="P7指令集"></a>P7指令集</h2><p><strong>{add,sub,and,or,slt,sltu,addi,andi,ori,lb,lh,lw,sb,sh,sw,mult,multu,div,divu,mfhi,mflo,mthi,mtlo,beq,bne,lui,jal,jr,nop,mtc0,mfc0,syscall}</strong></p><h2 id="迭代思路"><a href="#迭代思路" class="headerlink" title="迭代思路"></a>迭代思路</h2><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><h3 id="CPU功能正确性测试"><a href="#CPU功能正确性测试" class="headerlink" title="CPU功能正确性测试"></a>CPU功能正确性测试</h3><p>根据P6的介绍，mtc0,mfc0,syscall均为安全指令，所以可以加入全局生成中。</p><h3 id="CPU异常正确性测试"><a href="#CPU异常正确性测试" class="headerlink" title="CPU异常正确性测试"></a>CPU异常正确性测试</h3><p>根据P7课程网站，我们会发现，异常的可能性是可以穷举的，而且考虑到一个很难受的事情：P6的数据生成器是绝对正确的（我们已经de过了万千Bug，是绝对跑不出问题的），所以我们直接在数据生成中将<font color="red">所有可能的异常加入，然后随机产生。</font></p><h3 id="CPU中断正确性测试"><a href="#CPU中断正确性测试" class="headerlink" title="CPU中断正确性测试"></a>CPU中断正确性测试</h3><p>课程组给的Mars是稍微有点问题的，首先它<font color="red">无法测试外部中断</font>，而且计时中断测试，也会由于<font color="blue">阻塞的问题导致和CPU行为不一致。</font>因此，Mars在中断测试中无用，我们只能选择对拍。<br>我们只需修改数据生成，让其开头固定生成一段打开计时器中断的代码即可。</p><h3 id="通用Handler"><a href="#通用Handler" class="headerlink" title="通用Handler"></a>通用Handler</h3><h4 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h4><p>通用的Handler需要我们实现：<br>（1）检测是什么异常<br>（2）根据检测到的异常进入不同的异常处理模块<br>（3）处理异常<br>（4）恢复<br>笔者的通用Handler思路实现比较简单，主要是区分一下是否是延迟槽异常，区分一下是否是PC异常，如果是延迟槽异常，就PC+8（分为两次PC+4）,如果是PC异常，就跳到开头的死循环位置。其余直接PC+4跳过这条异常指令。</p><h4 id="实现示例："><a href="#实现示例：" class="headerlink" title="实现示例："></a>实现示例：</h4><p>笔者这里实现了一个通用的Handler模型，可以给大家使用。<br><strong>当笔者实现后，CRT助教哥哥告诉笔者Github好像有现成的，笔者哭死T-T</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.ktext 0x4180</span><br><span class="line">mfc0 $k1,$13</span><br><span class="line">andi $k1,$k1,0x80000000</span><br><span class="line">beq $k1,$0,nodelay  //判断是否是延迟槽里的异常</span><br><span class="line">nop</span><br><span class="line">mfc0 $k0, $14</span><br><span class="line">andi $k0,$k0,0xfffffffc</span><br><span class="line">addu $k0, $k0, 4</span><br><span class="line">mtc0 $k0, $14</span><br><span class="line">nodelay:</span><br><span class="line">mfc0 $k0, $14</span><br><span class="line">andi $k0,$k0,0xfffffffc</span><br><span class="line">addu $k0, $k0, 4</span><br><span class="line">mtc0 $k0, $14</span><br><span class="line">subu $k1,$k1,$k1</span><br><span class="line">ori $k1,$0,0x3008</span><br><span class="line">subu $8,$8,$8</span><br><span class="line">ori $8,$0,0x6ffc</span><br><span class="line">slt $9,$8,$k0</span><br><span class="line">beq $9,$0,nopc_0 //判断是否是PC异常</span><br><span class="line">nop</span><br><span class="line">mtc0 $k1,$14</span><br><span class="line">addiu $k0,$k1,0</span><br><span class="line">nopc_0:</span><br><span class="line">subu $10,$10,$10</span><br><span class="line">ori $10,$0,0x3000</span><br><span class="line">slt $9,$k0,$10</span><br><span class="line">beq $9,$0,nopc_1</span><br><span class="line">nop</span><br><span class="line">mtc0 $k1,$14</span><br><span class="line">addiu $k0,$k1,0</span><br><span class="line">nopc_1:</span><br></pre></td></tr></table></figure></p><p><strong>TIPS:</strong>使用笔者的通用Handler需要在代码开头实现一个beq的死循环，这是因为在笔者的通用Handler中，一旦出现PC错误，将直接跳到开头进行死循环刷到指令执行上限结束程序。</p><h3 id="功能正确"><a href="#功能正确" class="headerlink" title="功能正确"></a>功能正确</h3><p>写3个生成函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mfc0:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mfc0</span><span class="params">(<span class="type">int</span> rs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (random == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mfc0 $%d $12\n&quot;</span>, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mfc0 $%d $13\n&quot;</span>, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mfc0 $%d $14\n&quot;</span>, rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mtc0:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mtc0</span><span class="params">(<span class="type">int</span> rs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mtc0 $%d $14\n&quot;</span>, rs);</span><br><span class="line">&#125;</span><br><span class="line">syscall:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">syscall</span><span class="params">()</span>  #这个其实可有可无，毕竟就一句话，在我们枚举异常所有情况时写在那里就行</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;syscall\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>加入全局生成即可完成功能正确性测试。    </p><h3 id="异常正确"><a href="#异常正确" class="headerlink" title="异常正确"></a>异常正确</h3><p>枚举所有异常情况，随机生成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">32</span>: <span class="comment">//异常特加</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;#Exc:\n&quot;</span>);</span><br><span class="line">        radom = <span class="built_in">rand</span>() % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (radom == <span class="number">0</span>)  <span class="comment">//ADEL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//PC异常</span></span><br><span class="line">            <span class="type">int</span> Imm = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (Reg % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Imm = <span class="number">28668</span> + <span class="built_in">rand</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (((Imm % <span class="number">4</span>) == <span class="number">0</span>) &amp;&amp; (Imm &gt;= <span class="number">16768</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    Imm = <span class="built_in">rand</span>() % <span class="number">28669</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sub</span>(rs, rs, rs,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">ori</span>(rs, rs, Imm, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;jr $%d\n&quot;</span>, rs);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;nop\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">1</span>)  <span class="comment">//ADEL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (random == <span class="number">0</span>)  <span class="comment">//取指不对齐</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Imm = <span class="built_in">rand</span>() % <span class="number">32548</span>;</span><br><span class="line">                <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">12</span>;  <span class="comment">//取到错误地方</span></span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>)        <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32512($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32516($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32512($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32516($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">6</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32528($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">7</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32532($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">8</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">9</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32528($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">10</span>)  <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32532($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">11</span>)  <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sub</span>(rt, rt, rt,<span class="number">1</span>);   <span class="comment">//取指超范围</span></span><br><span class="line">                <span class="built_in">ori</span>(rt, rt, <span class="number">2147480000</span> + I, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">2</span>) <span class="comment">//ADES</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (random == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Imm = <span class="built_in">rand</span>() % <span class="number">32548</span>;  <span class="comment">//取指不对齐</span></span><br><span class="line">                <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">13</span>; <span class="comment">//取到错误地方</span></span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>)       <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32512($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32516($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32512($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32516($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">6</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32528($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">7</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32532($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">8</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">9</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32528($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">10</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32532($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">11</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">11</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">12</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">2</span>) <span class="comment">//取指超范围</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sub</span>(rt, rt, rt,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">ori</span>(rt, rt, <span class="number">2147480000</span> + I, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">3</span>)  <span class="comment">//syscall异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;syscall\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">4</span>) <span class="comment">//未知指令</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ftrap\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">5</span>) <span class="comment">//加减溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs == <span class="number">1</span> || rs == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rs = Reg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rt == <span class="number">1</span> || rt == <span class="number">0</span> || rt == rs)</span><br><span class="line">            &#123;</span><br><span class="line">                rt = Reg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rd == <span class="number">1</span> || rd == <span class="number">0</span> || rd == rs || rd == rt)</span><br><span class="line">            &#123;</span><br><span class="line">                rd = Reg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">sub</span>(rs, rs, rs,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">ori</span>(rs, rs, <span class="number">2147480000</span> + I, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">sub</span>(rt, rt, rt,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">ori</span>(rt, rt, <span class="number">2147480000</span> + I, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(rd, rs, rt,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">addi</span>(rs, rd, <span class="number">2147480000</span> + I,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//测减法溢出的同时测连续异常的处理能力</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;#ExcEnd:\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上包含了所有异常的可能，我们在生成时在其中抽取异常生成即可，我将它称为异常池。</p><font color="red">注意减法溢出，笔者在这里写了很多个sub是为了检测CPU连续处理异常的能力</font>   <h3 id="中断正确"><a href="#中断正确" class="headerlink" title="中断正确"></a>中断正确</h3><p>因为我们是全自动测试，所以我们无需仔细考虑中断和异常同时发生的各种情况，因为我们的样本数据够多，随机生成总会碰到的，所以我们直接采用计时器生成，每隔5个指令进行一次中断，因此我们需要配置计时器中断，固定生成以下代码在开头：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ori $t1,11\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ori $t2,20\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ori $t3,0xFC01\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mtc0 $t3,$12\n&quot;</span>);</span><br></pre></td></tr></table></figure><br>之后正常对拍即可</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>P7对于自动化测试的压力还是比较大的，毕竟课上就是对P7的强测，只要强测全部过了都可以直接交卷了，所以课下做的好，课上5分钟。<br>课上分为三个强测：功能，异常，中断强测，因此根据Mars发挥的作用笔者也做了两个测试程序：功能/异常测试,中断测试。</p><p><font color="red">笔者的自动化测试甚至测出了强测没考的点（x</font><br>可惜，P7没有P5,P6那种覆盖率测试程序QAQ，一人血书求出P7覆盖率测试程序。</p><h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>两个都太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P7">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P7</a><br><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P7课上强测！</font></strong><br><strong><font size = 5>P7功能\异常数据生成器代码行数：1178行</font></strong><br><strong><font size = 5>P7中断数据生成器代码行数：1229行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流水线设计与添加指令经验总结</title>
      <link href="/posts/33345/"/>
      <url>/posts/33345/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P5,P6的流水线搭建和课上添加指令的经验总结</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>虽然这么说有搞心态的嫌疑x，但笔者认为，P5是计组难度的分水岭，难度同时体现在课下和课上当中，课下CPU做不好，做出Bug,课上强测也过不去，而且课上加指令本来就比较难做，所以被P5卡一两回也是理所应当的，同时，P5和P6同作为流水线的开发，课上指令将具有极大的<font color="red">相似性</font>，因此笔者认为，开一篇博客来分享一下笔者P5,P6流水线搭建和课上添加指令是必要的，话不多说，<strong>Here We Go!</strong></p><h1 id="预留扩展空间"><a href="#预留扩展空间" class="headerlink" title="预留扩展空间"></a>预留扩展空间</h1><p>如果大家是以顺利通过P3,P4的身份来看这一篇文章的，大家就会明白，一个好的架构对于课上的帮助将有多么巨大，特别是针对于P5,P6这种千行级代码的开发，笔者这里主要说一下扩展空间的事情。</p><h2 id="MUX的非模块化"><a href="#MUX的非模块化" class="headerlink" title="MUX的非模块化"></a>MUX的非模块化</h2><p>很多人在P4，包括我会这样模块化写MUX：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MUX_4_32(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data0,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data2,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data3,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] out</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assign</span> out = (sel==<span class="number">2&#x27;b00</span>) ? data0 : </span><br><span class="line">                    (sel==<span class="number">2&#x27;b01</span>) ? data1 :</span><br><span class="line">                        (sel==<span class="number">2&#x27;b10</span>) ? data2 : data3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> MUX_4_5(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] data0,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] data1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] data2,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] data3,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] out</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assign</span> out = (sel==<span class="number">2&#x27;b00</span>) ? data0 : </span><br><span class="line">                    (sel==<span class="number">2&#x27;b01</span>) ? data1 :</span><br><span class="line">                        (sel==<span class="number">2&#x27;b10</span>) ? data2 : data3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> MUX_2_32(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data0,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data1,</span><br><span class="line">    <span class="keyword">input</span> sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] out</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assign</span> out = (sel==<span class="number">2&#x27;b00</span>) ? data0 : data1;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br>之后在DataPath里面将这些模块连起来就好，<strong>确实，这样做十分的直观，就是对P3CPU的一个翻译</strong>，但对于扩展是极为不友好的，输入位数，输入个数这两个里面有一个变了，就要写一个新的MUX，那么在上机中，我们的时间就会被浪费，因此，笔者认为应直接在DataPath中采用这样的写法：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MEM_ToReg</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] E_MemToReg = (E_MemToReg_sign == <span class="number">1</span>) ? <span class="number">32&#x27;d0</span> : </span><br><span class="line">                            (E_MemToReg_sign == <span class="number">2</span>) ?  EX_PC + <span class="number">8</span> : <span class="number">32&#x27;d0</span>;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] M_MemToReg = (M_MemToReg_sign == <span class="number">1</span>) ? <span class="number">32&#x27;d0</span> : </span><br><span class="line">                            (M_MemToReg_sign == <span class="number">2</span>) ?  MEM_PC + <span class="number">8</span> : MEM_ALU_Result;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] W_MemToReg = (W_MemToReg_sign == <span class="number">1</span>) ? WB_DM_RD : </span><br><span class="line">                            (W_MemToReg_sign == <span class="number">2</span>) ?  WB_PC + <span class="number">8</span> : WB_ALU_Result;</span><br><span class="line"><span class="comment">//MEM_ToReg</span></span><br></pre></td></tr></table></figure><br>这样的写法或许不如前面那种模块化写法理解直观，但这样写的好处就是，扩展十分的方便，只需在三目运算符中再次添加条件即可，是<strong>绝对快于</strong>添加MUX然后再连线的。</p><h2 id="删除转发模块"><a href="#删除转发模块" class="headerlink" title="删除转发模块"></a>删除转发模块</h2><p>有一种东西叫全力转发，这个已经是被证明是理论正确的了，如果想了解更多可以看一下这位学长的博客(<a href="https://thysrael.github.io/posts/59164957/">https://thysrael.github.io/posts/59164957/</a>)<br>采用全力转发将无需转发模块（Forward）的存在，可以减轻在课上加指令时还需要考虑转发的负担，只需考虑阻塞即可。<br>细心的小伙伴可以发现，笔者并没有采用全力转发的思路，这是因为笔者在一开始认为这种全力转发会导致一些特殊指令的难以添加，所以不敢以身试险，做了一个保守决策，但笔者一学期下来并没有遇到这种特殊指令，所以大家应该是可以放心使用的。</p><h1 id="解读指令集描述"><a href="#解读指令集描述" class="headerlink" title="解读指令集描述"></a>解读指令集描述</h1><h2 id="I和I-1"><a href="#I和I-1" class="headerlink" title="I和I+1"></a>I和I+1</h2><p>原文如下：<br><img src="I和I+1.png" alt="I和I+1"><br>大意是讲，I和I+1分类的标准在于效果生效的时间，I表示I内的内容效果在<font color="red">本条指令</font>生效，I+1则表示I+1内的内容效果在<font color="red">下一条指令</font>生效。<br>Tips:这里的下一条指的是正常顺序执行的下一条指令，而且I+1与下一条指令生效的先后顺序不会影响结果。<br>其实看到这里，有聪明的小伙伴就可以看出，I+1这种东西，大概率是和延迟槽挂钩的，如果不存在延迟槽，就不会存在本条指令的执行效果在下一条指令生效的情况。举个例子：Beq这条指令，STL描述如下：<br><img src="Beq.png" alt="Beq"><br>它的PC&lt;-PC+target是在I+1中的，想一想为什么会这样？<br>假如PC&lt;-PC+target在I中，那么在本条指令中，PC值就已经跳转，那么下一条指令就已经执行的是跳转后的指令了，<font color="red">延迟槽消失了！</font><br>假如PC&lt;-PC+target在I+1中，在执行下一条指令时才改变PC的值，<font color="red">延迟槽是不是就出现了？ </font><br><strong>现在，大家明白了I和I+1的区别了吗？进而，大家明白I+n和I-n的含义了吗？</strong><br>但其实，根据笔者上机经验来看，无需考虑这么多，<font color="red">把I和I+1的功能直接实现了即可</font>，这里就算个小科普吧！   </p><h2 id="NullilyCurrentInstruction"><a href="#NullilyCurrentInstruction" class="headerlink" title="NullilyCurrentInstruction()"></a>NullilyCurrentInstruction()</h2><p>意思为清空延迟槽，我们以一道例题做解释：</p><h3 id="例题：Bonall"><a href="#例题：Bonall" class="headerlink" title="例题：Bonall"></a>例题：Bonall</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RTL：</span><br><span class="line">I:   target_offest &lt;- sign(offest||0^2)</span><br><span class="line">     condition &lt;- GPR[rs] + GPR[rt] = 0</span><br><span class="line">     GPR[31] &lt;- PC + 8</span><br><span class="line">  </span><br><span class="line">I+1: if condition:</span><br><span class="line">PC &lt;- PC + starget_offest</span><br><span class="line">      else:</span><br><span class="line">NullilyCurrentInstruction()</span><br><span class="line">      endif</span><br></pre></td></tr></table></figure>  <p><strong>顺带大家可以复习一下第一条知识:</strong>为什么NullilyCurrentInstruction会被翻译为清空延迟槽而不是直译为清空当前指令？<br>这个操作理解起来很好理解，就是把延迟槽的指令屏蔽掉嘛，但怎么实现需要我们好好考虑一下：</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>以bonall为例，如果是bonall指令并且不跳转，则要清除延迟槽，则生成一个flush信号，如果flush有效<font color="red">并且没有处于阻塞状态</font>，则 flush一下FD级流水线寄存器即可。<br><strong>Tips:</strong>如果在阻塞状态下清楚了FD流水线寄存器，则相当于清除了bonall这条指令，这显然不正确。   </p><p><strong>记住我们的目标：清除的是延迟槽，只有不在阻塞的状态下，下一次流水到FD寄存器的才正好是延迟槽指令！</strong></p><h2 id=""><a href="#" class="headerlink" title="||"></a>||</h2><h3 id="例题：Lwbti"><a href="#例题：Lwbti" class="headerlink" title="例题：Lwbti"></a>例题：Lwbti</h3><p>在lw指令的基础上，将要写入的寄存器的编号改为rt的访存结果前五位这两者无符号比较结果的最大值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RTL：</span><br><span class="line">vaddr &lt;- GRF[base] + sign_extend(offset)</span><br><span class="line">paddr &lt;- vaddr31...2||0^2</span><br><span class="line">memWord &lt;- memory[paddr]</span><br><span class="line">index &lt;- max(memWord[31:27],rt)</span><br><span class="line">GRF[index] &lt;- memWord</span><br></pre></td></tr></table></figure>  </p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>由memory[paddr],知paddr为32位，所以，<strong>||的意思就是拼接</strong></p><h2 id="x…y"><a href="#x…y" class="headerlink" title="x…y"></a>x…y</h2><h3 id="例题：Lwbti-1"><a href="#例题：Lwbti-1" class="headerlink" title="例题：Lwbti"></a>例题：Lwbti</h3><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>由memory[paddr],知paddr为32位，所以，<strong>x…y的意思就是取变量的x-y位</strong></p><h1 id="添加指令"><a href="#添加指令" class="headerlink" title="添加指令"></a>添加指令</h1><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>（1）Control模块添加指令对应的OPCode<br>（2）在对应模块中实现相应功能<br>（3）在Datapath中连线<br>（4）回到Control写控制信号<br>（5）转发阻塞</p><h2 id="Fuction"><a href="#Fuction" class="headerlink" title="Fuction"></a>Fuction</h2><p>很多时候，如果一个功能实现过于复杂，我们有希望将其用assign实现，那么我们往往需要函数作为支持 <strong>（always@（*）块可以直接替代）</strong></p><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><p>1）不含有任何延迟、时序或时序控制逻辑<br>2）至少有一个输入变量<br>3）只有一个返回值，且没有输出<br>4）不含有非阻塞赋值语句<br>5）函数可以调用其他函数，但是不能调用任务</p><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [range]     function_id ;</span><br><span class="line">input_declaration ;</span><br><span class="line">other_declaration ;</span><br><span class="line">procedural_statement ;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>  <h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>函数通过指明函数名与输入变量进行调用。函数结束时，返回值被传递到调用处。</p><h3 id="调用实例"><a href="#调用实例" class="headerlink" title="调用实例"></a>调用实例</h3><pre><code>function [31:0] cal;input [31:0] RDD:input [l:0] Lower;input iss_lbget;begin    if(iss lbget &amp;_ Lower == 2&#39;d0) begin        cal = &#123; &#123;24&#123;RDD[7]&#125;&#125;,RDD[7:0] &#125;;    end    else if(iss lbget &amp;&amp; Lower = 2&#39;dl) begin        cal = &#123; &#123;24&#123;RDD[15]&#125;&#125;,RDD[15:8] &#125;;    end    else if(iss lbget &amp; Lower == 2&#39;d2) begin        cal = &#123; &#123;24&#123;RDD[23]&#125;&#125;,RDD[23:16] &#125;;    end    else if(iss lbget &amp; Lower == 2&#39;d3) begin        cal = &#123; &#123;24&#123;RDD[31]&#125;&#125;,RDD[31:24] &#125;;    end    else begin        cal = RDD:    endendendfunction</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果你加入了 <strong>`default_nettype none</strong> 这条代码,注意别将函数写成这样：</p><pre><code>function [31:0] cal;input wire [31:0] RDD:input wire [l:0] Lower;input wire iss_lbget;begin    if(iss lbget &amp;_ Lower == 2&#39;d0) begin        cal = &#123; &#123;24&#123;RDD[7]&#125;&#125;,RDD[7:0] &#125;;    end    else if(iss lbget &amp;&amp; Lower = 2&#39;dl) begin        cal = &#123; &#123;24&#123;RDD[15]&#125;&#125;,RDD[15:8] &#125;;    end    else if(iss lbget &amp; Lower == 2&#39;d2) begin        cal = &#123; &#123;24&#123;RDD[23]&#125;&#125;,RDD[23:16] &#125;;    end    else if(iss lbget &amp; Lower == 2&#39;d3) begin        cal = &#123; &#123;24&#123;RDD[31]&#125;&#125;,RDD[31:24] &#125;;    end    else begin        cal = RDD:    endendendfunction</code></pre><p><strong>这样会直接报错，因为函数的定义内不能写明wire或者reg</strong></p><h2 id="计算指令，跳转指令，访存指令添加方法论"><a href="#计算指令，跳转指令，访存指令添加方法论" class="headerlink" title="计算指令，跳转指令，访存指令添加方法论"></a>计算指令，跳转指令，访存指令添加方法论</h2><h3 id="计算指令"><a href="#计算指令" class="headerlink" title="计算指令"></a>计算指令</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><strong>鲁迅说：计算简单，上来先秒计算。</strong><br>笔者说：别听他胡咧咧，笔者被坑成傻子了。<br>综上所述：计算一般而言是比较简单的，但要难也可以难到爆炸，比如：实现二维数组冒泡排序<br>或者我们换句话说：计算的难度永远都在实现计算功能这个操作上，阻塞和转发都是十分简单的。<br>因此在这里，没有什么具体的方法论，重心就在于实现功能上，P5大概率ALU，P6大概率MDU，而这个往往因题而异。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="SWC.png" alt="SWC"></p><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>跳转指令是有规律可循的，大概分为两类，一种是条件链接，一种是非条件链接。<br>对于条件链接，需要我们流水线传递一个信号D_jump，在D级得出是否需要写入，在W级根据D_jump进行写入<br>对于非条件链接，直接写5’d31<br>其余就是正常的更改CMP产生比较信号，在NPC中根据比较信号和比较指令信号进行PC值的更改。<br>阻塞和转发类似于Jal和Beq的混合处理，也比较简单。<br><strong>Tips</strong> 这个题几乎是必做， <strong>因为掌握后它的变化最少，最容易实现</strong></p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h5 id="条件链接"><a href="#条件链接" class="headerlink" title="条件链接"></a>条件链接</h5><p><img src="BLZTAL.png" alt="BLZTAL">   </p><h5 id="非条件链接"><a href="#非条件链接" class="headerlink" title="非条件链接"></a>非条件链接</h5><p><strong>Bgezall</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RTL：</span><br><span class="line">I:</span><br><span class="line">  target_offset &lt;- signed_ext(offset||0^2)</span><br><span class="line">  condition &lt;- GPR[rs] &gt;= 0 </span><br><span class="line">  GPR[31] &lt;- PC + 8</span><br><span class="line">I+1: </span><br><span class="line">  if condition then</span><br><span class="line">    PC &lt;- PC + 4 + target_offset</span><br><span class="line">  else</span><br><span class="line">    NullilyCurrentInstruction()</span><br></pre></td></tr></table></figure></p><h3 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>访存被很多人认为是最难的，但其实掌握后也不难。<br>它其实也是那种一眼难，会了以后也是有一定的规律的题<br>他们大多都是条件访存，只有从DM取出来内容后我们才知道到底往哪里写，我们这里可以统一在WB写的时候在Datapath中生成一个条件信号。<br>例如judge信号，直接在Datapath写组合逻辑判断好后送给Control，结合指令信号进行一起判断，产生控制信号<br>例如grf信号，直接在Datapath写组合逻辑判断好后送给Control作为一个备选的grf目标。<br><strong>阻塞和转发一定要尽力做好，在D级可以排除一些寄存器我们就要尽力排除，让无关指令不需暂停，否则大概率TLE，这点和往年不太一样，往年可能暴力阻塞也可以通过</strong></p><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><h5 id="Judge信号"><a href="#Judge信号" class="headerlink" title="Judge信号"></a>Judge信号</h5><p><img src="LWIE.png" alt="LWIE"></p><h5 id="Grf信号"><a href="#Grf信号" class="headerlink" title="Grf信号"></a>Grf信号</h5><p><img src="Lwbti.png" alt="Lwbti"></p><h1 id="Mars课上测试指令构造技巧"><a href="#Mars课上测试指令构造技巧" class="headerlink" title="Mars课上测试指令构造技巧"></a>Mars课上测试指令构造技巧</h1><h2 id="写在开头-1"><a href="#写在开头-1" class="headerlink" title="写在开头"></a>写在开头</h2><font size = 5><font color="red">一定要做Mars测试！</font></font>   <font size = 5><font color="red">一定要做Mars测试！</font></font><font size = 5><font color="red">一定要做Mars测试！</font></font>   <p>不管是为正确性也好，还是为了RTL表述错误/不准确，我们都必须使用class文件进行测试。而测试点是绝对以class文件的行为为准的。<br>不要相信自己一定可以肉眼de出来，这种自信是盲目的自信，笔者深受其害，大多数时候做一条指令就能复现的问题，肉眼可能得考虑半天也出不来。<br>笔者亲身体会P5时跳转指令RTL描述和class文件有一点点的出入，按照RTL全错，按照Class直接过，如果不拿class文件做测试，这道题必定过不了。</p><h2 id="计算指令-1"><a href="#计算指令-1" class="headerlink" title="计算指令"></a>计算指令</h2><p>正数，负数，0都测试一下，只需三条，也比较简单。</p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p><strong>原地跳</strong>，向前跳，向后跳<br>一定注意原地跳，这个是错点最多的情况，我眼睁睁看着我的一个好友没有测原地跳导致挂了一P。</p><h2 id="条件访存"><a href="#条件访存" class="headerlink" title="条件访存"></a>条件访存</h2><p>先存一个数值进去<br>然后进行条件访存<br>确保访存内容不为0即可</p><h1 id="悄悄话"><a href="#悄悄话" class="headerlink" title="悄悄话"></a>悄悄话</h1><p>更多课上习题见:<br><a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P5">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P5</a><br><a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P6">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P6</a></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P6 </tag>
            
            <tag> 北航计算机组成-P5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂流水线CPU全自动测试思路（Verilog）</title>
      <link href="/posts/42542/"/>
      <url>/posts/42542/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P6的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><font size = 3><font color="purple">由于P6是P5的迭代开发，因此本次工作将主要体现在数据生成上</font></font><h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><font size = 3><font color="red">无需，前面的完全够用</font></font><h1 id="Python实现（数据执行器）"><a href="#Python实现（数据执行器）" class="headerlink" title="Python实现（数据执行器）"></a>Python实现（数据执行器）</h1><font size = 3><font color="red">无需，照搬P5即可，具体见我的前几篇博客</font></font><h1 id="数据生成器迭代思路"><a href="#数据生成器迭代思路" class="headerlink" title="数据生成器迭代思路"></a>数据生成器迭代思路</h1><h2 id="P6指令集"><a href="#P6指令集" class="headerlink" title="P6指令集"></a>P6指令集</h2><p><strong>{add,sub,and,or,slt,sltu,addi,andi,ori,lb,lh,lw,sb,sh,sw,mult,multu,div,divu,mfhi,mflo,mthi,mtlo,beq,bne,lui,jal,jr,nop}</strong></p><h2 id="迭代思路"><a href="#迭代思路" class="headerlink" title="迭代思路"></a>迭代思路</h2><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><h4 id="等同与不等同"><a href="#等同与不等同" class="headerlink" title="等同与不等同"></a>等同与不等同</h4><font color="purple">找到同类，直接归类</font>  <font color="red">没有同类，单独添加</font>         <p>我举个例子，or,and,slt,sltu都是cal_r类型，可以直接和P5数据生成器中的add,sub等同处理。<br>lb,lh可以等同lw处理。<br>sb,sh可以等同sw处理。<br>等同的意思是，代码可以复用，规则可以复用。<br>对于mult,div则不可以，需要新规则的限制。<br>做完这些，大部分我们就归类完毕了，之后就是对于新规则的修修补补，维持程序正确</p><h4 id="危险指令与安全指令"><a href="#危险指令与安全指令" class="headerlink" title="危险指令与安全指令"></a>危险指令与安全指令</h4><p>要这样考虑是为了逻辑上的简便，和作为指令生成时随机范围的依据，例如add,sub,and,or这些，就是安全指令，因为他们无论如何都不会引起异常，所以他们可以在任何位置生成（开头，代码块，延迟槽）……<br>而lw,sw,div这些，则是危险指令，对他们的操作稍有不慎，就会导致Mars报错，div不能除0，lw，sw要求地址合理，要求字对齐，而这些规则的处理，在随机生成中是需要我们提前用一些指令规避这些问题的，所以某些规则下生成的他们就不能出现在延迟槽中，因为不止一条指令。</p><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="div除0的处理"><a href="#div除0的处理" class="headerlink" title="div除0的处理"></a>div除0的处理</h4><p>div和divu是不能除0的，这在数学上本就不被允许，在Mars中是一种UB（未定义）行为，所以我们需要添加规则避免除0现象的产生：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rss= rs;</span><br><span class="line"><span class="type">int</span> rtt = rt;</span><br><span class="line"><span class="keyword">while</span>(rtt==<span class="number">0</span>) #避免<span class="number">0</span>号寄存器对后面的影响</span><br><span class="line">&#123;</span><br><span class="line">    rtt = Reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(rss==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">rss = Reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ori</span>(rtt,rss,I+<span class="number">4</span>,<span class="number">0</span>); </span><br><span class="line"><span class="built_in">ori</span>(rtt,rss,I+<span class="number">4</span>,<span class="number">0</span>); <span class="meta">#ori两个不同的立即数保证除数不为0</span></span><br><span class="line"><span class="type">int</span> delay = Delayinstr; #抽取随机数决定抽取指令池中的哪条指令</span><br><span class="line"><span class="keyword">while</span>(delay == <span class="number">8</span>||delay == <span class="number">9</span>) # <span class="number">8</span>，<span class="number">9</span>为div和divu，我们这里不允许嵌套，所以要重新抽取</span><br><span class="line">&#123;</span><br><span class="line">delay = Delayinstr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Choose</span>(delay, <span class="number">0</span>, rss, rtt, rs, rt, <span class="number">0</span>); #生成抽取好的指令，后面的参数是生成时寄存器不会选择rss,rtt,rs,rt（概率不生成）</span><br><span class="line">delay = Delayinstr;</span><br><span class="line"><span class="keyword">while</span>(delay == <span class="number">8</span>||delay == <span class="number">9</span>)</span><br><span class="line">&#123;</span><br><span class="line">delay = Delayinstr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Choose</span>(delay, <span class="number">0</span>, rss, rtt, rs, rt, <span class="number">0</span>);  #同理（概率不生成）</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;divu $%d,$%d\n&quot;</span>, rtt, rss); 核心人物</span><br></pre></td></tr></table></figure><br>以上代码便是对div,divu规则的具体表现，具体体现为，避免0寄存器的影响；在div这条指令的前1-2，2-3或3-4均为ori，保证除数不为0，至于为什么中间可能会插入两条指令，就是为了我P5时所说的那样，<strong>实现不同的转发级别。增强测试能力。</strong></p><h4 id="指令类的生成"><a href="#指令类的生成" class="headerlink" title="指令类的生成"></a>指令类的生成</h4><p>细细察看我的代码生成，会发现我在尽力保持一种原则，及时是固定3条指令，我也会尽可能将这3条指令变为指令类，进行生成，这样既保证了正确性，也能提高随机性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sw $0,0($0)\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> imm = Ib;</span><br><span class="line"><span class="built_in">sub</span>(rt, rt, rt);</span><br><span class="line"><span class="built_in">ori</span>(rt, rt, <span class="number">12</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> random = <span class="built_in">rand</span>() % <span class="number">3</span>; </span><br><span class="line"><span class="keyword">if</span>(random == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,0($0)\n&quot;</span>, rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,0($0)\n&quot;</span>, rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,0($0)\n&quot;</span>, rt);</span><br><span class="line">&#125;</span><br><span class="line">random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(random == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lw $%d,0($0)\n&quot;</span>, rs);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,0($0)\n&quot;</span>, rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,0($0)\n&quot;</span>, rs);</span><br><span class="line">&#125;</span><br><span class="line">random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(random == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125;</span><br><span class="line">random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(random == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($0)\n&quot;</span>, rt, Ib);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($0)\n&quot;</span>, rt, Ib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($0)\n&quot;</span>, rt, Ib);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>这一段代码是我为了解决load和store指令冲突的规则之一，会发现，我在生成这些指令时，看着复杂，实际上就是指令类的随机生成，store-load-load-store,这样既能测试转发和阻塞，又能保证正确性。   </p><font color="red">TIPS：由于Lb只能存1个字节，所以随机数Ib的生成范围应该在0-255之间，否则可能会出现sw了一个400，lb取出来就不是400，导致后面出错。</font><h4 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h4><p>刚才我在总体思路里说明了，对于类似指令下的已有规则，我们可以直接复用，不需创造新规则，这样稳定又高效，展示一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sw_sh_sb</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> rt)</span> #原来是sw的生成函数的一部分，直接改为sw_sh_sb的生成函数</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = Reg % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> imm = Ib;</span><br><span class="line">        <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">        <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rs++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> imm1 = Ib;</span><br><span class="line">        <span class="type">int</span> imm2 = Ib;</span><br><span class="line">        <span class="keyword">if</span> (imm1 &lt; imm2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = imm1;</span><br><span class="line">            imm1 = imm2;</span><br><span class="line">            imm2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">        <span class="built_in">ori</span>(rs, rs, imm1, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> imm3 = <span class="number">0</span> - imm2;</span><br><span class="line">        <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rt, imm3, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($%d)\n&quot;</span>, rt, imm3, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($%d)\n&quot;</span>, rt, imm3, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如上，这个函数在P5中是sw生成规则的一部分，具体是为了加入负数检验EXT模块的正确性，在P6它便可以摇身一变，成为sw_sh_sb生成规则的一部分，我们要做的，只是添加一个随机的功能，抽取一个Store类即可。  </p><h4 id="jr和jal的处理"><a href="#jr和jal的处理" class="headerlink" title="jr和jal的处理"></a>jr和jal的处理</h4><p>这个话题是老生常谈的，也是数据生成中最大的问题，稍微动错一点，就会导致跳转错误。所以我们对这两个的转发和阻塞实现可以从两个方面下手：<br>（1）让他们作为转发人，作为阻塞源：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#前面是jal,刚对$<span class="number">31</span>进行了写入</span><br><span class="line"><span class="keyword">if</span>(Reg%<span class="number">3</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;mult $31,$%d\n&quot;</span>,Reg);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Reg%<span class="number">3</span>==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;multu $31,$%d\n&quot;</span>,Reg);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Reg%<span class="number">3</span>==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;divu $%d,$31\n&quot;</span>,Reg);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;div $%d,$31\n&quot;</span>,Reg);</span><br></pre></td></tr></table></figure><br>这是我生成规则中，对于jal和乘除指令的一个特殊生成规则，有个小细节就是，在div中，保证$31作为除数，因为它绝对不为0，可以省去考虑div为0的步骤。<br>（2）作为被转发人，作为被阻塞源：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g = Reg % <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (g == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">    <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">    <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  </span></span><br><span class="line">    <span class="built_in">add</span>(rd, <span class="number">0</span>, <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">    <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">    <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  $31=0</span></span><br><span class="line">    <span class="built_in">ori</span>(rd, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> immi = I;</span><br><span class="line">    <span class="built_in">sub</span>(rt, rt, rt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, <span class="number">31</span>, immi, rt);</span><br><span class="line">    <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, <span class="number">31</span>, immi, rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">    <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="built_in">sub</span>(rd, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g==<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">mtlo</span>(<span class="number">31</span>);</span><br><span class="line">    <span class="built_in">mthi</span>(<span class="number">31</span>);</span><br><span class="line">    <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">if</span>(Reg%<span class="number">2</span>) <span class="built_in">mflo</span>(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">mfhi</span>(<span class="number">31</span>);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总体思路就是：把$31的值挪走，再挪回来。 </p><font color="red">有一个很遗憾的一点是，在这里对于$31的处理要小心加小心，因此难以实现指令类的随机，导致了随机性的有所下降，这个也只能通过不断地添加特殊指令序列去增强随机，笔者由于时间原因也只写了5条，这可能就是随机生成法的一个缺陷吧.</font>            <font color="purple">所以笔者寒假也在尝试一些新的数据生成方式，有所作为的话一定会再次开贴更新，先画个饼先~</font>   <h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;grade&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;forward&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;average&quot;</span>: <span class="number">95.06304176516942</span>,</span><br><span class="line">    <span class="string">&quot;stall&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;average&quot;</span>: <span class="number">95.52380952380952</span>,</span><br></pre></td></tr></table></figure><h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P6">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P6</a></p><p><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P6课上强测！</font></strong></p><p><strong><font size = 5>P6数据生成器代码行数：823行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂流水线CPU设计文档（Verilog）</title>
      <link href="/posts/45102/"/>
      <url>/posts/45102/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Verilog 复杂流水线CPU设计文档</center></font></strong></p><h1 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h1><h2 id="总体设计综述"><a href="#总体设计综述" class="headerlink" title="总体设计综述"></a>总体设计综述</h2><p>使用Verilog开发一个流水线CPU,总体概述如下：<br>1.此流水线CPU为32位CPU<br>2.此CPU为流水线设计<br>3.此CPU支持的指令集为:{add,sub,and,or,slt,sltu,addi,andi,ori,lb,lh,lw,sb,sh,sw,mult,multu,div,divu,mfhi,mflo,mthi,mtlo,beq,bne,lui,jal,jr,nop}<br>4.nop的机器码为0x0000000<br>5.add，sub不支持溢出</p><h2 id="关键模块定义"><a href="#关键模块定义" class="headerlink" title="关键模块定义"></a>关键模块定义</h2><h3 id="IM-外置"><a href="#IM-外置" class="headerlink" title="IM(外置)"></a>IM(外置)</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i_inst_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">需要进行取指操作的流水级 PC（一般为 F 级）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i_inst_rdata[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">i_inst_addr 对应的 32 位指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">取指</td><td style="text-align:center">利用PC取出对应位置处的指令</td></tr></tbody></table></div><h3 id="F-PC"><a href="#F-PC" class="headerlink" title="F_PC"></a>F_PC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前PC值</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">更改PC值</td><td style="text-align:center">利用NPC更改PC值</td></tr></tbody></table></div><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">A3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其作为RD的写入地址</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位写入数据</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A2指定寄存器的32位数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号，清零32个寄存器中的数据</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">同步复位</td><td style="text-align:center">时钟上升沿到来时，若RESET信号有效，则将32个寄存器中的数据全部清除</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A1与A2所存地址对应的寄存器的数据读出到RD1和RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD写入到A3所存地址对应的寄存器中</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">转发数据</td><td style="text-align:center">当A3\==A2或A3\==A1且WE有效，A3!=0时，将WD中的数据作为RD1或RD2的输出</td></tr></tbody></table></div><h3 id="ID-ID-REG"><a href="#ID-ID-REG" class="headerlink" title="ID_ID_REG"></a>ID_ID_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">IF_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段机器码</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">IF_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">ID阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">O</td><td style="text-align:center">扩展类型信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">O</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RegWrite</td><td style="text-align:center">O</td><td style="text-align:center">寄存器写使能信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MemWrite</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">MemToReg[2:0]</td><td style="text-align:center">O</td><td style="text-align:center">Reg写入数据类型信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">RegDest[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">A3寄存器选择信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ALUop[3:0]</td><td style="text-align:center">O</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">O</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">O</td><td style="text-align:center">Jr信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">RegSrc</td><td style="text-align:center">O</td><td style="text-align:center">ALU数据来源选择信号</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">imm16[15:0]</td><td style="text-align:center">O</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">imm26[25:0]</td><td style="text-align:center">O</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">rs[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rs寄存器编号</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">rt[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rt寄存器编号</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">rd[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rd寄存器编号</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">load</td><td style="text-align:center">O</td><td style="text-align:center">是否为lw指令</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">store</td><td style="text-align:center">O</td><td style="text-align:center">是否为sw指令</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">cal_r</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_r类指令</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">cal_i</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_i类指令</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">jal</td><td style="text-align:center">O</td><td style="text-align:center">是否为jal指令</td></tr></tbody></table></div><p>(2)真值表</p><div class="table-container"><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">add</th><th style="text-align:center">sub</th><th style="text-align:center">ori</th><th style="text-align:center">lw</th><th style="text-align:center">sw</th><th style="text-align:center">lui</th><th style="text-align:center">beq</th><th style="text-align:center">Jal</th><th style="text-align:center">Jr</th></tr></thead><tbody><tr><td style="text-align:center">OP</td><td style="text-align:center">000000</td><td style="text-align:center">000000</td><td style="text-align:center">001101</td><td style="text-align:center">100011</td><td style="text-align:center">101011</td><td style="text-align:center">001111</td><td style="text-align:center">000100</td><td style="text-align:center">000011</td><td style="text-align:center">000000</td></tr><tr><td style="text-align:center">FC</td><td style="text-align:center">100000</td><td style="text-align:center">100010</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">001000</td></tr><tr><td style="text-align:center">ALUop</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0011</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0100</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">Jump</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">RegWrite</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemWrite</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemToReg</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegDest</td><td style="text-align:center">01</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegSrc</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Branch</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jreg</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">B[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Equal</td><td style="text-align:center">O</td><td style="text-align:center">A==B？1：0</td></tr></tbody></table></div><p>(2)功能定义<br>|  序号   | 功能 | 描述 |<br>|  :——:  | :——:  | :——: |<br>|1|比较|比较操作数A与B是否相等，相等则Equal有效|</p><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">F_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段的PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段的PC值</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Beq指令</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jal指令</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jr指令</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Jal_imm26[25:0]</td><td style="text-align:center">I</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">D_GRF_Jr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">Jr目标寄存器数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">Beq_imm16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">Equal</td><td style="text-align:center">I</td><td style="text-align:center">D_CMP两操作数是否相等</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">PC的下一值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">计算下一PC的值</td><td style="text-align:center">根据指令和当前PC值计算下一PC值</td></tr></tbody></table></div><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">经过扩展后的32位立即数</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">I</td><td style="text-align:center">选择扩展类型信号  0：符号扩展 1：无符号扩展</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">符号扩展</td><td style="text-align:center">将16位立即数符号扩展为32位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">无符号扩展</td><td style="text-align:center">将16位立即数无符号扩展为32位立即数</td></tr></tbody></table></div><h3 id="ID-EX-REG"><a href="#ID-EX-REG" class="headerlink" title="ID_EX_REG"></a>ID_EX_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_RD1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">D_imm32[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段32位立即数</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">EX_RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">EX_imm32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段32位立即数</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">EX阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ALUControl[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">运算结果</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">判断两个操作数是否相等</td><td style="text-align:center">相等则Bigger输出1否则为0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">加运算</td><td style="text-align:center">res=SrcA+SrcB</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">减运算</td><td style="text-align:center">res=SrcA-SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">与运算</td><td style="text-align:center">res=SrcA$SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">或运算</td><td style="text-align:center">res=SrcA或SrcB</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">加载高位运算</td><td style="text-align:center">res={SrcB[15:0],16’h0}</td></tr></tbody></table></div><h3 id="E-MDU"><a href="#E-MDU" class="headerlink" title="E_MDU"></a>E_MDU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">start</td><td style="text-align:center">I</td><td style="text-align:center">开始信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MDUop[2:0]</td><td style="text-align:center">I</td><td style="text-align:center">MDU功能选择信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">HIWrite</td><td style="text-align:center">I</td><td style="text-align:center">HI寄存器写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">LOWrite</td><td style="text-align:center">I</td><td style="text-align:center">LO寄存器写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">HIRead</td><td style="text-align:center">I</td><td style="text-align:center">读HI寄存器信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">LORead</td><td style="text-align:center">I</td><td style="text-align:center">读LO寄存器信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">HI[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">HI寄存器</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">LO[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">LO寄存器</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">busy</td><td style="text-align:center">O</td><td style="text-align:center">MDU模块忙信号</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">MDU_res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MDU结果信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">无符号乘</td><td style="text-align:center">{HI_temp,LO_temp} = SrcA * SrcB</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">符号乘</td><td style="text-align:center">{HI_temp,LO_temp} = $signed(SrcA) * $signed(SrcB)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">符号除</td><td style="text-align:center">HI = $signed(SrcA) % $signed(SrcB)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">符号除</td><td style="text-align:center">LO = $signed(SrcA) \ $signed(SrcB)</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">无符号除</td><td style="text-align:center">HI = SrcA % SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">无符号除</td><td style="text-align:center">LO = SrcA \ SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">读写HI寄存器</td><td style="text-align:center">mfhi读，mthi写</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">读写LO寄存器</td><td style="text-align:center">mflo读，mflo写</td></tr></tbody></table></div><h3 id="EX-MEM-REG"><a href="#EX-MEM-REG" class="headerlink" title="EX_MEM_REG"></a>EX_MEM_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">MEM_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">MEM阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="DM（外置）"><a href="#DM（外置）" class="headerlink" title="DM（外置）"></a>DM（外置）</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">m_data_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">m_data_rdata[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">32位数据输出</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">m_data_wdata[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位数据输入</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">m_inst_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">M级PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">m_inst_byteen[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">字节使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">写入数据</td><td style="text-align:center">当时钟上升沿到来时，根据字节使能信号中的有效位将WD中的数据写入到A所存地址所对应的位处</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A所存地址对应位置的数据读出到RD</td></tr></tbody></table></div><h3 id="M-BE"><a href="#M-BE" class="headerlink" title="M_BE"></a>M_BE</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[1:0]</td><td style="text-align:center">I</td><td style="text-align:center">DM地址的低两位</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">DM读出数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Op[2:0]</td><td style="text-align:center">I</td><td style="text-align:center">BE功能选择</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">BE数据输出</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">处理DM数据</td><td style="text-align:center">根据A和OP处理数据，使其符合指令行为</td></tr></tbody></table></div><h3 id="MEM-WB-REG"><a href="#MEM-WB-REG" class="headerlink" title="MEM_WB_REG"></a>MEM_WB_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">MEM_DM_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段DM读出数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WB_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WB_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">WB_DM_RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段DM读出数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">WB_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">WB阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Stall"><a href="#Stall" class="headerlink" title="Stall"></a>Stall</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">D_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Stall</td><td style="text-align:center">O</td><td style="text-align:center">阻塞信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">阻塞功能</td><td style="text-align:center">判断当前流水线是否需要在ID阶段阻塞</td></tr></tbody></table></div><p>(3)判断方法——AT法</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">rsTuse</th><th style="text-align:center">rtTuse</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">slt</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sltu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">addi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">andi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lb</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lh</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sb</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">sh</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">bne</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">mult</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">multu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">div</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">divu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">mthi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mtlo</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">0</td><td style="text-align:center">-</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">E_Tnew</th><th style="text-align:center">M_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">slt</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sltu</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">addi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">andi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">lh</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">lb</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sh</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sb</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mfhi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">mflo</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">bne</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><h3 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">W_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_Forward</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">MEM_Forward</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">WB_Forward</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段数据是否可以转发信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">转发信号</td><td style="text-align:center">判断每个阶段是否可以为前面转发数据</td></tr></tbody></table></div><h1 id="转发暂停控制"><a href="#转发暂停控制" class="headerlink" title="转发暂停控制"></a>转发暂停控制</h1><h2 id="暂停："><a href="#暂停：" class="headerlink" title="暂停："></a>暂停：</h2><pre><code>wire Stall_MDU = busy &amp;&amp; ( D_MDU_c || D_MDU_f || D_MDU_t );wire Stall_rs_E = (E_RegDest == D_rs) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rs &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_rt_E = (E_RegDest == D_rt) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rt &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_E = Stall_rs_E || Stall_rt_E;wire Stall_rs_M = (M_RegDest == D_rs) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rs &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_rt_M = (M_RegDest == D_rt) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rt &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_M = Stall_rs_M || Stall_rt_M;assign Stall = Stall_M || Stall_E || Stall_MDU;     </code></pre><h2 id="转发："><a href="#转发：" class="headerlink" title="转发："></a>转发：</h2><pre><code>wire [31:0] D_Forward_rs = (D_rs == 0)? 0 :            ((E_RegDest == D_rs) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :        ((M_RegDest == D_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD1;wire [31:0] D_Forward_rt = (D_rt == 0)? 0 :            ((E_RegDest == D_rt) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :            ((M_RegDest == D_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD2;wire [31:0] E_Forward_rs =   (E_rs == 0) ? 0 :        ((M_RegDest == E_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rs) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD1;wire [31:0] E_Forward_rt =   (E_rt == 0) ? 0 :        ((M_RegDest == E_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rt) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD2;wire [31:0] M_WD_Forward = (M_rt == 0) ? 0 :        ((W_RegDest == M_rt) &amp;&amp; (WB_Forward) &amp;&amp; (W_RegWrite)) ? W_MemToReg : MEM_RD2;</code></pre><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><h2 id="（1）测试代码"><a href="#（1）测试代码" class="headerlink" title="（1）测试代码"></a>（1）测试代码</h2><p>为<strong>自动化测试</strong>：<br>共随机生成1000组数据<br><img src="微信截图_20221106010804.png" alt="数据示意1"><br>并生成1000组比对文件<br><img src="微信截图_20221106010955.png" alt="数据示意2"><br>和一个总体结果文件<br><img src="微信截图_20221106011047.png" alt="数据示意3"></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="（1）为什么需要有单独的乘除法部件而不是整合进-ALU？为何需要有独立的-HI、LO-寄存器？"><a href="#（1）为什么需要有单独的乘除法部件而不是整合进-ALU？为何需要有独立的-HI、LO-寄存器？" class="headerlink" title="（1）为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？"></a>（1）为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</h3><p>答：要遵循“高内聚，低耦合”的设计思想。MDU有着和ALU截然不同的特性，首先最根本的就是它是一个时序逻辑<br>有独立的HI和LO，操作会更加灵活，便于运算。存取也会更加方便一些</p><h3 id="（2）真实的流水线-CPU-是如何使用实现乘除法的？请查阅相关资料进行简单说明。"><a href="#（2）真实的流水线-CPU-是如何使用实现乘除法的？请查阅相关资料进行简单说明。" class="headerlink" title="（2）真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。"></a>（2）真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</h3><p>答：实现方式有很多种，在这里举一个我能理解的乘法器和除法器：<br><img src="20201120193209527.png" alt="数据示意1"><br>如图为乘法实现原理：类比10进制乘法，利用移位运算。每次对两因数中的一个的第一位进行判断，一共判断32位共循环32次，若该位为1，则将积加上另一因数，若为0，则不用加。每次循环结束将用于判断的因数右移一位，用于和积相加的因数左移一位，循环完成后，积即为两因数的积。<br><img src="20201120193356865.png" alt="数据示意1"><br>如图为除法实现原理：类比十进制除法，利用移位运算。将被除数前32位拼接上32位的0，一共判断32位共循环32次，每次比较被除数前32位与除数相比，若大于除数，则将被除数前32位减去除数，并将整个64位的被除数加上1，若小于除数，则什么也不做，每次循环完成后将被除数左移一位。循环完成后，被除数前32位为余数，后32位为商。</p><h3 id="（3）请结合自己的实现分析，你是如何处理-Busy-信号带来的周期阻塞的？"><a href="#（3）请结合自己的实现分析，你是如何处理-Busy-信号带来的周期阻塞的？" class="headerlink" title="（3）请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？"></a>（3）请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</h3><p>答：我将其独立于一般的指令阻塞，专门写了一路用于处理其阻塞问题，只要Busy一直有效，且遇到了D级指令需要使用MDU的情况，该路便一直有效，进而导致Stall信号一直有效</p><pre><code> wire Stall_MDU = busy &amp;&amp; ( D_MDU_c || D_MDU_f ||D_MDU_t );</code></pre><h3 id="（4）请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）"><a href="#（4）请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）" class="headerlink" title="（4）请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）"></a>（4）请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</h3><p>答：清晰性：相较于单一的WE使能信号来说，字节使能让读者可以清晰看出哪一位字节是需要写入的，更加直观明了。<br>统一性：统一了SW,SB,SH三个指令的使能信号，只需要更改对应的字节使能即可实现三个指令，统一性较好</p><h3 id="（5）请思考，我们在按字节读和按字节写时，实际从-DM-获得的数据和向-DM-写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？"><a href="#（5）请思考，我们在按字节读和按字节写时，实际从-DM-获得的数据和向-DM-写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？" class="headerlink" title="（5）请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？"></a>（5）请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</h3><p>答：不为一字节，仍为按字读取。<br>如果有这样一种指令，他会读第一个字的最后一个字节的高四位，读二个字的第一个字节低四位，拼成一个半字，那么此时按字读需要读两次，而按字节读只需1次，此时效率会高。</p><h3 id="（6）为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？"><a href="#（6）为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？" class="headerlink" title="（6）为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？"></a>（6）为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</h3><p>答：比如将不同的指令在同一模块中的行为用一个信号的不同值来表示，这样减少了信号量，提高了统一性，减少了手滑写出例如：extendsign变成exrtendsign的行为产生，提高debug效率。<br><img src="微信截图_20221120204502.png" alt="数据示意1"><br>又比如对指令进行归类：将例如add,sub指令归为cal_r,addi,andi这种立即数指令归为cal_t,这样在考虑阻塞与转发时可以统一考虑，也是提高了统一性，且简洁明了<br><img src="微信截图_20221120204513.png" alt="数据示意1"></p><h3 id="（7）在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？"><a href="#（7）在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？" class="headerlink" title="（7）在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？"></a>（7）在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</h3><p>在覆盖率测试软件的结果中其实对于冲突的展示已经完全明了    </p><pre><code>转发：            &quot;average&quot;: 95.06304176516942,            &quot;cal_rr &lt;~~ cal_rr&quot;: 100.0,            &quot;cal_rr &lt;~~ cal_ri&quot;: 100.0,            &quot;cal_rr &lt;~~ mv_fr&quot;: 100.0,            &quot;cal_rr &lt;~~ load&quot;: 100.0,            &quot;cal_rr &lt;~~ lui&quot;: 100.0,            &quot;cal_rr &lt;~~ jal&quot;: 100.0,            &quot;cal_ri &lt;~~ cal_rr&quot;: 100.0,            &quot;cal_ri &lt;~~ cal_ri&quot;: 100.0,            &quot;cal_ri &lt;~~ mv_fr&quot;: 100.0,            &quot;cal_ri &lt;~~ load&quot;: 100.0,            &quot;cal_ri &lt;~~ lui&quot;: 100.0,            &quot;cal_ri &lt;~~ jal&quot;: 100.0,            &quot;br_r2 &lt;~~ cal_rr&quot;: 100.0,            &quot;br_r2 &lt;~~ cal_ri&quot;: 100.0,            &quot;br_r2 &lt;~~ mv_fr&quot;: 100.0,            &quot;br_r2 &lt;~~ load&quot;: 100.0,            &quot;br_r2 &lt;~~ lui&quot;: 100.0,            &quot;br_r2 &lt;~~ jal&quot;: 100.0,            &quot;mv_to &lt;~~ cal_rr&quot;: 100.0,            &quot;mv_to &lt;~~ cal_ri&quot;: 100.0,            &quot;mv_to &lt;~~ mv_fr&quot;: 100.0,            &quot;mv_to &lt;~~ load&quot;: 100.0,            &quot;mv_to &lt;~~ lui&quot;: 100.0,            &quot;mv_to &lt;~~ jal&quot;: 100.0,            &quot;load &lt;~~ cal_rr&quot;: 75.18518518518519,            &quot;load &lt;~~ cal_ri&quot;: 64.44444444444444,            &quot;load &lt;~~ mv_fr&quot;: 86.66666666666666,            &quot;load &lt;~~ load&quot;: 80.0,            &quot;load &lt;~~ lui&quot;: 73.33333333333333,            &quot;load &lt;~~ jal&quot;: 91.11111111111111,            &quot;store &lt;~~ cal_rr&quot;: 100.0,            &quot;store &lt;~~ cal_ri&quot;: 100.0,            &quot;store &lt;~~ mv_fr&quot;: 100.0,            &quot;store &lt;~~ load&quot;: 100.0,            &quot;store &lt;~~ lui&quot;: 100.0,            &quot;store &lt;~~ jal&quot;: 95.55555555555556,            &quot;mul_div &lt;~~ cal_rr&quot;: 92.22222222222223,            &quot;mul_div &lt;~~ cal_ri&quot;: 91.11111111111111,            &quot;mul_div &lt;~~ mv_fr&quot;: 93.33333333333334,            &quot;mul_div &lt;~~ load&quot;: 88.33333333333334,            &quot;mul_div &lt;~~ lui&quot;: 90.0,            &quot;mul_div &lt;~~ jal&quot;: 100.0,            &quot;jr &lt;~~ cal_rr&quot;: 80.0,            &quot;jr &lt;~~ cal_ri&quot;: 73.33333333333333,            &quot;jr &lt;~~ mv_fr&quot;: 80.0,            &quot;jr &lt;~~ load&quot;: 80.0,            &quot;jr &lt;~~ jal&quot;: 100.0暂停：            &quot;average&quot;: 95.52380952380952            &quot;cal_rr &lt;~~ load&quot;: 100.0,            &quot;cal_ri &lt;~~ load&quot;: 100.0,            &quot;br_r2 &lt;~~ cal_rr&quot;: 100.0,            &quot;br_r2 &lt;~~ cal_ri&quot;: 100.0,            &quot;br_r2 &lt;~~ mv_fr&quot;: 100.0,            &quot;br_r2 &lt;~~ load&quot;: 100.0,            &quot;mv_to &lt;~~ load&quot;: 100.0,            &quot;load &lt;~~ load&quot;: 100.0,            &quot;store &lt;~~ load&quot;: 100.0,            &quot;mul_div &lt;~~ load&quot;: 90.0,            &quot;jr &lt;~~ cal_rr&quot;: 80.0,            &quot;jr &lt;~~ cal_ri&quot;: 83.33333333333333,            &quot;jr &lt;~~ mv_fr&quot;: 100.0,            &quot;jr &lt;~~ load&quot;: 80.0   </code></pre><p>以上为全部P6会遇到的转发阻塞情况，这里我采用了随机+特判的方式自动化生成数据，随机可以随机出大部分的阻塞和转发情况，但由于为了保证jal,jr的跳转正确性，jal和jr的转发与阻塞则需要我构造特判指令去保证在测试完毕后$31寄存器的值不会被改变，并且可以实现转发和阻塞，以及load和store也需要我进行一些辅助特判保证不会超范围，例如：   </p><pre><code>解决 &quot;load &lt;~~ mv_fr&quot;&#123;    int base = Reg;    int rtt = rt;    int rss = rs;    while(rtt==0||rtt==base)    &#123;        rtt = Reg;        &#125;     while(rss==0||rss==rtt||rss==base)    &#123;        rss = Reg;    &#125;    sub(rtt, rtt, rtt);    sub(rss,rss,rss);    int num_1 = rand()%10;    while(num_1&lt;=4)    &#123;        num_1 = rand()%10;    &#125;    int num = (((rand()%10)+1)*4)*num_1+4;    ori(0,rtt,num_1,0);    ori(0,rss,num,0);    printf(&quot;divu $%d,$%d\n&quot;, rss, rtt);    if(Reg % 2 == 1)    &#123;        printf(&quot;mfhi $%d\n&quot;,base);    &#125;    else    &#123;        printf(&quot;mflo $%d\n&quot;,base);    &#125;    if(Reg % 3)    &#123;        int rad= Delayinstr;        while(rad == 8 || rad == 9)        &#123;            rad = Delayinstr;            &#125;         Choose(rad, 0, rss, rtt, base, 0, 0);    &#125;    int random = Reg;    if((random % 3) == 0)    &#123;        printf(&quot;lw $%d,0($%d)\n&quot;, rss,base);    &#125;    else if((random % 3) == 1)    &#123;        printf(&quot;lh $%d,0($%d)\n&quot;, rss,base);    &#125;    else    &#123;        printf(&quot;lb $%d,0($%d)\n&quot;, rss,base);     &#125;</code></pre><p>在这个程序段中，我会构造出不会超出load地址范围的数据，并进行乘法，除法（随机）运算并Mflo或Mfhi(随机），并紧跟或隔一条无关指令（随机）<br>在紧接lb,lw,lh（随机）且寄存器就是mfhi/mflo的目标寄存器实现保证正确运行下的阻塞与运行</p><h3 id="（8）如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。"><a href="#（8）如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。" class="headerlink" title="（8）如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。"></a>（8）如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。</h3><p>答：我选择的是随机+特判的方式构造数据，随机可以覆盖大部分的阻塞和转发，但正如我前面所说，为了保证程序的正确运行完全随机是不可信的，这必然导致一些代码的固定化，而一些代码的固定化必然导致一些阻塞与转发的无效化，所以为了保证正确性与覆盖率兼得，所以引入特判是必须的，比如，如果load指令Base不为0就需要对这个寄存器提前处理，不要让其数据太大，导致加和超出范围，store同理，jal和jr则需要测试前后$31的寄存器值不变，才能正确跳转，这便是特判+随机Orz （虽然P5教程上的一些构造方法真的很吸引人，但时间成本对我来说有点高，所以最终出此下策）<br>至于如何结合随机性，具体来说：固定的指令段之间会随机插入不影响这一段固定指令对应寄存器值的指令，固定的指令段的寄存器随机产生，而且，不影响正确结果的情况下，指令段的固定其实是指令类的固定，比如ori+load（lb,lh,lw)这种,最后效果还是蛮好的。</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易流水线CPU全自动测试思路（Verilog）</title>
      <link href="/posts/5928/"/>
      <url>/posts/5928/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P5的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><font size = 3><font color="purple">如果P3,P4大家有好好的做数据生成，那么P5的数据生成的工作将主要体现在对于数据生成器的优化上，对于数据执行器则无需太大的优化。</font></font>      <font size = 3><font color="green">如果大家是从P5才开始做测试，那么建议看看笔者博客中P3 P4的自动化测试，很多工作在那时就已经完成，P5的自动化将迭代开发，在本篇博客中将不再赘述。</font></font>    <h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars_perfect.jar mc CompactDataAtZero nc db test.asm &gt; mar.txt</span><br></pre></td></tr></table></figure> <p><strong>有小问号可能要问了，这和P4没啥区别啊这？其实区别就在于”db”，这是要求Mars执行时按延迟槽执行的指令。</strong>  </p><h1 id="Python实现（数据执行器）"><a href="#Python实现（数据执行器）" class="headerlink" title="Python实现（数据执行器）"></a>Python实现（数据执行器）</h1><h2 id="基础功能迭代"><a href="#基础功能迭代" class="headerlink" title="基础功能迭代"></a>基础功能迭代</h2><p>迭代在P4的基础，我们只需要更改命令行学习中的那一条指令即可完成P5的数据执行器。  </p><h2 id="自动存储机器码"><a href="#自动存储机器码" class="headerlink" title="自动存储机器码"></a>自动存储机器码</h2><p>在P4中笔者只是将asm文件和比较结果进行了存储，并没有保存机器码，在P5笔者建议保留机器码文件，具体原因见后。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dir_name_3 = &#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\机器码文件\\&#x27;</span><br><span class="line">f_1 = open(&#x27;code.txt&#x27;, &quot;r&quot;)</span><br><span class="line">list_temp = f_1.readlines()</span><br><span class="line">f_2 = open(dir_name_3 + &#x27;test&#x27;+str(test_order)+&#x27;.txt&#x27;, &quot;w&quot;)</span><br><span class="line">f_2.writelines(list_temp)</span><br><span class="line">f_1.close()</span><br><span class="line">f_2.close()</span><br></pre></td></tr></table></figure><br>功能：将生成的机器码文件Code.txt的内容复制到test+第几次测试.txt中，并放到dir_name_3的目录下。<strong>（此处使用绝对目录）</strong></p><h2 id="自动打包"><a href="#自动打包" class="headerlink" title="自动打包"></a>自动打包</h2><p>机器码其实本来就是可有可无的东西，毕竟只要有asm,需要时我们就能手动生成，但是，考虑到从P5开始，计组提供了数据构造测试器，可以测试我们构造数据的强度，但数据构造测试器有一个极其阴间的一点是：    </p><p><strong><font color="green">我们必须将每一个机器码打包成一个压缩包，再将整体压缩包打包成一个压缩包，对于命名还有很多的要求，比如P5的数据必须以P5开头等等，初期手搓的笔者已经累傻了，所以我们要自动化打包。</font></strong>   </p><p>笔者打包使用360压缩，建议大家同样使用360压缩进行打包，因为360压缩支持<strong>命令行操作</strong>，我们因此得以利用Python的OS库调用360压缩<strong>自动化打包</strong>每一次生成的机器码文件，并命名。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zip(i+<span class="number">1</span>)</span><br><span class="line">def zip(test_order):</span><br><span class="line">os.system(&quot;\&quot;<span class="number">360</span>压缩安装目录&quot; -ar code.txt 打包好的压缩包存放位置\\&quot;命名.zip&quot;)</span><br><span class="line">例如：</span><br><span class="line">os.system(&quot;\&quot;C:\\Program Files (x86)\\<span class="number">360</span>\\<span class="number">360</span>zip\\<span class="number">360</span>zip.exe\&quot; -ar code.txt C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\压缩文件\\P5_Q&quot;+str(test_order)+&quot;.zip&quot;)</span><br></pre></td></tr></table></figure><br><strong>TIPS: </strong>- ar前面为360压缩安装目录，后面为打包好的压缩包存放位置。</p><h1 id="数据生成器迭代思路"><a href="#数据生成器迭代思路" class="headerlink" title="数据生成器迭代思路"></a>数据生成器迭代思路</h1><h2 id="P5指令集："><a href="#P5指令集：" class="headerlink" title="P5指令集："></a>P5指令集：</h2><p><strong>{add,sub,ori,lw,sw,beq,lui,jal,jr,nop}</strong></p><h2 id="迭代思路："><a href="#迭代思路：" class="headerlink" title="迭代思路："></a>迭代思路：</h2><p><strong>• 整体构造思路</strong></p><font color="purple">（1）需求制造规则，规则产生需求，不断循环迭代。在原有的数据生成上不断添加规则，增强随机性，直至取得一个良好的效果，说人话就是，一旦针对某一项需求设定了规则，就可能导致随机性或正确性的下降，而为了弥补这个随机性的下降，提高随机性，就产生了新的需求，就必然导致新规则的加入以提高随机性。或者是为了保证正确性，就需要添加新的规则，来修补漏洞。而修补漏洞也可能导致随机性的下降，有需要产生新的规则提高随机性。笔者的数据生成就是在这样的循环开发中不断走向圆满的。</font> </br><font color="blue">（2）如果为了保持正确性，有需要固定生成的一些随机指令，举一个例子，笔者往往选择如下方式尽可能地提高随机性：</font> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令类（cal_i,cal_r....)</span><br><span class="line">（可能随机<span class="number">0</span><span class="number">-2</span>条无关指令）  #无关指令：寄存器不相关</span><br><span class="line">jr（冲突指令)</span><br></pre></td></tr></table></figure><p>这样由于中间无关指令可能产生，可能不产生，实现了不同流水级转发的效果，且采用指令类解决冲突，提高了不同指令对同一指令的转发冲突解决效果。&lt;/br&gt;</p><p><strong>• 迎合流水线设计，缩减寄存器范围，提高转发和冲突的出现频率，增强测试强度。在这里我们将寄存器范围缩减到0-5。</strong></p><font color="red">注意：数据的生成中往往会因为0号寄存器的存在导致一些不可预料的错误，这些都需要我们特别增加生成规则，或许有人会考虑将寄存器范围缩减到1-6，但这样会面临着一些关于0寄存器读出，转发，写入的问题没法检测出来，降低了生成强度。</font>  <p><strong>• 加入负数测试，现在lw,sw都会随机生成负数立即数，用来检验EXT模块的正确性。</strong></p><font color="red">但，这样的加入仍然是有代价的，我们仍然需要添加规则，使得offset+寄存器的值>=0，否则将出错，笔者这里采用了一旦要这样做，就提前指定一个寄存器，为其赋大于该负数的值，然后再执行lw,sw</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    rs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> imm1 = I;</span><br><span class="line"><span class="type">int</span> imm2 = I;</span><br><span class="line"><span class="keyword">if</span> (imm1 &lt; imm2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = imm1;</span><br><span class="line">    imm1 = imm2;</span><br><span class="line">    imm2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line"><span class="built_in">ori</span>(rs, rs, imm1, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> imm3 = <span class="number">0</span> - imm2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rt, imm3, rs);</span><br><span class="line">grf[rt] = dm[(imm3 + imm1) / <span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>在这一段代码中，同时有两个规则在起作用，和我上文提到的两条都有关系，比如对rs=0的处理，如果rs是0，不对其进行处理，那么对rs赋值也是白赋值，rs的值恒为0，导致offset+[rs]小于0的问题的出现。Mars将会报错。<br>再比如对负数的处理，笔者随机生成两个数，进行比较，然后将小的那一个取反，大的那一个赋值给寄存器，保证了lw和sw寻址大于0.  </p><p><strong>• 保证延迟槽必无beq,j等跳转指令！维护理论正确性</strong></p><font color="red">延迟槽中是不能有跳转指令的，否则将是一个UB行为，而且大概率来讲，大家写的CPU将会直接死循环，而Mars则会正确运行。对于这条的处理相对比较简单，只要在随机延迟槽指令时，判断是否是跳转，如果是则再在指令池当中抽取一条即可！</font><p><strong>• 保证lw,sw在经过负数和寄存器值相加后字对齐，不会报错！</strong></p><font color="red">由于lw，sw是按字读取，所以地址加和后必须是4的倍数，否则Mars将报错，因此我们需要改变随机数的生成规则，这里笔者取巧了一下，将随机数的生成全部生成为4的倍数，且寄存器永远为$0，保证了字对齐，至于前面所提到的负数的情况，由于寄存器的值也是随机数生成的，所以加起来仍然是4的倍数，仍然字对齐。</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> I ((rand() + rand()) % 40) * 4</span></span><br></pre></td></tr></table></figure><p><strong>• 移除无用的nop</strong></p><font color="red">笔者认为，nop在流水线中是极其无用的指令，加入Nop将减少转发冲突的产生，因此笔者在生成指令时拒绝了Nop的生成</font><font color="green">至于nop的功能正确性，嘛，这不还有计组平台的弱测帮你测试这个功能嘛~</font><p><strong>• 对于jal转发暂停的特殊解决</strong></p><font color="red">在P3,P4我们提到，为了保证程序运行的整体正确性，对于jal和beq的生成我们都是有规则的，且对于jal近乎是以固定于每一代码段的末尾的方式生成的，而这种非随机化的规则必然带来代价——转发冲突覆盖的不全面，首当其冲就是jal和各种指令的转发阻塞覆盖的缺失，且由于$31寄存器承担着正确运行的职能，我们还不能随意更改，必须在真正执行Jal前改回来，因此对于jal来说，我们依旧需要提供大量的规则，增强随机性，覆盖其转发阻塞。</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sw_jal</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> imm = <span class="number">-12288</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lw_jal</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> imm = <span class="number">-12288</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="keyword">if</span> (Reg % <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;jal Test_jal%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">Choose</span>(Stall_Jal, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;beq $0,$0,Test_beq%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">Choose</span>(Stall_Jal, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test_jal%d: jr $ra\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test_beq%d:\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">Choose</span>(Normal, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;jal Test%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">Choose</span>(Delayinstr, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">ori</span>(<span class="number">31</span>, rt, I, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="built_in">lw_jal</span>(<span class="number">31</span>, rt);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">        <span class="built_in">sw_jal</span>(<span class="number">31</span>, rt);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">        <span class="type">int</span> g = Reg % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (g==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">            <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">            <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  </span></span><br><span class="line">            <span class="built_in">add</span>(rd, <span class="number">0</span>, <span class="number">31</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(g==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">            <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">            <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  $31=0</span></span><br><span class="line">            <span class="built_in">ori</span>(rd, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(g==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> immi = I;</span><br><span class="line">            <span class="built_in">sub</span>(rt, rt, rt);</span><br><span class="line">            <span class="built_in">sw_diy</span>(rt, <span class="number">31</span>, immi);</span><br><span class="line">            <span class="built_in">sub</span>(<span class="number">31</span>,<span class="number">31</span>,<span class="number">31</span>);</span><br><span class="line">            <span class="built_in">lw_diy</span>(rt, <span class="number">31</span>, immi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">            <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">            <span class="built_in">sub</span>(rd, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  </span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sw_diy</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> rt, <span class="type">int</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rt, imm, base);</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lw_diy</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> rt, <span class="type">int</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rt, imm, base);</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br></pre></td></tr></table></figure><p>其余的特殊转发都很类似，只需不断地添加规则增强随机性，不断地修正新规则所带来的正确性的问题，最后实现覆盖。</p><p><strong>• 其余特殊解决</strong></p><font color="blue">由于时间过于久远，笔者也记不住自己究竟写了多少条规则限制数据生成，更详细的规则还请大家移步文章最后我的数据生成代码查看，谢谢！</font><p><strong>大家可能觉得这样会很复杂，但实话说，随机生成就是有着这样的缺陷，其指令的正确性只能通过不断地添加规则来实现，但不得不承认，随机生成法在上学这种没有很多空余时间的期间，是投入与产出性价比最高的测试方式。</strong></p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;grade&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;forward&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;average&quot;</span>: <span class="number">93.8735632183908</span>,</span><br><span class="line">    <span class="string">&quot;stall&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;average&quot;</span>: <span class="number">100.0</span>,</span><br></pre></td></tr></table></figure><h1 id="Python自动化测试框架代码"><a href="#Python自动化测试框架代码" class="headerlink" title="Python自动化测试框架代码"></a>Python自动化测试框架代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> filestools</span><br><span class="line"><span class="keyword">from</span> filediff.diff <span class="keyword">import</span> file_diff_compare</span><br><span class="line">p_road = <span class="string">&quot;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\FlowCpu&quot;</span></span><br><span class="line">run_time = <span class="string">&quot;100us&quot;</span></span><br><span class="line">xilinx_path = <span class="string">&quot;G:\\ISE\\14.7\\ISE_DS\\ISE&quot;</span></span><br><span class="line">dir_name = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\mars文件\\&#x27;</span></span><br><span class="line">dir_name_3 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\机器码文件\\&#x27;</span></span><br><span class="line">dir_name_1 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\比较文件\\&#x27;</span></span><br><span class="line">dir_name_2 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\&#x27;</span></span><br><span class="line">error = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成指令中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    command = <span class="string">&quot;C语言.exe&quot;</span></span><br><span class="line">    os.system(command)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;test.asm&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.asm&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mar</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成机器码中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars_perfect.jar mc CompactDataAtZero a dump .text HexText code.txt nc test.asm&quot;</span>)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;code.txt&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name_3 + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.txt&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line">    <span class="comment"># print(&quot;生成标准答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc db test.asm &gt; mar.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟槽 os.system(&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc db test.asm &gt; mar.txt&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ise</span>():</span><br><span class="line">    <span class="comment"># print(&quot;运行ise中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(p_road):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">                file_list.append(file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">            prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + p_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">        tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">    prj.close()</span><br><span class="line">    tcl.close()</span><br><span class="line">    os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path</span><br><span class="line">    os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + p_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + p_road + <span class="string">&quot;\\mips.tcl&gt; raw_out.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>():</span><br><span class="line">    <span class="comment"># print(&quot;转换ise答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">        mymem = mymem + myfriendmem[i];</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(mymem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_file</span>(<span class="params">name, target_road</span>):</span><br><span class="line">    f_1 = <span class="built_in">open</span>(name, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(target_road + <span class="string">&quot;\\&quot;</span> + name, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_cmp</span>(<span class="params">test_order</span>):</span><br><span class="line">    co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    co.write(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mar.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> out_1:</span><br><span class="line">        out_std = out_1.readlines()</span><br><span class="line">        out_std.remove(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> out_2:</span><br><span class="line">        out_test = out_2.readlines()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.\\log.txt&quot;</span>.<span class="built_in">format</span>(test_order), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(out_std) &gt; <span class="built_in">len</span>(out_test):</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out_std)):</span><br><span class="line">                <span class="keyword">if</span> out_std[i] != out_test[i]:</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Wrong Answer!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Wrong Answer!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Accepted!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Accepted!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    co.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> f.readlines()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: 没有找到文件:%s！&quot;</span> % filename)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_file</span>(<span class="params">file1, file2, out_file</span>):</span><br><span class="line">    file1_content = read_file(file1)</span><br><span class="line">    file2_content = read_file(file2)</span><br><span class="line">    d = difflib.HtmlDiff()</span><br><span class="line">    result = d.make_file(file1_content, file2_content)</span><br><span class="line">    fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    fb.write(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zip</span>(<span class="params">test_order</span>):</span><br><span class="line">    os.system(<span class="string">&quot;\&quot;C:\\Program Files (x86)\\360\\360zip\\360zip.exe\&quot; -ar code.txt C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\压缩文件\\P5_Q&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;.zip&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入测试次数:&quot;</span>)</span><br><span class="line">test_times =<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">co.write(<span class="string">&quot;测试次数:&quot;</span>+<span class="built_in">str</span>(test_times)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">co.close()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">    generate(i+<span class="number">1</span>)</span><br><span class="line">    run_mar(i+<span class="number">1</span>)</span><br><span class="line">    run_ise()</span><br><span class="line">    process()</span><br><span class="line">    <span class="built_in">zip</span>(i+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># print(&quot;比较答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    compare_file(<span class="string">r&#x27;verilog.txt&#x27;</span>, <span class="string">r&#x27;mar.txt&#x27;</span>, <span class="string">&#x27;result&#x27;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">    file_cmp(i+<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P5">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P5</a></p><p><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P5课上强测！</font></strong></p><p><strong><font size = 5>P5数据生成器代码行数：445行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易流水线CPU设计文档（Verilog）</title>
      <link href="/posts/3119/"/>
      <url>/posts/3119/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Verilog 简易流水线CPU设计文档</center></font></strong></p><h1 id="一、CPU设计方案综述"><a href="#一、CPU设计方案综述" class="headerlink" title="一、CPU设计方案综述"></a>一、CPU设计方案综述</h1><h2 id="（一）总体设计综述"><a href="#（一）总体设计综述" class="headerlink" title="（一）总体设计综述"></a>（一）总体设计综述</h2><p>使用Verilog开发一个流水线CPU,总体概述如下：<br>1.此流水线CPU为32位CPU<br>2.此CPU为流水线设计<br>3.此CPU支持的指令集为:{add,sub,ori,lw,sw,beq,lui,jal,jr,nop}<br>4.nop的机器码为0x0000000<br>5.add，sub不支持溢出</p><h2 id="（二）关键模块定义"><a href="#（二）关键模块定义" class="headerlink" title="（二）关键模块定义"></a>（二）关键模块定义</h2><h3 id="F-IFU"><a href="#F-IFU" class="headerlink" title="F_IFU"></a>F_IFU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前指令</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">取指令</td><td style="text-align:center">取出当前PC所对应的指令</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">更改PC值</td><td style="text-align:center">利用NPC更改PC值</td></tr></tbody></table></div><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">A3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其作为RD的写入地址</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位写入数据</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A2指定寄存器的32位数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号，清零32个寄存器中的数据</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">同步复位</td><td style="text-align:center">时钟上升沿到来时，若RESET信号有效，则将32个寄存器中的数据全部清除</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A1与A2所存地址对应的寄存器的数据读出到RD1和RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD写入到A3所存地址对应的寄存器中</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">转发数据</td><td style="text-align:center">当A3\==A2或A3\==A1且WE有效，A3!=0时，将WD中的数据作为RD1或RD2的输出</td></tr></tbody></table></div><h3 id="ID-ID-REG"><a href="#ID-ID-REG" class="headerlink" title="ID_ID_REG"></a>ID_ID_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">IF_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段机器码</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">IF_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">ID阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">O</td><td style="text-align:center">扩展类型信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">O</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RegWrite</td><td style="text-align:center">O</td><td style="text-align:center">寄存器写使能信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MemWrite</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">MemToReg[2:0]</td><td style="text-align:center">O</td><td style="text-align:center">Reg写入数据类型信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">RegDest[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">A3寄存器选择信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ALUop[3:0]</td><td style="text-align:center">O</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">O</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">O</td><td style="text-align:center">Jr信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">RegSrc</td><td style="text-align:center">O</td><td style="text-align:center">ALU数据来源选择信号</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">imm16[15:0]</td><td style="text-align:center">O</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">imm26[25:0]</td><td style="text-align:center">O</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">rs[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rs寄存器编号</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">rt[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rt寄存器编号</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">rd[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rd寄存器编号</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">load</td><td style="text-align:center">O</td><td style="text-align:center">是否为lw指令</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">store</td><td style="text-align:center">O</td><td style="text-align:center">是否为sw指令</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">cal_r</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_r类指令</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">cal_i</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_i类指令</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">jal</td><td style="text-align:center">O</td><td style="text-align:center">是否为jal指令</td></tr></tbody></table></div><p>(2)真值表</p><div class="table-container"><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">add</th><th style="text-align:center">sub</th><th style="text-align:center">ori</th><th style="text-align:center">lw</th><th style="text-align:center">sw</th><th style="text-align:center">lui</th><th style="text-align:center">beq</th><th style="text-align:center">Jal</th><th style="text-align:center">Jr</th></tr></thead><tbody><tr><td style="text-align:center">OP</td><td style="text-align:center">000000</td><td style="text-align:center">000000</td><td style="text-align:center">001101</td><td style="text-align:center">100011</td><td style="text-align:center">101011</td><td style="text-align:center">001111</td><td style="text-align:center">000100</td><td style="text-align:center">000011</td><td style="text-align:center">000000</td></tr><tr><td style="text-align:center">FC</td><td style="text-align:center">100000</td><td style="text-align:center">100010</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">001000</td></tr><tr><td style="text-align:center">ALUop</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0011</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0100</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">Jump</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">RegWrite</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemWrite</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemToReg</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegDest</td><td style="text-align:center">01</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegSrc</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Branch</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jreg</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">B[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Equal</td><td style="text-align:center">O</td><td style="text-align:center">A==B？1：0</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">比较</td><td style="text-align:center">比较操作数A与B是否相等，相等则Equal有效</td></tr></tbody></table></div><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">F_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段的PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段的PC值</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Beq指令</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jal指令</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jr指令</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Jal_imm26[25:0]</td><td style="text-align:center">I</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">D_GRF_Jr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">Jr目标寄存器数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">Beq_imm16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">Equal</td><td style="text-align:center">I</td><td style="text-align:center">D_CMP两操作数是否相等</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">PC的下一值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">计算下一PC的值</td><td style="text-align:center">根据指令和当前PC值计算下一PC值</td></tr></tbody></table></div><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">经过扩展后的32位立即数</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">I</td><td style="text-align:center">选择扩展类型信号  0：符号扩展 1：无符号扩展</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">符号扩展</td><td style="text-align:center">将16位立即数符号扩展为32位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">无符号扩展</td><td style="text-align:center">将16位立即数无符号扩展为32位立即数</td></tr></tbody></table></div><h3 id="ID-EX-REG"><a href="#ID-EX-REG" class="headerlink" title="ID_EX_REG"></a>ID_EX_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_RD1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">D_imm32[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段32位立即数</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">EX_RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">EX_imm32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段32位立即数</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">EX阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ALUControl[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">运算结果</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">判断两个操作数是否相等</td><td style="text-align:center">相等则Bigger输出1否则为0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">加运算</td><td style="text-align:center">res=SrcA+SrcB</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">减运算</td><td style="text-align:center">res=SrcA-SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">与运算</td><td style="text-align:center">res=SrcA$SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">或运算</td><td style="text-align:center">res=SrcB</td><td>SrcB</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">加载高位运算</td><td style="text-align:center">res={SrcB[15:0],16’h0}</td></tr></tbody></table></div><h3 id="EX-MEM-REG"><a href="#EX-MEM-REG" class="headerlink" title="EX_MEM_REG"></a>EX_MEM_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">MEM_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">MEM阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="M-DM"><a href="#M-DM" class="headerlink" title="M_DM"></a>M_DM</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">32位数据输出</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位数据输入</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD中的数据写入到A所存地址所对应的位置</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A所存地址对应位置的数据读出到RD</td></tr></tbody></table></div><h3 id="MEM-WB-REG"><a href="#MEM-WB-REG" class="headerlink" title="MEM_WB_REG"></a>MEM_WB_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">MEM_DM_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段DM读出数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WB_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WB_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">WB_DM_RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段DM读出数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">WB_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">WB阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Stall"><a href="#Stall" class="headerlink" title="Stall"></a>Stall</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">D_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Stall</td><td style="text-align:center">O</td><td style="text-align:center">阻塞信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">阻塞功能</td><td style="text-align:center">判断当前流水线是否需要在ID阶段阻塞</td></tr></tbody></table></div><p>(3)判断方法——AT法</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">rsTuse</th><th style="text-align:center">rtTuse</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">0</td><td style="text-align:center">-</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">E_Tnew</th><th style="text-align:center">M_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><h3 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">W_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_Forward</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">MEM_Forward</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">WB_Forward</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段数据是否可以转发信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">转发信号</td><td style="text-align:center">判断每个阶段是否可以为前面转发数据</td></tr></tbody></table></div><h1 id="转发暂停控制"><a href="#转发暂停控制" class="headerlink" title="转发暂停控制"></a>转发暂停控制</h1><h2 id="暂停："><a href="#暂停：" class="headerlink" title="暂停："></a>暂停：</h2><pre><code>wire Stall_rs_E = (E_RegDest == D_rs) &amp;&amp;(E_RegDest) &amp;&amp; (T_use_rs &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_rt_E = (E_RegDest == D_rt) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rt &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_E = Stall_rs_E || Stall_rt_E;wire Stall_rs_M = (M_RegDest == D_rs) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rs &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_rt_M = (M_RegDest == D_rt) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rt &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_M = Stall_rs_M || Stall_rt_M;assign Stall = Stall_M || Stall_E;      </code></pre><h2 id="转发："><a href="#转发：" class="headerlink" title="转发："></a>转发：</h2><pre><code>wire [31:0] D_Forward_rs = (D_rs == 0)? 0 :            ((E_RegDest == D_rs) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :        ((M_RegDest == D_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD1;wire [31:0] D_Forward_rt = (D_rt == 0)? 0 :            ((E_RegDest == D_rt) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :            ((M_RegDest == D_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD2;wire [31:0] E_Forward_rs =   (E_rs == 0) ? 0 :        ((M_RegDest == E_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rs) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD1;wire [31:0] E_Forward_rt =   (E_rt == 0) ? 0 :        ((M_RegDest == E_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rt) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD2;</code></pre><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>为<strong>自动化测试</strong>：<br>共随机生成1000组数据<br><img src="微信截图_20221106010804.png" alt="数据示意1"><br>并生成1000组比对文件<br><img src="微信截图_20221106010955.png" alt="数据示意2"><br>和一个总体结果文件<br><img src="微信截图_20221106011047.png" alt="数据示意3"></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="（1）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。"><a href="#（1）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。" class="headerlink" title="（1）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。"></a>（1）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</h3><p>答：分支判断确实是提前了，但其他指令并没有提前，这或许会导致原本只需要进行转发的指令因为这一提前而不能及时生成导致需要阻塞，例如：  </p><pre><code>add $t1,$t2,$t3beq $t1,$t2,labellabel:</code></pre><p>在这个例子中，Beq的提前判断会导致原本转发可以解决的$t1的值的更新需要阻塞一个周期。<br>因为Beq在ID阶段CMP中判断时，add指令$t1的值还没有存入流水线寄存器，不能转发，需要阻塞一周期。<br>若Beq在EX阶段ALU中判断，则此时EX/MEM流水线寄存器中已经存有了$t1正确的值，可以转发，不需要阻塞。</p><h3 id="（2）因为延迟槽的存在，对于-jal-等需要将指令地址写入寄存器的指令，要写回-PC-8，请思考为什么这样设计？"><a href="#（2）因为延迟槽的存在，对于-jal-等需要将指令地址写入寄存器的指令，要写回-PC-8，请思考为什么这样设计？" class="headerlink" title="（2）因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？"></a>（2）因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？</h3><p>答：延迟槽的存在，会让jal跳转时也会执行其下一条指令，也正因为这条指令已经被执行过了，为了维护程序的正确性，当利用jr或其他指令返回时，我们需要跳到Jal的下两条指令，即PC+8，也因此要将它存入$31寄存器中，而非PC+4</p><h3 id="（3）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如-DM-、-ALU-），请思考为什么？"><a href="#（3）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如-DM-、-ALU-），请思考为什么？" class="headerlink" title="（3）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？"></a>（3）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？</h3><p>答：首先我个人认为从功能部件进行转发也是合理的，即“Brutal-Forward”，但这样转发显然没有流水线转发直观，会让转发的控制变得更加复杂。</p><h3 id="（4）我们为什么要使用-GPR-内部转发？该如何实现？"><a href="#（4）我们为什么要使用-GPR-内部转发？该如何实现？" class="headerlink" title="（4）我们为什么要使用 GPR 内部转发？该如何实现？"></a>（4）我们为什么要使用 GPR 内部转发？该如何实现？</h3><p>答：GPR内部转发可以实现WB-&gt;ID的转发，举个例子：     </p><pre><code>WB:add $t1,$t2,$t3ID:sub $t1,$t2,$t3</code></pre><p>此时显然ID中的SUB需要使用的是WB中$t1的值，因此需要转发，利用该内部转发便可实现这样的功能，提高流水线运行效率。<br><strong>实现方法</strong>:<br><img src="微信截图_20221106013054.png" alt="实现方法"><br>如图：只需在RD1和RD2输出加一个三目运算符即可<br>！注意：需要考虑A3是否为0（对$0写入实际写入为0，而并非WD）<br>！注意：需要考虑WE是否有效（只有对GRF写入的数据才应该被转发）<br>！注意：需要考虑A1或A2是否等于A3（只有相同寄存器的数据才需要被转发）</p><h3 id="（5）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？"><a href="#（5）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？" class="headerlink" title="（5）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？"></a>（5）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</h3><p>答：<br><strong>需求者</strong>：CMP的两个操作数；ALU的两个操作数；DM的WD端口<br><strong>供给者</strong>：ID_EX流水线寄存器，EX_MEM流水线寄存器，MEM_WB流水线寄存器<br><strong>通路</strong>：<br>ID_EX-&gt;CMP<br>EX_MEM-&gt;CMP<br>MEM_WB-&gt;CMP<br>EX_MEM-&gt;ALU<br>MEM_WB-&gt;AKU<br>MEM_WB-&gt;DM</p><h3 id="（6）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。"><a href="#（6）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。" class="headerlink" title="（6）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。"></a>（6）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</h3><p>答：<br>跳转：可能需要在Control加入新的控制信号识别该指令,并在NPC中加入完成该指令的方法，并添加if分支选择其作为NPC，并考虑跳转和阻塞问题。<br>计算：可能需要在Control加入新的ALUop信号计算该指令，并在ALU中加入完成该指令的方法，并考虑跳转和阻塞问题。<br>访存：可能需要在Control加入新的控制信号识别该指令，并在DM中完成该访存的方法，并考虑跳转和阻塞问题。</p><h3 id="（7）简要描述你的译码器架构，并思考该架构的优势以及不足。"><a href="#（7）简要描述你的译码器架构，并思考该架构的优势以及不足。" class="headerlink" title="（7）简要描述你的译码器架构，并思考该架构的优势以及不足。"></a>（7）简要描述你的译码器架构，并思考该架构的优势以及不足。</h3><p>答：<br>我选用的是分布式译码器，该架构的<strong>优势</strong>在于不需要流水控制信号，只需要在不同的流水线阶段生成不同的控制信号即可，实现起来无论是思路还是代码量上都远远少于集中式译码器，且不用考虑Tnew随周期数减少的问题。<br><strong>不足</strong>在于多次实例化Control模块，每一次实例都闲置了大量的端口，造成了资源的浪费。且实际应用中增加了数据通路的长度，降低了效率。</p><h3 id="（8）请详细描述你的测试方案及测试数据构造策略。"><a href="#（8）请详细描述你的测试方案及测试数据构造策略。" class="headerlink" title="（8）请详细描述你的测试方案及测试数据构造策略。"></a>（8）请详细描述你的测试方案及测试数据构造策略。</h3><p>答：测试方案：<br>（1）第一步编写生成指令代码，自动生成为test.asm文件<br>（2）第二步利用python os库运行mars执行“test.asm”使其生成“command.txt”（里面为机器码）<strong>和</strong>标准输出（魔改mars)“mar.txt”<br>（3）第三步自动生成ise的.prj和.tcl文件<br>（4）第四步利用python os库运行ise使其生成“raw_out.txt”<br>（5）第五步将raw_out的头部无用内容处理掉，生成”verilog.txt”文件<br>（5）第五步利用python difflib或进行文本比较，生成“result.html”并输出”Accepted!”或“Wrong Answer!”</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单周期CPU全自动测试思路（Verilog）</title>
      <link href="/posts/34987/"/>
      <url>/posts/34987/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P4的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p><p style="color: #FF00FF;">在笔者看来，由于P5,P6,P7需要大量的数据作为支持，且均为Verilog语言，所以在P4学好自动化测试是十分有必要的，它可以免除你课上担心课下CPU有问题的后顾之忧，大大增加你PASS的几率。</p></p><p><p style="color: #00FF00;">而且，从P4开始，我们的自动化测试对拍对象不是小伙伴，完全可以是Mars，对我们的测试难度降低了很多，笔者在这里十分建议大家学一学自动化测试。</p><br>通过阅读本文，你可以了解到如何<del>蒟蒻</del>合理生成不会陷入死循环不会报错的指令，并了解到对Verilog进行自动化测试的相关方法。</p><h1 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h1><p>作者对于Verilog的学习全程采用ISE，<font color="red">（学会ISE是能做P8的基础）</font>所以我们这里介绍ISE的命令行操作。</p><h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><h2 id="MARS命令行"><a href="#MARS命令行" class="headerlink" title="MARS命令行"></a>MARS命令行</h2><h3 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a>官方教程</h3><p><img src="MARS官方教程.png" alt="MARS官方教程"><br>对其他命令感兴趣的小伙伴可以去这里看看~ </p><h3 id="速通版本"><a href="#速通版本" class="headerlink" title="速通版本"></a>速通版本</h3><h4 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h4><p>来到P4,原有的MARS已经不能满足我们的要求，因此我们需要一个<font color="red">可以显示每一条指令对GRF和DM读写信息的MARS</font>，笔者在此为大家准备了一个:<a href="https://pan.baidu.com/s/1UCrD0v5SnoU5i_ptZ4B__A?pwd=jkvq">Mars_perfect</a>,提取码：jkvq,需要的uu可以自取。</p><h4 id="生成机器码"><a href="#生成机器码" class="headerlink" title="生成机器码"></a>生成机器码</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars_perfect.jar mc CompactDataAtZero a dump .text HexText code.txt nc test.asm</span><br></pre></td></tr></table></figure> <p>该命令行的意思是，<strong>运行Mars_perfect.jar将test.asm文件中.text部分指令转换为机器码输出到code.txt中（中间是参数，具体意思见官方教程）</strong><br>产生机器码，是为了提供给ISE的CPU使用。</p><h4 id="运行MARS生成标答"><a href="#运行MARS生成标答" class="headerlink" title="运行MARS生成标答"></a>运行MARS生成标答</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars_perfect.jar mc CompactDataAtZero nc test.asm &gt; mar.txt</span><br></pre></td></tr></table></figure>  <p>该命令行的意思是，<strong>运行Mars_perfect.jar将test.asm中每一条指令对GRF和DM的修改输出到mar.txt中</strong><br>便于和ISE产生的CPU信息对拍。</p><h4 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h4><p>以上运行时均需保证Cmd运行在Mars_perfect.jar和test.asm的根目录下</p><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p><img src="Mar输出文件.png" alt="MARS输出文件"></p><h2 id="ISE命令行"><a href="#ISE命令行" class="headerlink" title="ISE命令行"></a>ISE命令行</h2><h3 id="配置系统环境"><a href="#配置系统环境" class="headerlink" title="配置系统环境"></a>配置系统环境</h3><p>要顺利利用命令行运行ISE，我们需要首先配置系统环境,将ISE主题文件路径配置到系统变量中。<br>1、桌面—&gt;右击“我的电脑”—&gt;“属性”—&gt;切换至“高级系统设置”选项卡<br>2、进入环境变量对话框后，点击下面的“系统变量”的“新建”，添加下面环境变量：<br>变量名： XILINX<br>变量值：    安装Xilinx ISE的路径，如我的是：G:\\ISE\\14.7\\ISE_DS\\ISE</p><font size = 3><font color="green">当然，如果使用Python实现自动化，则无需配置，具体见后</font></font> <h3 id="准备生成可执行CPU文件"><a href="#准备生成可执行CPU文件" class="headerlink" title="准备生成可执行CPU文件"></a>准备生成可执行CPU文件</h3><p>要生成可供自动化测试执行的CPU文件，我们首先需要生成和顶层模块同名的.prj和.tcl文件:  </p><font color="purple">.prj是告诉命令行要编译哪些.v文件: </font><p><img src="prj文件内容.png" alt="prj文件内容">     </p><font color="green">.tcl是告诉命令行要让CPU运行多长时间。</font>    <p><img src="tcl文件内容.png" alt="tcl文件内容"><br>为了保证每次我们更新CPU后这些文件可以被及时更新，我们可以采用Python每次<strong>自动化生成</strong>.prj和.tcl文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file_list = []</span><br><span class="line"><span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(p_road):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">            file_list.append(file)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">        prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + p_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">    tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">prj.close()</span><br><span class="line">tcl.close()</span><br></pre></td></tr></table></figure><br>这样，就算我们新增加了模块，每次测试时也会自动补上，而且，我们只需要改变Python种tun_time的值，就可以方便的改变CPU运行时间</p><h3 id="生成可执行CPU文件"><a href="#生成可执行CPU文件" class="headerlink" title="生成可执行CPU文件"></a>生成可执行CPU文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ISE本体路径 + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + CPU路径 + <span class="string">&quot;\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt&quot;</span></span><br><span class="line">举例： ISE本体路径：G:\\ISE\\<span class="number">14.7</span>\\ISE_DS\\ISE</span><br><span class="line">举例： CPU路径：C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\SingleCPU</span><br></pre></td></tr></table></figure>      <p>该命令行的意思是，<strong>利用ISE将CPU生成可执行文件，文件名为mips.exe。</strong>    </p><h3 id="运行可执行CPU文件"><a href="#运行可执行CPU文件" class="headerlink" title="运行可执行CPU文件"></a>运行可执行CPU文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mips.exe -nolog -tclbatch <span class="string">&quot; + CPU路径 + &quot;</span>\\mips.tcl&gt; raw_out.txt</span><br></pre></td></tr></table></figure> <p>该命令行的意思是，<strong>利用生成好的mips.exe结合mips.tcl里的运行时长进行运行，并将结果重定向输出到同目录下的raw_out.txt中</strong> </p><h3 id="结果展示-1"><a href="#结果展示-1" class="headerlink" title="结果展示"></a>结果展示</h3><p>至此，我们获得了一个这样的输出文件：<br><img src="输出文件.png" alt="输出文件"></p><h1 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h1><h2 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h2><p>对比以上两条输出结果，我们发现，ISE的输出会有一些烦人的前缀，导致文件比较失败。所以我们需要对其进行优化，利用Python处理文件将其前缀删去：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>: <span class="comment">#保留每个输出中@及后面的内容，实现输出提纯</span></span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line">mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">    mymem = mymem + myfriendmem[i]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file: <span class="comment">#将提纯后的结果输出到verilog.txt中</span></span><br><span class="line">    file.write(mymem)</span><br></pre></td></tr></table></figure><br>优化后，我们得到了和MARS标准输出一样形式的答案，便可以正常使用文件比较。</p><h2 id="无人值守测试"><a href="#无人值守测试" class="headerlink" title="无人值守测试"></a>无人值守测试</h2><p>在P3中我们实现的只是一个简单的自动化，点击一次运行，执行一次，比较一次，在P4我们做出革新，点击一次运行，输入执行次数，便可以一直执行，每一次的比较结果追加到result.txt中，只有“Accept”和“Wrong answer”，程序运行结束后可在该文件中查看哪次比较为“Wrong answer”,进而去进一步查看详细的比较文件，看看是第几个指令产生了不同。<br>以上的实现通过两个部分完成：</p><h3 id="diff模块获取详细比较文件"><a href="#diff模块获取详细比较文件" class="headerlink" title="diff模块获取详细比较文件"></a>diff模块获取详细比较文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compare_file(<span class="string">r&#x27;verilog.txt&#x27;</span>, <span class="string">r&#x27;mar.txt&#x27;</span>, <span class="string">&#x27;result&#x27;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_file</span>(<span class="params">file1, file2, out_file</span>):</span><br><span class="line">    file1_content = read_file(file1)</span><br><span class="line">    file2_content = read_file(file2)</span><br><span class="line">    d = difflib.HtmlDiff()</span><br><span class="line">    result = d.make_file(file1_content, file2_content)</span><br><span class="line">    fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    fb.write(result)</span><br></pre></td></tr></table></figure> <p><img src="详细比较.png" alt="详细比较">   </p><h3 id="手动编写比较方法，确定粗略比较信息"><a href="#手动编写比较方法，确定粗略比较信息" class="headerlink" title="手动编写比较方法，确定粗略比较信息"></a>手动编写比较方法，确定粗略比较信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">co.write(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mar.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> out_1:</span><br><span class="line">    out_std = out_1.readlines()</span><br><span class="line">    out_std.remove(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> out_2:</span><br><span class="line">    out_test = out_2.readlines()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.\\log.txt&quot;</span>.<span class="built_in">format</span>(test_order), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(out_std) &gt; <span class="built_in">len</span>(out_test):</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out_std)):</span><br><span class="line">            <span class="keyword">if</span> out_std[i] != out_test[i]:</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong Answer!&quot;</span>)</span><br><span class="line">        co.write(<span class="string">&quot;Wrong Answer!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Accepted!&quot;</span>)</span><br><span class="line">        co.write(<span class="string">&quot;Accepted!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">co.close()</span><br></pre></td></tr></table></figure> <p><img src="粗略比较.png" alt="粗略比较">   </p><h3 id="储存每次详细比较文件和ASM文件"><a href="#储存每次详细比较文件和ASM文件" class="headerlink" title="储存每次详细比较文件和ASM文件"></a>储存每次详细比较文件和ASM文件</h3><p>目的是便于出现错误答案时进行查找，复现问题：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dir_name_1 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\比较文件\\&#x27;</span></span><br><span class="line">fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">fb.write(result)</span><br><span class="line">dir_name = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\mars文件\\&#x27;</span></span><br><span class="line">f_2 = <span class="built_in">open</span>(dir_name + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.asm&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">f_2.writelines(list_temp)</span><br></pre></td></tr></table></figure> </p><h2 id="其余细节"><a href="#其余细节" class="headerlink" title="其余细节"></a>其余细节</h2><p><strong>python提供了os模块代替手动执行命令行，示例如下：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path <span class="comment">#自动配置系统变量（因此无需主动配置环境变量）</span></span><br><span class="line">os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + p_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + p_road + <span class="string">&quot;\\mips.tcl&gt; raw_out.txt&quot;</span>)</span><br></pre></td></tr></table></figure> </p><h1 id="数据生成思路"><a href="#数据生成思路" class="headerlink" title="数据生成思路"></a>数据生成思路</h1><p>由于和P3的指令集相同，所以这里无需新的数据生成，利用P3即可。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><font color="red">至此，我们完成了Verilog的测试构建，该Python文件将支持我们P4-P7的测试，之后根据不同的Project在P4的测试上进行小修小补即可，所以，恭喜正式步入自动化测试的大门！</font><p><strong><font color="purple">这是一条很艰辛的道路，后续的数据构造将花费大量时间，但我也保证，这是计组成神之路！</font></strong>   </p><h1 id="Python自动化测试框架代码"><a href="#Python自动化测试框架代码" class="headerlink" title="Python自动化测试框架代码"></a>Python自动化测试框架代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> filestools</span><br><span class="line"><span class="keyword">from</span> filediff.diff <span class="keyword">import</span> file_diff_compare</span><br><span class="line">p_road = <span class="string">&quot;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\SingleCPU&quot;</span></span><br><span class="line">run_time = <span class="string">&quot;50us&quot;</span></span><br><span class="line">xilinx_path = <span class="string">&quot;G:\\ISE\\14.7\\ISE_DS\\ISE&quot;</span></span><br><span class="line">dir_name = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\mars文件\\&#x27;</span></span><br><span class="line">dir_name_1 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\比较文件\\&#x27;</span></span><br><span class="line">dir_name_2 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\&#x27;</span></span><br><span class="line">error = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成指令中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    command = <span class="string">&quot;C语言.exe&quot;</span></span><br><span class="line">    os.system(command)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;test.asm&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.asm&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mar</span>():</span><br><span class="line">    <span class="comment"># print(&quot;生成机器码中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars_perfect.jar mc CompactDataAtZero a dump .text HexText code.txt nc test.asm&quot;</span>)</span><br><span class="line">    <span class="comment"># print(&quot;生成标准答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc test.asm &gt; mar.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ise</span>():</span><br><span class="line">    <span class="comment"># print(&quot;运行ise中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(p_road):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">                file_list.append(file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">            prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + p_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">        tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">    prj.close()</span><br><span class="line">    tcl.close()</span><br><span class="line">    os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path</span><br><span class="line">    os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + p_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + p_road + <span class="string">&quot;\\mips.tcl&gt; raw_out.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>():</span><br><span class="line">    <span class="comment"># print(&quot;转换ise答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">        mymem = mymem + myfriendmem[i]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(mymem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_file</span>(<span class="params">name, target_road</span>):</span><br><span class="line">    f_1 = <span class="built_in">open</span>(name, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(target_road + <span class="string">&quot;\\&quot;</span> + name, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_cmp</span>(<span class="params">test_order</span>):</span><br><span class="line">    co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    co.write(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mar.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> out_1:</span><br><span class="line">        out_std = out_1.readlines()</span><br><span class="line">        out_std.remove(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> out_2:</span><br><span class="line">        out_test = out_2.readlines()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.\\log.txt&quot;</span>.<span class="built_in">format</span>(test_order), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(out_std) &gt; <span class="built_in">len</span>(out_test):</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out_std)):</span><br><span class="line">                <span class="keyword">if</span> out_std[i] != out_test[i]:</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Wrong Answer!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Wrong Answer!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Accepted!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Accepted!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    co.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> f.readlines()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: 没有找到文件:%s或读取文件失败！&quot;</span> % filename)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_file</span>(<span class="params">file1, file2, out_file</span>):</span><br><span class="line">    file1_content = read_file(file1)</span><br><span class="line">    file2_content = read_file(file2)</span><br><span class="line">    d = difflib.HtmlDiff()</span><br><span class="line">    result = d.make_file(file1_content, file2_content)</span><br><span class="line">    fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    fb.write(result)</span><br><span class="line">    <span class="comment"># with open(dir_name + out_file, &#x27;w&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     f.writelines(result)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入测试次数:&quot;</span>)</span><br><span class="line">test_times =<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">co.write(<span class="string">&quot;测试次数:&quot;</span>+<span class="built_in">str</span>(test_times)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">co.close()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">    generate(i+<span class="number">1</span>)</span><br><span class="line">    run_mar()</span><br><span class="line">    run_ise()</span><br><span class="line">    process()</span><br><span class="line">    <span class="comment"># print(&quot;比较答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    compare_file(<span class="string">r&#x27;verilog.txt&#x27;</span>, <span class="string">r&#x27;mar.txt&#x27;</span>, <span class="string">&#x27;result&#x27;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">    file_cmp(i+<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure> <h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P4">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P4</a></p><p><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P4课上强测！</font></strong></p><p><strong><font size = 5>P4数据生成器代码行数：304行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单周期CPU设计文档（Verilog）</title>
      <link href="/posts/33193/"/>
      <url>/posts/33193/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Verilog 单周期CPU设计文档</center></font></strong></p><h1 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h1><h2 id="（一）总体设计综述"><a href="#（一）总体设计综述" class="headerlink" title="（一）总体设计综述"></a>（一）总体设计综述</h2><h3 id="IFU"><a href="#IFU" class="headerlink" title="IFU"></a>IFU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前指令</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">取指令</td><td style="text-align:center">取出当前PC所对应的指令</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">更改PC值</td><td style="text-align:center">利用NPC更改PC值</td></tr></tbody></table></div><h3 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a>GRF</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">A3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其作为RD的写入地址</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位写入数据</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A2指定寄存器的32位数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号，清零32个寄存器中的数据</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">同步复位</td><td style="text-align:center">时钟上升沿到来时，若RESET信号有效，则将32个寄存器中的数据全部清除</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A1与A2所存地址对应的寄存器的数据读出到RD1和RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD写入到A3所存地址对应的寄存器中</td></tr></tbody></table></div><h3 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPCControl</td><td style="text-align:center">I</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Jump</td><td style="text-align:center">I</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Jreg</td><td style="text-align:center">I</td><td style="text-align:center">Jr 信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">J26imm[25:0]</td><td style="text-align:center">I</td><td style="text-align:center">跳转信号的26位立即数</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">B32imm[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">分支信号的扩展后的32位立即数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RegJump[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">Jr跳转地址</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">PC4[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">PC+4的值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">计算下一PC的值</td><td style="text-align:center">根据指令和当前PC值计算下一PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">输出PC4</td><td style="text-align:center">为JR写入寄存器提供数据</td></tr></tbody></table></div><h3 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">经过扩展后的32位立即数</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">I</td><td style="text-align:center">选择扩展类型信号  0：符号扩展 1：无符号扩展</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">符号扩展</td><td style="text-align:center">将16位立即数符号扩展为32位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">无符号扩展</td><td style="text-align:center">将16位立即数无符号扩展为32位立即数</td></tr></tbody></table></div><h3 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">32位数据输出</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位数据输入</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD中的数据写入到A所存地址所对应的位置</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A所存地址对应位置的数据读出到RD</td></tr></tbody></table></div><h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Bigger</td><td style="text-align:center">I</td><td style="text-align:center">ALU两个操作数是否相等信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">O</td><td style="text-align:center">扩展类型信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jump</td><td style="text-align:center">O</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RegWrite</td><td style="text-align:center">O</td><td style="text-align:center">寄存器写使能信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MemWrite</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">MemToReg</td><td style="text-align:center">O</td><td style="text-align:center">Reg写入数据类型信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">RegDest</td><td style="text-align:center">O</td><td style="text-align:center">A3寄存器选择信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ALUop</td><td style="text-align:center">O</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Branch</td><td style="text-align:center">O</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Jreg</td><td style="text-align:center">O</td><td style="text-align:center">Jr信号</td></tr></tbody></table></div><p>(2)真值表</p><div class="table-container"><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">add</th><th style="text-align:center">sub</th><th style="text-align:center">ori</th><th style="text-align:center">lw</th><th style="text-align:center">sw</th><th style="text-align:center">lui</th><th style="text-align:center">beq</th><th style="text-align:center">Jal</th><th style="text-align:center">Jr</th></tr></thead><tbody><tr><td style="text-align:center">OP</td><td style="text-align:center">000000</td><td style="text-align:center">000000</td><td style="text-align:center">001101</td><td style="text-align:center">100011</td><td style="text-align:center">101011</td><td style="text-align:center">001111</td><td style="text-align:center">000100</td><td style="text-align:center">000011</td><td style="text-align:center">000000</td></tr><tr><td style="text-align:center">FC</td><td style="text-align:center">100000</td><td style="text-align:center">100010</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">001000</td></tr><tr><td style="text-align:center">ALUop</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0011</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0100</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">Jump</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">RegWrite</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemWrite</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemToReg</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegDest</td><td style="text-align:center">01</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegSrc</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Branch</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jreg</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ALUControl[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Bigger</td><td style="text-align:center">O</td><td style="text-align:center">两操作数是否相等信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">运算结果</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">判断两个操作数是否相等</td><td style="text-align:center">相等则Bigger输出1否则为0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">加运算</td><td style="text-align:center">res=SrcA+SrcB</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">减运算</td><td style="text-align:center">res=SrcA-SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">与运算</td><td style="text-align:center">res=SrcA$SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">或运算</td><td style="text-align:center">res=SrcB</td><td>SrcB</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">加载高位运算</td><td style="text-align:center">res={SrcB[15:0],16’h0}</td></tr></tbody></table></div><h3 id="MUX"><a href="#MUX" class="headerlink" title="MUX"></a>MUX</h3><h4 id="Mux-4-5"><a href="#Mux-4-5" class="headerlink" title="Mux_4_5"></a>Mux_4_5</h4><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">data0[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">data1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">data2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">data3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">sel[1:0]</td><td style="text-align:center">I</td><td style="text-align:center">选择信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">out[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">输出</td></tr></tbody></table></div><h4 id="Mux-4-32"><a href="#Mux-4-32" class="headerlink" title="Mux_4_32"></a>Mux_4_32</h4><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">data0[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">data1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">data2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">data3[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">sel[1:0]</td><td style="text-align:center">I</td><td style="text-align:center">选择信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">out[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">输出</td></tr></tbody></table></div><h4 id="Mux-2-32"><a href="#Mux-2-32" class="headerlink" title="Mux_2_32"></a>Mux_2_32</h4><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">data0[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">data1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据1</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">sel</td><td style="text-align:center">I</td><td style="text-align:center">选择信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">out[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">输出</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">选择数据</td><td style="text-align:center">根据选择信号进行选择数据并输出</td></tr></tbody></table></div><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><p>(1)测试代码  </p><pre><code>ori $a0,$0,1999  ori $a1,$a0,111 lui $a2,12345lui $a3,0xffffnopori $a3,$a3,0xffffadd $s0,$a0,$a1 add $s1,$a3,$a3add $s2,$a3,$s0beq $s2,$s3,eeesub $s0,$a0,$s2 sub $s1,$a3,$a3eee:sub $s2,$a3,$a0sub $s3,$s2,$s1ori $t0,$0,0x0000sw $a0,0($t0)nopsw $a1,4($t0)sw $s0,8($t0)sw $s1,12($t0)sw $s2,16($t0)sw $s5,20($t0)lw $t1,20($t0)lw $t7,0($t0)lw $t6,20($t0)sw $t6,24($t0)lw $t5,12($t0)jal endori $t0,$t0,1ori $t1,$t1,1ori $t2,$t2,2beq $t0,$t2,eeelui $t3,1111jal outend:add $t0,$t0,$t7jr $raout:add $t0,$t0,$t3ori $t2,$t0,0beq $t0,$t2,qqqlui $v0,10qqq:lui $v0,11</code></pre><p>（2)MARS中运行结果<br><img src="MAR运行结果1.png" alt="MAR运行结果1"><br><img src="MARS运行结果2.png" alt="MAR运行结果2"><br>(3)该CPU运行输出结果</p><pre><code>@00003000: $ 4 &lt;= 000007cf@00003004: $ 5 &lt;= 000007ef@00003008: $ 6 &lt;= 30390000@0000300c: $ 7 &lt;= ffff0000@00003014: $ 7 &lt;= ffffffff@00003018: $16 &lt;= 00000fbe@0000301c: $17 &lt;= fffffffe@00003020: $18 &lt;= 00000fbd@00003028: $16 &lt;= fffff812@0000302c: $17 &lt;= 00000000@00003030: $18 &lt;= fffff830@00003034: $19 &lt;= fffff830@00003038: $ 8 &lt;= 00000000@0000303c: *00000000 &lt;= 000007cf@00003044: *00000004 &lt;= 000007ef@00003048: *00000008 &lt;= fffff812@0000304c: *0000000c &lt;= 00000000@00003050: *00000010 &lt;= fffff830@00003054: *00000014 &lt;= 00000000@00003058: $ 9 &lt;= 00000000@0000305c: $15 &lt;= 000007cf@00003060: $14 &lt;= 00000000@00003064: *00000018 &lt;= 00000000@00003068: $13 &lt;= 00000000@0000306c: $31 &lt;= 00003070@00003088: $ 8 &lt;= 000007cf@00003070: $ 8 &lt;= 000007cf@00003074: $ 9 &lt;= 00000001@00003078: $10 &lt;= 00000002@00003080: $11 &lt;= 04570000@00003084: $31 &lt;= 00003088@00003090: $ 8 &lt;= 045707cf@00003094: $10 &lt;= 045707cf@000030a0: $ 2 &lt;= 000b0000</code></pre><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="（1）阅读下面给出的-DM-的输入示例中（示例-DM-容量为-4KB，即-32bit-×-1024字），根据你的理解回答，这个-addr-信号又是从哪里来的？地址信号-addr-位数为什么是-11-2-而不是-9-0-？"><a href="#（1）阅读下面给出的-DM-的输入示例中（示例-DM-容量为-4KB，即-32bit-×-1024字），根据你的理解回答，这个-addr-信号又是从哪里来的？地址信号-addr-位数为什么是-11-2-而不是-9-0-？" class="headerlink" title="（1）阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？"></a>（1）阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？</h3><p><img src="66.png" alt="66"><br>答：addr是从ALU的输出信号中经过位的截取而得到的，代表的是将要读取的DM的储存器的位置。<br>因为MIPS以字为单位，存储的时候也是以字为单位存储的（32位reg）,左移两位相当于除4，除4才可以得到我们需要的字，即我们需要的数据。  </p><h3 id="（2）思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。"><a href="#（2）思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。" class="headerlink" title="（2）思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。"></a>（2）思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</h3><p>答：<br><img src="控制信号对应指令.png" alt="1"><br><img src="指令对应控制信号.png" alt="2"><br>控制信号对应指令：哪种信号需要为哪些指令提供什么样的值一目了然<br>指令对于控制信号：哪种指令需要什么指令取什么值一目了然<br>这是两种看待控制信号和指令之间关系的角度。<br>前者代码较为简洁，后者代码则较为繁多。<br>前者不能很好的体现一条条指令的独立性，后者则可以很好体现一条条指令的独立性。  </p><h3 id="（3）在相应的部件中，复位信号的设计都是同步复位，这与-P3-中的设计要求不同。请对比同步复位与异步复位这两种方式的-reset-信号与-clk-信号优先级的关系。"><a href="#（3）在相应的部件中，复位信号的设计都是同步复位，这与-P3-中的设计要求不同。请对比同步复位与异步复位这两种方式的-reset-信号与-clk-信号优先级的关系。" class="headerlink" title="（3）在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。"></a>（3）在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。</h3><p>答：我们可以通过Verilog中实现它们的方式进行对比：<br><img src="复位.png" alt="123"><br>前者为异步复位，后者为同步复位。  </p><ul><li>可以看出来异步复位中clk和reset都为敏感信号，两者中任意一者发生变化都会导致always块的运行，clk和reset无相关关系，所以优先级相同。  </li><li>同步复位中只有clk为敏感信号，只有满足clk上升沿时，always块才会运行，这时才会考虑reset的值是否有效，所以clk和reset存在类似于主从关系的关系，优先级clk&gt;reset。</li></ul><h3 id="（4）C-语言是一种弱类型程序设计语言。C-语言中不对计算结果溢出进行处理，这意味着-C-语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持-C-语言，MIPS-指令的所有计算指令均可以忽略溢出。-请说明为什么在忽略溢出的前提下，addi-与-addiu-是等价的，add-与-addu-是等价的。提示：阅读《MIPS32®-Architecture-For-Programmers-Volume-II-The-MIPS32®-Instruction-Set》中相关指令的-Operation-部分。"><a href="#（4）C-语言是一种弱类型程序设计语言。C-语言中不对计算结果溢出进行处理，这意味着-C-语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持-C-语言，MIPS-指令的所有计算指令均可以忽略溢出。-请说明为什么在忽略溢出的前提下，addi-与-addiu-是等价的，add-与-addu-是等价的。提示：阅读《MIPS32®-Architecture-For-Programmers-Volume-II-The-MIPS32®-Instruction-Set》中相关指令的-Operation-部分。" class="headerlink" title="（4）C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。"></a>（4）C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。</h3><p>答：addi与addiu行为区别上的差异在于：出现溢出时，addiu忽略溢出，将溢出位<strong>舍弃</strong>，addi则会<strong>抛出错误</strong>SignalException(IntegerOverflow)，其余表现形式与addiu<strong>相同</strong>，故忽略溢出，则错误不抛出，此时两者便等价了。<br><strong><em>add与addu上述相同。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单周期CPU全自动测试思路（Logisim）</title>
      <link href="/posts/6588/"/>
      <url>/posts/6588/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P3的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>通过阅读本文，你可以了解到如何<del>蒟蒻</del>合理生成不会陷入死循环不会报错的指令，并了解到对logisim进行自动化测试的相关方法。</p><h1 id="全自动测试的开端：设施准备"><a href="#全自动测试的开端：设施准备" class="headerlink" title="全自动测试的开端：设施准备"></a>全自动测试的开端：设施准备</h1><p>要完成logisim的自动测试，需要使用到Logisim的命令行操作对输出进行重定向，所以我们需要.jar版的logisim来实现，该文件上网找找就有，我也已经上传至<a href="https://pan.baidu.com/s/1-ZFbWIHCk7tVUt5MWq8gWA?pwd=ozsw">百度网盘</a>，提取码：ozsw，需要的uu可以自取。</p><h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><p>logisim的命令行官方文档是有介绍的，感兴趣的可以去看看：<br><img src="https://s1.ax1x.com/2022/12/29/pSp8rin.png" alt="Logisim官方介绍"><br>这里我直接贴出有用的命令行，并对其做出解释，方便速通。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar logisim-generic-<span class="number">2</span>.<span class="number">7</span>.<span class="number">1</span>.jar CPU名称.circ -tty table &gt; 输出.txt</span><br></pre></td></tr></table></figure><br>这句话的意思是运行该.circ文件并将<strong>顶层模块的输出</strong>全部进行<strong>输出</strong>，注意是<strong>顶层模块</strong>，<strong>子模块</strong>不会输出任何结果！<br>意味着若你想得到你需要的数据，你就需要在主模块将其作为输出进行输出。<br>对于一个xxxx.asm程序，我们需要通过命令行运行mars使其输出机器码文件：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars4_5.jar xxxx.asm nc mc CompactTextAtZero a dump .text HexText 机器码.txt</span><br></pre></td></tr></table></figure> </p><h1 id="对于cpu的额外设置"><a href="#对于cpu的额外设置" class="headerlink" title="对于cpu的额外设置"></a>对于cpu的额外设置</h1><p>有了上述指令，程序就可以运行了，并且我们可以在程序的同一目录下得到输出文件，但此时会出现新的问题，该cpu会一直运转，不会停止，这时候就需要对其提供halt指令（源自官方文档），当halt信号为1时，结束程序，可以如下实现：<br>为在顶层模块采用计数器设置计数最大值（你需要运行的周期），设置计数器为达到最大值保持，这时候进位输出端便会输出1，将其作为halt信号即可结束程序<br><img src="https://s1.ax1x.com/2022/12/29/pSp8yR0.png" alt="P3图片1"></p><font color="purple">官方介绍：</font><p><img src="https://s1.ax1x.com/2022/12/29/pSp82sU.png" alt="P3图片2"><br>好像这就是评测机的评测机制的一部分（思考）</p><font color="red">不用担心这里的halt信号也会作为输出不断输出，logisim会忽略halt信号的输出。</font><h1 id="机器码读入ROM"><a href="#机器码读入ROM" class="headerlink" title="机器码读入ROM"></a>机器码读入ROM</h1><p>Logisim官方文档也提供了读入的方法，但其实不是很直观，观察.circ文件中rom的表示方式，我们可以使用正则表达式对其匹配并强制替换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr/data: <span class="number">10</span> <span class="number">32</span>([\s\S]*?)&lt;/a&gt;  <span class="comment">#正则表达式</span></span><br></pre></td></tr></table></figure><br>注意<font color="green">非贪婪匹配</font>，贪婪匹配会导致该正则表达式匹配到多余的内容，替换后使得文件损坏。<br><img src="https://s1.ax1x.com/2022/12/29/pSp8IiR.png" alt="P3图片3"></p><center>替换前</center>     <p><img src="https://s1.ax1x.com/2022/12/29/pSp8gMT.png" alt="P3图片4"></p><center>替换后</center><h1 id="python实现思路"><a href="#python实现思路" class="headerlink" title="python实现思路"></a>python实现思路</h1><p><strong>python提供了os模块代替手动执行命令行，示例如下：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&quot;java -jar Mars4_5.jar test.asm nc mc CompactTextAtZero a dump .text HexText command.txt&quot;</span>)</span><br></pre></td></tr></table></figure><br><strong>python提供了re模块用于正则表达式匹配替换，示例如下：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymem = re.sub(<span class="string">r&#x27;addr/data: 10 32([\s\S]*?)&lt;/a&gt;&#x27;</span>, <span class="string">&quot;addr/data: 10 32\n&quot;</span> + content + <span class="string">&quot;&lt;/a&gt;&quot;</span>, mymem)</span><br></pre></td></tr></table></figure><br>执行完毕后得到的结果文件可以与同学对拍。<br><strong>而python也提供了filediff.diff模块用于文本差异比对，生成html文件，若有区别，则会标红，这里是由于文本一致所以无色。</strong><br><img src="https://s1.ax1x.com/2022/12/29/pSp84o9.png" alt="P3图片7"><br>（左右各为两个CPU输出结果） 有了这些我们就可以写出.py程序直接得到最终的比较结果 </p><h1 id="自动化数据生成思路"><a href="#自动化数据生成思路" class="headerlink" title="自动化数据生成思路"></a>自动化数据生成思路</h1><p><font color="purple">测试讲完了，但测试数据怎么来？这就需要我们自动化生成测试数据。 </font><br>可以选择c,c++,java,python生成，因为它们都支持命令行的重定向操作，最终用python指挥它们干活即可。     </p><h2 id="具体思路："><a href="#具体思路：" class="headerlink" title="具体思路："></a>具体思路：</h2><p>•开局先使用ori或lui给31个寄存器用随机数乱赋初值，确保后面的指令运行时不会拿0加来加去，导致没有测试意义。<br>•构造一个字符串数组，存指令名称，用随机数生成的数字确定本次随机的指令，然后分别实现各个指令的生成，对于寄存器和立即数选择随机生成。<br>•对于一般指令这样做完全够用，但beq和jal和jr则需要仔细考虑，不然会导致程序死循环或寻址到不合适的地方而报错。</p><p><font color="green">在此提供我的一些思路：</font><br>•以段生成代码，将jal固定出现在入口末尾，jr固定出现在出口末尾，确保jal和jr的跳转不会导致死循环<br>•对于beq的生成，其实有一个最简单粗暴的方式是beq往后跳转，这样不满足条件，指令也会往下执行，满足，也会往下执行，不会出现问题。当然如果一定要实现往前跳转，可以固定一段代码段，将其作为计数模块，当其执行超过一定次数时直接跳出此段代码。         </p><p><img src="https://s1.ax1x.com/2022/12/29/pSp8RLF.png" alt="P3图片8"><br><img src="https://s1.ax1x.com/2022/12/29/pSp8hdJ.png" alt="P3图片9"><br><img src="https://s1.ax1x.com/2022/12/29/pSp8fZ4.png" alt="P3图片10"><br>这部分做好后同样利用Python即可将其与上述测试程序链接自动生成代码自己对拍出结果，实现<strong>自动化测试</strong>。</p><h1 id="Python代码放送"><a href="#Python代码放送" class="headerlink" title="Python代码放送"></a>Python代码放送</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import difflib</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line">import filestools</span><br><span class="line">from filediff.diff import file_diff_compare</span><br><span class="line"># <span class="number">0</span>.自动化生成数据</span><br><span class="line"><span class="built_in">print</span>(&quot;生成指令中&quot;+&#x27;\n&#x27;)</span><br><span class="line">command = &quot;C语言.exe&quot;</span><br><span class="line">os.system(command)</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>.先运行Mars生成机器码</span><br><span class="line"><span class="built_in">print</span>(&quot;生成机器码中&quot;+&#x27;\n&#x27;)</span><br><span class="line">os.system(&quot;java -jar Mars4_5.jar test.asm nc mc CompactTextAtZero a dump .text HexText command.txt&quot;)</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>.运行写好的circ文件将里面的ROM值更改为上述输出的机器码</span><br><span class="line"><span class="built_in">print</span>(&quot;添加指令至单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">content = open(&quot;command.txt&quot;).read()</span><br><span class="line">mymem = open(&quot;单周期cpu.circ&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;).read()</span><br><span class="line">mymem = re.sub(r&#x27;addr/data: <span class="number">10</span> <span class="number">32</span>([\s\S]*?)&lt;/a&gt;&#x27;, &quot;addr/data: <span class="number">10</span> <span class="number">32</span>\n&quot; + content + &quot;&lt;/a&gt;&quot;, mymem)</span><br><span class="line">with open(&quot;单周期cpu镜像.circ&quot;, &quot;w&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;) as file:</span><br><span class="line">    file.write(mymem)</span><br><span class="line"><span class="built_in">print</span>(&quot;添加指令至另一个单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">myfriendmem = open(&quot;另一个单周期cpu.circ&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;).read()</span><br><span class="line">myfriendmem = re.sub(r&#x27;addr/data: <span class="number">10</span> <span class="number">32</span>([\s\S]*?)&lt;/a&gt;&#x27;, &quot;addr/data: <span class="number">10</span> <span class="number">32</span>\n&quot; + content + &quot;&lt;/a&gt;&quot;, myfriendmem)</span><br><span class="line">with open(&quot;另一个单周期cpu镜像.circ&quot;, &quot;w&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;) as file:</span><br><span class="line">    file.write(myfriendmem)</span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>.运行logisim输出结果</span><br><span class="line"><span class="built_in">print</span>(&quot;运行单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">command = &quot;java -jar logisim-generic-<span class="number">2</span>.<span class="number">7</span>.<span class="number">1</span>.jar 单周期cpu镜像.circ -tty table &gt; 单周期cpu结果.txt&quot;</span><br><span class="line">os.system(command)</span><br><span class="line"><span class="built_in">print</span>(&quot;运行另一个单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">command = &quot;java -jar logisim-generic-<span class="number">2</span>.<span class="number">7</span>.<span class="number">1</span>.jar 另一个单周期cpu镜像.circ -tty table &gt; 另一个单周期cpu结果.txt&quot;</span><br><span class="line">os.system(command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>.找人对拍</span><br><span class="line"><span class="built_in">print</span>(&quot;正在比较结果，时间可能较长，请耐心等待&quot;+&#x27;\n&#x27;)</span><br><span class="line">def read_file(filename):</span><br><span class="line"><span class="function">    try:</span></span><br><span class="line"><span class="function">        <span class="title">with</span> <span class="title">open</span>(<span class="title">filename</span>, &#x27;<span class="title">r</span>&#x27;) <span class="title">as</span> <span class="title">f</span>:</span></span><br><span class="line"><span class="function">            <span class="title">return</span> <span class="title">f.readlines</span>()</span></span><br><span class="line"><span class="function">    <span class="title">except</span> <span class="title">IOError</span>:</span></span><br><span class="line"><span class="function">        <span class="title">print</span>(&quot;<span class="title">ERROR</span>: 没有找到文件:%<span class="title">s</span>或读取文件失败！&quot; % <span class="title">filename</span>)</span></span><br><span class="line"><span class="function">        <span class="title">sys.exit</span>(1)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">compare_file</span>(<span class="title">file1</span>, <span class="title">file2</span>, <span class="title">out_file</span>):</span></span><br><span class="line"><span class="function">    <span class="title">file1_content</span> = <span class="title">read_file</span>(<span class="title">file1</span>)</span></span><br><span class="line"><span class="function">    <span class="title">file2_content</span> = <span class="title">read_file</span>(<span class="title">file2</span>)</span></span><br><span class="line"><span class="function">    <span class="title">d</span> = <span class="title">difflib.HtmlDiff</span>()</span></span><br><span class="line"><span class="function">    <span class="title">result</span> = <span class="title">d.make_file</span>(<span class="title">file1_content</span>, <span class="title">file2_content</span>)</span></span><br><span class="line"><span class="function">    <span class="title">with</span> <span class="title">open</span>(<span class="title">out_file</span>, &#x27;<span class="title">w</span>&#x27;) <span class="title">as</span> <span class="title">f</span>:</span></span><br><span class="line"><span class="function">        <span class="title">f.writelines</span>(<span class="title">result</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">compare_file</span>(<span class="title">r</span>&#x27;单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&#x27;, <span class="title">r</span>&#x27;另一个单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&#x27;, <span class="title">r</span>&#x27;<span class="title">result.html</span>&#x27;)</span></span><br><span class="line"><span class="function"><span class="title">file_diff_compare</span>(&quot;单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&quot;,&quot;另一个单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&quot;)</span></span><br><span class="line"><span class="function"><span class="title">print</span>(&quot;比较结束，测试完毕，请查看结果&quot;+&#x27;\<span class="title">n</span>&#x27;)</span></span><br><span class="line"><span class="function">#5.到文件中查看结果</span></span><br></pre></td></tr></table></figure>  <h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/blob/main/P3">https://github.com/ForeverYolo/2022-BUAA-CO/blob/main/P3</a>  </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这篇文章是写于作者学习P3之时，回过头来还是觉得当时的自己略显稚嫩，所以笔者在这里起一个抛砖引玉的作用，希望对大家测试logisim有所启发！</p><p><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P3课上强测！</font></strong></p><p><strong><font size = 5>P3数据生成器代码行数：304行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单周期CPU设计文档（Logisim）</title>
      <link href="/posts/4286/"/>
      <url>/posts/4286/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Logisim 单周期CPU设计文档</center></font></strong></p><h1 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h1><p>（一）总体设计概述</p><p>使用Logisim设计开发一个初步的单周期CPU，总体概述如下：</p><ol><li>此CPU为32位CPU</li><li>此CPU为单周期</li><li>此CPU支持的指令集为：{add, sub, addu, subu, ori, lw, sw, beq, lui, nop, j}</li><li>nop的机器码为0x00000000</li><li>addu,subu不支持溢出</li></ol><p>（二）关键模块定义</p><p><strong>1．IFU</strong></p><p>(1) 端口说明</p><p>表 1-IFU端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLK</td><td>I</td><td>时钟信号</td></tr><tr><td>2</td><td>RESET</td><td>I</td><td>异步复位信号，将PC值置为0x00000000 0：无效 1：复位</td></tr><tr><td>3</td><td>PCN[31:0]</td><td>I</td><td>PC的下一个值</td></tr><tr><td>4</td><td>Instr[31:0]</td><td>O</td><td>输出IM中将要执行的指令</td></tr><tr><td>5</td><td>PC[31:0]</td><td>O</td><td>输出当前PC值</td></tr></tbody></table></div><p>(2) 功能定义</p><p>表 2-IFU功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>当RESET有效时，将PC值置为0x00000000</td></tr><tr><td>2</td><td>更新PC值</td><td>PC\&lt;=NPC</td></tr><tr><td>3</td><td>输出指令</td><td>根据PC的值，取出IM中的指令</td></tr></tbody></table></div><p><strong>2．GRF</strong></p><p>(1) 端口说明</p><p>表 3-GRF端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLK</td><td>I</td><td>时钟信号</td></tr><tr><td>2</td><td>WE</td><td>I</td><td>写使能信号 0：不能向GRF写入数据 1：可向GRF写入数据</td></tr><tr><td>3</td><td>RESET</td><td>I</td><td>异步复位信号 1：将所有寄存器清零 0：无效</td></tr><tr><td>4</td><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>5</td><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>6</td><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将WD的数据读入到该寄存器</td></tr><tr><td>7</td><td>WD[31:0]</td><td>I</td><td>32位写入到A3所指向寄存器的数据</td></tr><tr><td>8</td><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器的32位数据</td></tr><tr><td>9</td><td>RD1[31:0]</td><td>O</td><td>输出A2指定的寄存器的32位数据</td></tr></tbody></table></div><p>（2）功能定义</p><p>表 4-GRF功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>异步复位</td><td>当RESET的值有效时，将所有寄存器异步清零</td></tr><tr><td>2</td><td>写入数据</td><td>当WE为1且时钟上升沿来临时，将WD写入到A3对应的寄存器</td></tr><tr><td>3</td><td>读出数据</td><td>将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出</td></tr></tbody></table></div><p><strong>3.DM</strong></p><p>（1）端口说明</p><p>表 5-DM端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLK</td><td>I</td><td>时钟信号</td></tr><tr><td>2</td><td>WE</td><td>I</td><td>写使能信号 0：不能向DM写入数据 1：可向DM写入数据</td></tr><tr><td>3</td><td>RESET</td><td>I</td><td>异步复位信号 0：无效 1：将DM清零</td></tr><tr><td>4</td><td>A[4:0]</td><td>I</td><td>5位读取或写入地址信号</td></tr><tr><td>5</td><td>WD[31:0]</td><td>I</td><td>32位写入数据</td></tr><tr><td>6</td><td>RD[31:0]</td><td>O</td><td>32位读出数据</td></tr></tbody></table></div><p>（2）功能定义</p><p>表 6-DM功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>异步复位</td><td>当RESET的值有效时，将DM清零</td></tr><tr><td>2</td><td>写入数据</td><td>当WE为1且时钟上升沿来临时，将WD写入A对应的地址中</td></tr><tr><td>3</td><td>读出数据</td><td>RD时刻读出A对应地址的值</td></tr></tbody></table></div><p><strong>4.ALU</strong></p><p>（1）端口说明</p><p>表 7-ALU端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>SrcA[31:0]</td><td>I</td><td>操作数1</td></tr><tr><td>2</td><td>SrcB[31:0]</td><td>I</td><td>操作数2</td></tr><tr><td>3</td><td>ALUControl[2:0]</td><td>I</td><td>决定ALU操作： 000：无符号加 001：无符号减 010：与 011：或 100：将SrcB左移10位</td></tr><tr><td>4</td><td>Bigger</td><td>O</td><td>SrcA与ScrB是否相等 0：不相等 1：相等</td></tr><tr><td>5</td><td>Res[31:0]</td><td>O</td><td>输出结果</td></tr></tbody></table></div><p>（2）功能定义</p><p>表 8-ALU功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>无符号加</td><td>Res=SrcA+SrcB</td></tr><tr><td>2</td><td>无符号减</td><td>Res=SrcA-SrcB</td></tr><tr><td>3</td><td>与</td><td>Res=SrcA&amp;SrcB</td></tr><tr><td>4</td><td>或</td><td>Res=SrcA\</td><td>SrcB</td></tr><tr><td>5</td><td>将SrcB左移10位</td><td>Res=SrcB\&lt;\&lt;10</td></tr></tbody></table></div><p><strong>5.NPC</strong></p><p>（1）端口说明</p><p>表 9-NPC端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>PC[31:0]</td><td>I</td><td>当前PC值</td></tr><tr><td>2</td><td>Jump</td><td>I</td><td>Jump选择信号 0：无效 1：指令是J</td></tr><tr><td>3</td><td>SignImm[31:0]</td><td>I</td><td>扩展后的32位信号</td></tr><tr><td>4</td><td>EPC[27:0]</td><td>I</td><td>扩展后的28位信号</td></tr><tr><td>5l</td><td>NPCControl</td><td>I</td><td>NPCControl选择信号 0：无效 1：指令是beq</td></tr><tr><td>6</td><td>PCN[31:0]</td><td>O</td><td>下一PC值</td></tr></tbody></table></div><p>（2）功能定义</p><p>表 10-NPC功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>选择是否为J指令</td><td>0：无效 1：是J指令</td></tr><tr><td>2</td><td>选择是否为Beq指令</td><td>0：无效 1：为Beq指令</td></tr><tr><td>3</td><td>输出下一PC值</td><td>PCN为下一PC值</td></tr></tbody></table></div><p><strong>6.Control</strong></p><p>(1) 端口说明</p><p>表 11-Control端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Op[5:0]</td><td>I</td><td>Instr[31:26] 6位控制信号</td></tr><tr><td>2</td><td>FC[5:0]</td><td>I</td><td>Instr[0:5] 6位控制信号</td></tr><tr><td>3</td><td>ALUop[2:0]</td><td>O</td><td>ALU的控制信号</td></tr><tr><td>4</td><td>Jump</td><td>O</td><td>是否为J指令 0：不是 1：是</td></tr><tr><td>5</td><td>RegWrite</td><td>O</td><td>GRF的写入信号 0：禁止写入 1：允许写入</td></tr><tr><td>6</td><td>MemWrite</td><td>O</td><td>DM的写入信号 0：禁止写入 1：允许写入</td></tr><tr><td>7</td><td>MemToReg</td><td>O</td><td>选择写入REG的数据 0：ALU 1：DM</td></tr><tr><td>8</td><td>RegDest</td><td>O</td><td>选择A3的地址 0：Instr[20:16] 1：Instr[15:11]</td></tr><tr><td>9</td><td>RegSrc</td><td>O</td><td>选择SrcB数据来源 0：GRF 1：立即数</td></tr><tr><td>10</td><td>Branch</td><td>O</td><td>是否为Beq指令 0：不是 1：是</td></tr></tbody></table></div><p>（2）真值表</p><p>表 12-Control真值表</p><div class="table-container"><table><thead><tr><th>端口</th><th>addu</th><th>subu</th><th>ori</th><th>lw</th><th>sw</th><th>lui</th><th>beq</th><th>J</th></tr></thead><tbody><tr><td>Op</td><td>000000</td><td>000000</td><td>001101</td><td>100011</td><td>101011</td><td>001111</td><td>000100</td><td>000010</td></tr><tr><td>FC</td><td>100001</td><td>100011</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALUop</td><td>000</td><td>001</td><td>011</td><td>000</td><td>000</td><td>100</td><td>000</td><td>000</td></tr><tr><td>Jump</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>RegWrite</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>MemWrite</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>MemToReg</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>RegDest</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>RegSrc</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Branch</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table></div><p>表 12-Control真值表（续）</p><div class="table-container"><table><thead><tr><th>端口</th><th>add</th><th>sub</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Op</td><td>000000</td><td>000000</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>FC</td><td>100000</td><td>100010</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALUop</td><td>000</td><td>001</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Jump</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegWrite</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MemWrite</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MemToReg</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegDest</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegSrc</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Branch</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><p>（1）测试代码</p><pre><code>ori $t1 , $t2 , 100addu(add) $t2 , $t1 , $t1subu(sub) $t3 , $t2 , $t1sw $t3 , 0($0)lw $t4 , 0($0)nopLabel:beq $t3 , $t2 , Label_Endaddu $t3 , $t3 , $t1j LabelLabel_End:</code></pre><p>（2）MARS中运行结果<br><img src="微信截图_20221017235123.png" alt=""><br><img src="微信截图_20221017235116.png" alt=""><br>（3）该CPU运行结果<br><img src="微信截图_20221018000817.png" alt=""><br><img src="微信截图_20221018000748.png" alt=""><br><img src="微信截图_20221018000803.png" alt=""></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="（一）上面我们介绍了通过-FSM-理解单周期-CPU-的基本方法。请大家指出单周期-CPU-所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。"><a href="#（一）上面我们介绍了通过-FSM-理解单周期-CPU-的基本方法。请大家指出单周期-CPU-所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。" class="headerlink" title="（一）上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。"></a>（一）上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</h3><p>答：状态存储：DM,GRF</p><p>状态转移：IFU,NPC,EXT,ALU,Control</p><h3 id="（二）现在我们的模块中IM使用ROM，-DM使用RAM，-GRF使用Register，这种做法合理吗？-请给出分析，若有改进意见也请一并给出。"><a href="#（二）现在我们的模块中IM使用ROM，-DM使用RAM，-GRF使用Register，这种做法合理吗？-请给出分析，若有改进意见也请一并给出。" class="headerlink" title="（二）现在我们的模块中IM使用ROM， DM使用RAM， GRF使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。"></a>（二）现在我们的模块中IM使用ROM， DM使用RAM， GRF使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</h3><p>答：合理</p><p>IM是指令单元，指令在程序执行过程中不会再更改，也不应该被更改，也就是应只读，ROM就是只具有读取功能的存储器，满足要求</p><p>DM是存储单元，在程序的执行过程中需要不断地向DM中存入，读出数据，所以具有读入与读出的RAM满足要求</p><p>之所以DM不选择寄存器的原因是寄存器相比RAM是昂贵的，且DM需要存储大量数据，采用寄存器会导致成本成倍增长，得不偿失。</p><p>GRF为寄存器堆，自然选择32个寄存器去实现32个寄存器，符合要求与逻辑</p><p>没有改进意见</p><h3 id="（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。"><a href="#（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。" class="headerlink" title="（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。"></a>（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</h3><p>答：是，设计了NPC模块，介绍：NPC模块是用于计算PC的下一值的集成式计算中心，它包容了Beq j等跳转指令的计算，使得对于PC下一值的处理整体而思路清晰。设计思路：首先NPC作为计算PC下一值的模块最基本的功能就是PC\&lt;=PC+4，这个是首要实现的功能，接着就是想办法实现BEQ,J等跳转指令的功能，结合BEQ和J等指令的机器码，将其有用的部分输入进NPC当中进行计算就可得到当前指令若为BEQ和J，它们的值分别为多少，但这里就涉及到了选择的问题，NPC如何知道提供给PC的下一值是PC+4,还是BEQ的跳转，还是J的跳转？因而就需引入多路选择器，并辅以控制选择信号（Conrtol部分生成）来选择PC的下一值，由于有3个选择，我这里采用了2个多路选择器，先二选一，再加入另一个再二选一，具体如图：<br><img src="1234.png" alt=""></p><h3 id="（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由"><a href="#（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由" class="headerlink" title="（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由"></a>（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由</h3><p>答：nop为空指令，不会进行任何操作，仅仅占用一个指令而使得PC\&lt;=PC+4，所以不管加不加都不会影响它的效果</p><h3 id="（五）上文提到，MARS-不能导出-PC-与-DM-起始地址均为-0-的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。"><a href="#（五）上文提到，MARS-不能导出-PC-与-DM-起始地址均为-0-的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。" class="headerlink" title="（五）上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。"></a>（五）上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。</h3><p>答：其实经过研究发现，在我目前所添加的指令中，PC所影响的指令就是J指令，因为J指令是直接跳转到地址，BEQ算的是偏移量，但为了修改方便，我还是针对PC进行了修改，而不是对J指令那一路进行修改，起始时首先PC应该复位为0x3000而且保证该周期正常取指，所以选择了多路选择器，在第一周期屏蔽PC的影响，直接取0位置处的地址（利用PC起始为0与0相等），在第二周期PC被成功赋值后再由PC决定取指，之后就简单了，每次PC的值作用于ROM时都先减去0x3000即可。实现如图：</p><p><img src="123.png" alt=""></p><h3 id="（六）阅读-Pre-的-“MIPS-指令集及汇编语言”-一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。"><a href="#（六）阅读-Pre-的-“MIPS-指令集及汇编语言”-一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。" class="headerlink" title="（六）阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。"></a>（六）阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</h3><p>答：测试样例反汇编为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lui $t0, 0x1</span><br><span class="line">ori $t0, $t0, 0x2f6a</span><br><span class="line">ori $a0, $0, 0x4</span><br><span class="line">ori $a1, $0, 0x1</span><br><span class="line">ori $a2, $0, 0x4</span><br><span class="line">ori $a3, $0, 0x20</span><br><span class="line">sw $a3, 0x0($0)</span><br><span class="line">lw $t2, 0x0($0)</span><br><span class="line">sw $t0, 0x0($a0)</span><br><span class="line">subu $t1, $t0, $t2</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">beq $a3, $a1, label_1</span><br></pre></td></tr></table></figure><br>首先肯定的是所有的要求实现的指令至少都出现了一次进行了测试（虽然要实现的是add和sub这里是addu和subu，但是由设计要求可知在这里add和addu等价，subu和sub等价），且除了Beq以外都测试了多次，提升了检测出Bug的概率，强度还是有的，但放到Logisim跑了一遍和观察汇编指令发现，全程并无负数出现，也就是只测试了正数，且正数不大，数据覆盖范围比较窄，同时发现检测的寄存器是固定的几个，寄存器检测范围比较窄，对于beq则没有检测原地跳，向后跳，只是检测了向前跳。跳转范围检测比较窄。</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机实验秒杀——模板化做题</title>
      <link href="/posts/14039/"/>
      <url>/posts/14039/</url>
      
        <content type="html"><![CDATA[<p><strong><font size=5>这是一篇适用于P0,P1状态机的做题思路分享</font></strong>     </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>在度过Pre通过的快乐或是不通过的悲伤之后，很快我们会迎来真正的考验，从P0开始一直到P1，我们将要面对的一个主要问题就是状态机，而状态机一般在P0中占据两题的位置，P1中占据三题的位置，所以我们可以说，状态机这一关过不去，<font color="red">我们的实验将止步于P0。</font><br>但是，在笔者看来，状态机反而是最为简单，最为模板化的一类题，一旦掌握，则成竹在胸，很难出现意外。今天我们就来聊一聊状态机的是是非非。<br>虽然笔者也极力反对这种刻板化做题的行为，但不得不说，对于状态机而言，<font color="green">一直用一直爽！</font>      </p><h1 id="状态机基础知识"><a href="#状态机基础知识" class="headerlink" title="状态机基础知识"></a>状态机基础知识</h1><h2 id="Moore型状态机"><a href="#Moore型状态机" class="headerlink" title="Moore型状态机"></a>Moore型状态机</h2><p>关键点：输出信号<font color="red">仅</font>与当前状态相关<br><img src="https://s1.ax1x.com/2022/12/29/pSp1QyD.png" alt="Moore型状态机"></p><h2 id="Mealy型状态机"><a href="#Mealy型状态机" class="headerlink" title="Mealy型状态机"></a>Mealy型状态机</h2><p>关键点：输出信号与当前状态<font color="red">及</font>输入信号有关<br><img src="https://s1.ax1x.com/2022/12/29/pSp13eH.png" alt="Mealy型状态机"><br><strong>没错，做题只需要知道这么多，两句话两个图！</strong></p><h1 id="做题模板"><a href="#做题模板" class="headerlink" title="做题模板"></a>做题模板</h1><h2 id="Logisim"><a href="#Logisim" class="headerlink" title="Logisim"></a>Logisim</h2><p><img src="https://s1.ax1x.com/2022/12/29/pSp1Lp6.png" alt="状态机示例1"><br><img src="https://s1.ax1x.com/2022/12/29/pSp39AA.png" alt="状态机示例2"><br>仔细观察笔者每一道题，细心的大家一定会发现，笔者的搭建完全按照状态机基础知识中的那两个图进行搭建，线多也只是因为笔者图方便，每一条线代表一位，而基础知识中的那几个图一条线代表很多位，经此而已，所以，搭建：<font color="purple">输入-状态转移模块-寄存器-输出模块-输出</font>的框架,这便是第一步。<br>第二步也很简单：根据题意分析出状态转移，直接使用Logisim分析电路，利用真值表建立两个模块，游戏结束。<br><img src="https://s1.ax1x.com/2022/12/29/pSp3yuD.png" alt="分析电路"><br>第三步就是考虑题目的特殊组合电路，即有些题目会不仅仅考虑状态机的事情，可能会有一些额外的输出，这些就是利用电路的组合即可解出，比如第一张图中的Hit输出（不属于状态机的内容）</p><h2 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h2><p><strong>如果说Logsim或许由于大家不熟悉这种手搓电路的形式感觉有一点点难度，那么Verilog作为一个用代码描述电路的语言，学了一年C语言的我们将会更加得心应手</strong><br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S0 2&#x27;b00  </span><span class="comment">//宏定义状态便于后续描述</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S1 2&#x27;b01</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S2 2&#x27;b10</span></span><br><span class="line"><span class="keyword">module</span> id_fsm(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] char, <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> out</span><br><span class="line">    );</span><br><span class="line"> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] status=<span class="number">2&#x27;b00</span>;  <span class="comment">//寄存器</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span>    <span class="comment">//输入和状态转移模块</span></span><br><span class="line"><span class="keyword">case</span> (status)</span><br><span class="line">`S0: <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d48</span> &amp;&amp; char &lt;= <span class="number">8&#x27;d57</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d65</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d90</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d97</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d122</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">`S1: <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d48</span> &amp;&amp; char &lt;= <span class="number">8&#x27;d57</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S2; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d65</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d90</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d97</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d122</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">`S2: <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d48</span> &amp;&amp; char &lt;= <span class="number">8&#x27;d57</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S2; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d65</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d90</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d97</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d122</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> out = (status==`S2)? <span class="number">1&#x27;b1</span>:<span class="number">1&#x27;b0</span>; <span class="comment">//输出模块和输出（Moore型）</span></span><br><span class="line"><span class="keyword">assign</span> out = (status==`S2 &amp;&amp; char == <span class="string">&quot;A&quot;</span>) <span class="comment">//输出模块和输出（Mealy型）</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br>笔者做题感觉，在P1中对于Moore状态机的考察会比Mealy多一些，但在Verilog下这些都大差不差，都可以分解为<font color="purple">定义+always块+assign语句（输出）</font>。<br>定义：输入和状态寄存器。<br>always块：状态转移，无脑Switch+if else语句判断即可，在笔者看来比Logisim都简单。<br>assign:输出电路，根据不同状态机类型选择不一样的判断条件。<br><strong>若该题有特殊输出，则可考虑新建立信号，并继续用assign语句输出</strong>    </p><h1 id="练习方式"><a href="#练习方式" class="headerlink" title="练习方式"></a>练习方式</h1><p>当然，笔者这里所说可能对于刚入门的大家不太能理解，所以我们需要在练习中感受思路，这里提供一下当时笔者练习的方式。</p><h2 id="Logisim："><a href="#Logisim：" class="headerlink" title="Logisim："></a>Logisim：</h2><p>1.上机前一天将课下重做一遍，保持手感。<br>2.见前一篇文章，获取<a href="https://foreveryolo.github.io/2022/12/29/%E6%88%90%E7%86%9F%E7%9A%84%E5%AD%A9%E5%AD%90%E8%A6%81%E8%87%AA%E5%B7%B1%E6%89%BE%E9%A2%98%E5%81%9A%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96CSCORE%E7%99%BD%E9%87%91%E7%89%88/">白金版CSCore</a></p><h2 id="Verilog-1"><a href="#Verilog-1" class="headerlink" title="Verilog:"></a>Verilog:</h2><p>1.上机前一天将课下重做一遍，保持手感。<br>2.<a href="https://hdlbits.01xz.net/wiki/Main_Page">HDLBits</a>,这是一个Verilog练习网站，类似于大一的OJ，洛谷。学有余力可以做一做这里的题，可能会有小惊喜。   </p><p><font color="green">（笔者只在这里做了一道题，然而这道题就成为了笔者的P1上机第三题，真是世事难预料！）</font><br><img src="https://s1.ax1x.com/2022/12/29/pSp8iVJ.png" alt="HDLBits">  </p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P0 </tag>
            
            <tag> 北航计算机组成-P1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成熟的孩子要自己找题做——获取CSCore白金版</title>
      <link href="/posts/30831/"/>
      <url>/posts/30831/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对CSCore的Selenium学习</font></strong>  </p><h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>在北航，有这样一群人，他享有着别人所羡慕不来的东西——<font color=purple>白金版CSCore</font>,他可以查看自己的统计图，看到自己学习的时长与成果；他可以被计组邮箱推题，评测别人看不到的题。<br>我们至今未能得知白金版CSCore的来源，或许正如助教所说，这是未开发功能，只供部分人试用，又或许这是来自计组平台对于不好好做Pre的小可爱的一种Push,我们不得而知。<br>笔者很不幸运，便是普通版的一员，即使拿到了统计图的网址，点进去也会被骗到BiliBili的《never gonna give you up》。<br>然而我们是成年人了，要学会自己去获取资源，要有自己去拿到<font color=red>王者版CSCore</font>的决心与努力，因此，我们就要学习WEB自动化工具——<strong>Selenium</strong><br>当然，不学习也可以，它毕竟只是一个<strong>自动化软件</strong>，选择用勤劳的双手创造财富也可以，再不济，笔者也为大家提供了<a href="https://www.bilibili.com/video/av156766/">亡灵版CSCore</a>,点击直接使用即可~<br><img src="https://s1.ax1x.com/2022/12/29/pSSDc34.png" alt="白金版CSCore">         </p><h2 id="Selenium安装"><a href="#Selenium安装" class="headerlink" title="Selenium安装"></a>Selenium安装</h2><p>Selenium是Python的一个工具包，所以我们需要先有Python，这里笔者推荐在安装解释器时直接使用<a href="https://anaconda.org.cn/">Anaconda</a>,其为Python的集成包，集成了Python及Python主流的工具包（库）多达1500个，让你可以开始你的Python编程。<br>如果你安装了Anaconda，那么大概率Anaconda中是有Selenium的，直接使用即可。<br>如果你只是安装了Python,那么大概率你是没有Selenium的，这时候需要在控制台输入以下指令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>如果报错，请检查Python安装的正确性。</p><h2 id="浏览器驱动安装"><a href="#浏览器驱动安装" class="headerlink" title="浏览器驱动安装"></a>浏览器驱动安装</h2><p>既然Selenium是WEB自动化工具，那么我们自然需要给浏览器安装驱动程序让Python可以驱动浏览器干活，这里针对<font color=green>不同</font>的<font color=blue>浏览器</font>我们要安装不同的驱动，针对<font color=green>不同</font>的<font color=blue>浏览器</font>版本也要选择安装不同的版本。<br><strong>Firefox浏览器驱动：</strong><a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a><br><strong>Chrome浏览器驱动：</strong><a href="https://sites.google.com/a/chromium.org/chromedriver/home">chromedriver</a><br><strong>Edge浏览器驱动：</strong><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">MicrosoftWebDriver</a><br>拿<strong>Microsoft Edge</strong>举例，点击设置中的关于Microsoft Edge，我们可以看到Microsoft Edge的版本号：<br><img src="https://s1.ax1x.com/2022/12/29/pSSsESe.png" alt="Edge版本号"><br>发现开头的是108，所以我们去官网选择开头为108的驱动进行下载，后面不一样问题不大。<br><img src="https://s1.ax1x.com/2022/12/29/pSSsVQH.png" alt="Edge驱动"> </p><h2 id="正式编写针对于CSCore的代码"><a href="#正式编写针对于CSCore的代码" class="headerlink" title="正式编写针对于CSCore的代码"></a>正式编写针对于CSCore的代码</h2><h3 id="CSCore网址分析"><a href="#CSCore网址分析" class="headerlink" title="CSCore网址分析"></a>CSCore网址分析</h3><p>以上面的那道题为例，我们贴出网址如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cscore.buaa.edu.cn/#/problem?ProblemId=336&amp;PieId=896</span><br></pre></td></tr></table></figure><br>分析看出,如果用小区做例子的话，PieId就是居民楼，ProblemId就是每一住户，我们遍历搜索每一居民楼，每一住户，问问家里是否有人（题目），便可以得到所有的隐藏题目，直升<font color = red>王者版CSCore</font>,问题来了：<br>0.Selenium让我望而却步，我<strong>不能接受</strong>。<br>1.手动改网址需要1000x1000=10^6次，我们<strong>不能接受</strong>。<br>2.肉眼观察每一户是否有人住（有题），我们<strong>不能接受</strong>。</p><h3 id="针对CSCore编写Selenium"><a href="#针对CSCore编写Selenium" class="headerlink" title="针对CSCore编写Selenium"></a>针对CSCore编写Selenium</h3><h4 id="Solution-Zero"><a href="#Solution-Zero" class="headerlink" title="Solution Zero"></a>Solution Zero</h4><p><strong>万事开头难，其实Selenium归根结底只是Python的一个库函数，学会则极其简单。</strong><br>我们首先进行初步的设置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">edge_options = Options()</span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>) <span class="comment"># 使用无头模式</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>) <span class="comment"># 禁用GPU，防止无头模式出现莫名的BUG</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;window-size=1920x1080&#x27;</span>) <span class="comment">#设置为电脑显示分辨率大小</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--start-maximized&#x27;</span>) <span class="comment">#全屏展开浏览器</span></span><br><span class="line"><span class="comment">#以上都是对于Edge的设置，若用其他浏览器同理。</span></span><br><span class="line"><span class="comment"># 开启开发者模式</span></span><br><span class="line">edge_options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line"><span class="comment"># 禁用启用Blink运行时的功能</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line"><span class="comment"># 打开Edge</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;exercise.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">driver = webdriver.Edge(options=edge_options)</span><br><span class="line">driver.maximize_window()  <span class="comment"># 窗口最大化</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐式等待10s查询元素</span></span><br><span class="line"><span class="comment">#以上是操作Edge驱动的基本过程</span></span><br></pre></td></tr></table></figure><br><strong>强调：</strong> 无头模式运行时不会将浏览器显示出来，所以如果你想观看自动化过程，请注释掉使用无头模式这条语句。</p><h4 id="Solution-First"><a href="#Solution-First" class="headerlink" title="Solution First"></a>Solution First</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    web = <span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span></span><br><span class="line">    driver.get(<span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[1]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;xxx&quot;</span>)   <span class="comment"># 输入账号</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[2]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;XXXX&quot;</span>)  <span class="comment"># 输入密码</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&#x27;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[3]/button/span&#x27;</span>).click()</span><br></pre></td></tr></table></figure> <p>看不懂没关系，我们慢慢解释：<br>第一行是for循环标准语句，我们需要敲响1000户的们，所以范围是1000.<br>第二行是定义了个变量用来存放网址，用于后面搜到题我们往文档里写入网址。<br>第三行是Selenium功能，利用驱动打开该网址，中间str(i)对应户，我们遍历查找896号居民楼。<br>第四行到第十二行是一个特判：第一次进入CSCore,我们自然会需要登陆，这时候利用Selenium功能，捕捉元素(find_element)捕捉到登陆框，利用Selenium功能(send_keys)将“xxx”自动输入进去。之后利用Selenium功能，模拟点击(click)点击登陆，进入计组平台。之后便是<font color = blue>天高任鸟飞，海阔凭鱼跃了</font>。</p><p><font color = red>TIPS：</font>Selenium有很多定位元素的方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find_element_by_id()</span><br><span class="line">find_element_by_name()</span><br><span class="line">find_element_by_class_name()</span><br><span class="line">find_element_by_tag_name()</span><br><span class="line">find_element_by_link_text()</span><br><span class="line">find_element_by_partial_link_text()</span><br><span class="line">find_element_by_xpath()</span><br><span class="line">find_element_by_css_selector()</span><br></pre></td></tr></table></figure><br>我们采用最简单准确度高的操作，Xpath定位，毕竟我们是来学计组的，够用就行。   </p><h5 id="Xpath定位法"><a href="#Xpath定位法" class="headerlink" title="Xpath定位法"></a>Xpath定位法</h5><p>打开浏览器，F12进入开发者模式，出现如图所示画面，选择元素。<br><img src="https://s1.ax1x.com/2022/12/29/pSShBhn.png" alt="XPath定位1"><br>之后我们将鼠标移到每一行上面，会发现该行元素作用的范围将会以蓝色显示出来。<br><img src="https://s1.ax1x.com/2022/12/29/pSS4iDS.png" alt="XPath定位2"><br>如图，右侧浅蓝色为我<font color = blue>鼠标停留位置</font>，左侧为定位到的<font color = blue>元素</font>，我们以CSCore的密码为例。<br>之后我们点击右键，按照下图所示复制出完整的XPath路径，<font color = red>一定要完整！否则定位大概率失效！</font><br><img src="https://s1.ax1x.com/2022/12/29/pSS4QDU.png" alt="XPath定位3">   </p><h4 id="Solution-Second"><a href="#Solution-Second" class="headerlink" title="Solution Second"></a>Solution Second</h4><p>之后我们解决第二个问题:自动判断，那么我们如何才能实现自动判断？道理也很简单，我们只需要找出没有搜到题和搜到题的不同点即可，搜到题，会出现题目，没有搜到题，则是空白界面，所以我们只需要定位一个题目任意的元素，每次判断该元素是否出现，即可实现这个功能，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = driver.find_element(By.XPATH, <span class="string">&#x27;/html/body/div/div[1]/div[1]/div/main/div/div/div/div[1]/h2&#x27;</span>).text</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> info:</span><br><span class="line">        f.write(web) <span class="comment">#找到就将Web里的网址写入文件中</span></span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>) <span class="comment">#换行</span></span><br></pre></td></tr></table></figure>  </p><p><font color = red>TIPS：</font><br>如果我们只想搜编程题，则考虑搜索编程题特有的提交题目那个框。<br>如果我们全都要，那么考虑搜索题目这个元素即可。          </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><img src="https://s1.ax1x.com/2022/12/29/pSS4HGn.png" alt="结果展示"> </p><p>至此，我们完成了Selenium针对计组的学习，之后我们想实现其他的功能按照上面类似操作即可，不记得对应的语句就去百度一下。<br>如果你真的这样做了，那么恭喜你的P0-P2将一帆风顺，因为你做到了许许多多的往年考题，还有自动评测。<br><strong><font color = purple>恭喜获得王者版CSCore</font></strong>  </p><h2 id="完整源代码放送"><a href="#完整源代码放送" class="headerlink" title="完整源代码放送"></a>完整源代码放送</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.edge.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">edge_options = Options()</span><br><span class="line"><span class="comment"># 使用无头模式</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"><span class="comment"># 禁用GPU，防止无头模式出现莫名的BUG</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;window-size=1920x1080&#x27;</span>)</span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--start-maximized&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启开发者模式</span></span><br><span class="line">edge_options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line"><span class="comment"># 禁用启用Blink运行时的功能</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line"><span class="comment"># 打开Edge</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;exercise.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">driver = webdriver.Edge(options=edge_options)</span><br><span class="line">driver.maximize_window()  <span class="comment"># 窗口最大化</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐式等待10s查询元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    web = <span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span></span><br><span class="line">    driver.get(<span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[1]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;xxx&quot;</span>)   <span class="comment"># 输入账号</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[2]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;XXXX&quot;</span>)  <span class="comment"># 输入密码</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&#x27;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[3]/button/span&#x27;</span>).click()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        info = driver.find_element(By.XPATH, <span class="string">&#x27;/html/body/div/div[1]/div[1]/div/main/div/div/div/div[1]/h2&#x27;</span>).text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> info:</span><br><span class="line">            f.write(web)</span><br><span class="line">            f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure> ]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P0 </tag>
            
            <tag> 北航计算机组成-P1 </tag>
            
            <tag> 北航计算机组成-P2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>何为从代码看Logisim?</title>
      <link href="/posts/54231/"/>
      <url>/posts/54231/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对Logisim的做题思路学习</font></strong>  </p><h1 id="何为从代码看Logisim"><a href="#何为从代码看Logisim" class="headerlink" title="何为从代码看Logisim?"></a>何为从代码看Logisim?</h1><p>• MIPS中对于递归可以直接翻译C代码，那么Logisim是否可以？这就是这个问题的来源：<br>• 从代码看Logisim，即类比程设思想解决logisim问题，那么如何类比？如何解决？我想引用组合电路一种类型题——投票类型问题对其做出解释，方便大家理解，并提供解决投票问题普通投票部分的一个可行思路。当然这里我只谈思路，不谈实现，小小的抛砖引玉一波，具体怎么应用就看大家了。 </p><h1 id="Example-1-补码解决投票问题"><a href="#Example-1-补码解决投票问题" class="headerlink" title="Example 1 补码解决投票问题"></a>Example 1 补码解决投票问题</h1><h2 id="题面及分析"><a href="#题面及分析" class="headerlink" title="题面及分析"></a>题面及分析</h2><p>这是一道考试真题，大概意思是说有几个人进行投票，统计票数，要求通过输出1，不通过则输出0，这其实是一类问题，因为有时候大家权重一样进行投票，有时候大家权重不一样进行投票（一票否决），这都是会可能出的题。<br>听起来很简单的样子，但实现上其实是有一定难度的。主要难度体现在对于如何判断是否通过的输出上。下面我们谈一谈我当初的解法：    </p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>•    在初看投票类型题前，如果用C的想法去解这种题该怎么解? 主体思路便是：同意为1，弃权为0，反对为-1. 加起来看是否大于0就可以了。那么既然C可以这样实现,C归根结底是在电路上运行的，那么为什么不可以尝试转化为logisim呢？<br>•    有了这样的想法，首先要解决的就是加法问题，借助一点对计算机知识的了解，我们知道计算机中加法是按补码运算的，那么我们加法器有了，我们只需解决补码部分就可以。<br>•    假设投票人数有7个，那么考虑到最多7人同意，7人反对，那么值的范围就在-7~7之间，所以我们可选用4位数字位+1位符号位来表示（大于5位都可 不溢出就行）,同意则为00001,弃权则为00000，反对则为11111。蛤？你补码忘记了？<font color=red>计组pre进制介绍解君愁（笑）</font><br>•    但其实logisim自带了补码器，不记得的话就去手动试试<br><img src="https://s1.ax1x.com/2022/12/28/pSSpAit.png" alt="何为从代码看Logisim-1"><br>•    加法问题解决~<br>•    最后我们只需要把每个人的数据相加即可，用比较器和0判断一下即可，切记别习惯性点成无符号了！<br><img src="https://s1.ax1x.com/2022/12/28/pSS9ClT.png" alt="何为从代码看Logisim-6">    </p><h1 id="Example-2-从C中if和Switch到logisim"><a href="#Example-2-从C中if和Switch到logisim" class="headerlink" title="Example 2 从C中if和Switch到logisim"></a>Example 2 从C中if和Switch到logisim</h1><p>•    写C最离不开的就是if语句，现在我们实现加法之后也遇到了一个问题，怎么判断输入的数据是同意，弃权，还是反对？这显然是一个switch语句，我们可以借助MUX实现:<br><img src="https://s1.ax1x.com/2022/12/28/pSSpFII.png" alt="何为从代码看Logisim-2"><br>•    if的实现：如图，比较器便是if的条件判断部分，比较器的结果作用于MUX使其实现if else 功能<br><img src="https://s1.ax1x.com/2022/12/28/pSSpidA.png" alt="何为从代码看Logisim-3"><br>•    体现在投票问题当中就是最后和零的判断部分：if(结果&gt;0)执行1 else执行0<br><img src="https://s1.ax1x.com/2022/12/28/pSSpPZd.png" alt="何为从代码看Logisim-4"><br>•    回到例子，现在判断的问题也已经解决，我们可以顺利的从输入当中得到我们想要的信息进行运算了！离主体实现只有一步之遥。  </p><h1 id="Example-3-从C中for到logisim"><a href="#Example-3-从C中for到logisim" class="headerlink" title="Example 3 从C中for到logisim"></a>Example 3 从C中for到logisim</h1><p>•    这一部分，理论上可以用计数器来实现，设置stay at value. 外加比较器相等时freeze(跳出循环）但考虑到其实logisim并没有很复杂的循环，建议果断选择Ctrl C + Ctrl V<br>•    于是经过对于n个投票人的Ctrl C和Ctrl V，以及前面的一系列工作，我们得到最终主体电路，放在C中 就是 Switch 和 C的加法运算 和 if的结合 （电路自行实现~)</p><h1 id="Example-4-从C中多条件判断到Logisim"><a href="#Example-4-从C中多条件判断到Logisim" class="headerlink" title="Example 4 从C中多条件判断到Logisim"></a>Example 4 从C中多条件判断到Logisim</h1><p>•    实际过程中，if往往有多个条件，那么如何解决这个问题？其实C已经给了答案&amp;或者|对应与门或者或门，这样我们也可以完成多条件判断了.<br><img src="https://s1.ax1x.com/2022/12/28/pSSpEJP.png" alt="何为从代码看Logisim-5"><br>•    Tips:对于特殊投票人的特判就是这样实现的~（提供一个思路，实现就交给大家自行完成了）      </p><h1 id="Example-5-其余C语句实现"><a href="#Example-5-其余C语句实现" class="headerlink" title="Example 5 其余C语句实现"></a>Example 5 其余C语句实现</h1><p>•    根据代码意思转换普通电路即可</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>•    到现在为止，C语言有的语法我们都可以借助Logisim实现，那么对于一道组合逻辑题若是实在没有思路，我们可以思考怎么用C怎么实现，进而一步步转化为Logisim电路。此法名为：翻译 （默念翻译大法好） </p><h1 id="True-END"><a href="#True-END" class="headerlink" title="True END"></a>True END</h1>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在北航计算机组成总结的开头语</title>
      <link href="/posts/28817/"/>
      <url>/posts/28817/</url>
      
        <content type="html"><![CDATA[<font size=5>弹剑作歌奏苦声，曳裾王门不称情</font>  <h1 id="获得"><a href="#获得" class="headerlink" title="获得"></a>获得</h1><p>通过阅读本博客，你可以获得：<br>• 北航计算机组成从Pre到P8的一些经验与思考<br>• 北航计算机组成一些往年题题面及class文件（侵删）<br>• 北航计算机组成实用的Mars等工具<br>• 北航计算机组成从P3到P7的自动化测试思路分享<br>• 北航计算机组成从P3到P7的所有全自动强度较高的测试化程序<br>• 北航计算机组成从P3到P8的设计文档<br>• 北航计算机组成对笔者帮助很大的学长学姐博客传送门  </p><h1 id="行文思路"><a href="#行文思路" class="headerlink" title="行文思路"></a>行文思路</h1><p>笔者希望写一些有启发性，有独特性，有更深意义的计组学习文章，所以在笔者的博客中，你将不止看到往年题，更多的可能是一些技术性，思考性的文章，也是为了避免博客的同质化。再次先谢过大家的捧场了Orz</p><h1 id="计组实验内容"><a href="#计组实验内容" class="headerlink" title="计组实验内容"></a>计组实验内容</h1><p><strong>• Pre:</strong><br>课下内容：学习Logisim,Verilog,MIPS<br>课上内容：5-10道选择/填空题+3道编程题（Logisim,Verilog,MIPS各一道）<br>要求：3道编程题全部通过<br><strong>• P0：</strong><br>课下内容：学习Logisim状态机写法并进一步加深Logisim的学习<br>课上内容：3道Logisim编程题<br>要求：3过2<br><strong>• P1：</strong><br>课下内容：学习Verilog状态机写法并进一步加深Verilog的学习<br>课上内容：3道Verilog编程题<br>要求：3过2<br><strong>• P2：</strong><br>课下内容：学习MIPS语言<br>课上内容：3道MIPS编程题<br>要求：3过2<br><strong>• P3：</strong><br>课下内容：利用Logisim搭建单周期CPU,并添加一些基础指令。<br>课上内容：对课下所做的Logisim单周期CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong>• P4：</strong><br>课下内容：利用Verilog搭建单周期CPU,并添加一些基础指令。<br>课上内容：对课下所做的Verilog单周期CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong><font color="red">• P5：</font></strong><br>课下内容：利用Verilog搭建流水线CPU，并添加一些基础指令。<br>课上内容：对课下所做的Verilog五级流水线CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong>• P6：</strong><br>课下内容：利用Verilog对P5搭建的流水线CPU进行迭代开发，使其拥有乘除槽并添加更多指令。<br>课上内容：对课下所做的Verilog五级流水线CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong>• P7：</strong><br>课下内容：利用Verilog对P6搭建的流水线CPU进行迭代开发，使其具备异常处理功能。<br>课上内容：强测CPU正确性，强测CPU异常处理，强测CPU中断处理，添加新异常/中断处理规则<br>要求：CPU正确性必须通过，其余3过2<br><strong><font color="red">• P8：</font></strong><br>课下内容：利用Verilog对P7搭建的流水线CPU进行迭代开发，使其成为MIPS微处理器，并进行板级验证<br>课上内容：编写MIPS程序，使得该MIPS微处理器实现新功能<br>要求：根据完成度给分</p><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>这一系列开始于笔者学完计算机组成的寒假时光，在这一学期的学习中，<font color="blue">笔者受益于助教团队们的耐心解答</font>，<font color="green">受益于计算机组成课程平台的严谨教程</font>，<font color="red">受益于各大学长学姐的博客帮助</font>，一路走来，从初学者变为学者，再到如今成为了过来人，<del>即将接受新一轮OO OS摧残的初学者</del>，笔者深感计组学习之不易，也因此想贡献自己的一份力量，这促成了这篇博客的产生。         </p><p>然，笔者已经尽量在学期中收集计算机组成实验的各种材料，可笔者真正坐在电脑前，开始写这一系列时也感受到了记忆的大量缺失，所以期望大家带有审慎的态度去观看笔者的每一篇博客，谢谢！      </p><p>作为过来人的笔者，教学谈不上，指导更谈不上，在此也就只是起一个抛砖引玉的作用，期盼大家在计算机组成上的优异表现！<br><img src="https://s1.ax1x.com/2022/12/28/pSS1kuQ.png" alt="通关图"><br><img src="https://s1.ax1x.com/2022/12/28/pSS1ABj.png" alt="AK图"><br><img src="https://s1.ax1x.com/2022/12/30/pSpDyWD.png" alt="计组文件大小"></p><center><font size=4>主要是生成的测试数据太多了Orz</font></center>      <p><strong><font color="purple">善始善终，Pre-P8无一次不通过记录，给自己留个纪念~非常感谢助教们的帮助Orz</font></strong>  </p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/baidu_verify_codeva-rSxShdkzwD.html"/>
      <url>/baidu_verify_codeva-rSxShdkzwD.html</url>
      
        <content type="html"><![CDATA[3cb4bb475c7dde65b56ca90f7afdabed]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>书籍</title>
      <link href="/books/index.html"/>
      <url>/books/index.html</url>
      
        <content type="html"><![CDATA[<div class="fj-gallery"><p><img src="https://s1.ax1x.com/2023/01/28/pSanJat.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSaurlD.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSauyOH.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSanoZR.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSanOzD.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSaupdI.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSauQYV.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSaulWT.png" alt=""></p>          </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>archives</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>2021-2025 北航<br>感恩每一次相遇！</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=780 height=900 src="//music.163.com/outchain/player?type=0&id=8106272779&auto=1&height=430"></iframe>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
