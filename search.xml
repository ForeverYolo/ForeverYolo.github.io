<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>单周期CPU全自动测试思路（Logisim）</title>
      <link href="/2022/12/30/P3%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E5%85%A8%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF%EF%BC%88Logisim%EF%BC%89/"/>
      <url>/2022/12/30/P3%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E5%85%A8%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF%EF%BC%88Logisim%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P3的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>通过阅读本文，你可以了解到如何<del>蒟蒻</del>合理生成不会陷入死循环不会报错的指令，并了解到对logisim进行自动化测试的相关方法。</p><h1 id="全自动测试的开端：设施准备"><a href="#全自动测试的开端：设施准备" class="headerlink" title="全自动测试的开端：设施准备"></a>全自动测试的开端：设施准备</h1><p>要完成logisim的自动测试，需要使用到Logisim的命令行操作对输出进行重定向，所以我们需要.jar版的logisim来实现，该文件上网找找就有，我也已经上传至<a href="https://pan.baidu.com/s/1-ZFbWIHCk7tVUt5MWq8gWA?pwd=ozsw">百度网盘</a>，提取码：ozsw，需要的uu可以自取。</p><h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><p>logisim的命令行官方文档是有介绍的，感兴趣的可以去看看：<br><img src="https://s1.ax1x.com/2022/12/29/pSp8rin.png" alt="Logisim官方介绍"><br>这里我直接贴出有用的命令行，并对其做出解释，方便速通。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar logisim-generic-<span class="number">2</span>.<span class="number">7</span>.<span class="number">1</span>.jar CPU名称.circ -tty table &gt; 输出.txt</span><br></pre></td></tr></table></figure>  <p>这句话的意思是运行该.circ文件并将<strong>顶层模块的输出</strong>全部进行<strong>输出</strong>，注意是<strong>顶层模块</strong>，<strong>子模块</strong>不会输出任何结果！<br>意味着若你想得到你需要的数据，你就需要在主模块将其作为输出进行输出。<br>对于一个xxxx.asm程序，我们需要通过命令行运行mars使其输出机器码文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars4_5.jar xxxx.asm nc mc CompactTextAtZero a dump .text HexText 机器码.txt</span><br></pre></td></tr></table></figure> <h1 id="对于cpu的额外设置"><a href="#对于cpu的额外设置" class="headerlink" title="对于cpu的额外设置"></a>对于cpu的额外设置</h1><p>有了上述指令，程序就可以运行了，并且我们可以在程序的同一目录下得到输出文件，但此时会出现新的问题，该cpu会一直运转，不会停止，这时候就需要对其提供halt指令（源自官方文档），当halt信号为1时，结束程序，可以如下实现：<br>为在顶层模块采用计数器设置计数最大值（你需要运行的周期），设置计数器为达到最大值保持，这时候进位输出端便会输出1，将其作为halt信号即可结束程序<br><img src="https://s1.ax1x.com/2022/12/29/pSp8yR0.png" alt="P3图片1"><br><font color="purple">官方介绍：</font></p><p><img src="https://s1.ax1x.com/2022/12/29/pSp82sU.png" alt="P3图片2"><br>好像这就是评测机的评测机制的一部分（思考）<br><font color="red">不用担心这里的halt信号也会作为输出不断输出，logisim会忽略halt信号的输出。</font></p><h1 id="机器码读入ROM"><a href="#机器码读入ROM" class="headerlink" title="机器码读入ROM"></a>机器码读入ROM</h1><p>Logisim官方文档也提供了读入的方法，但其实不是很直观，观察.circ文件中rom的表示方式，我们可以使用正则表达式对其匹配并强制替换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr/data: <span class="number">10</span> <span class="number">32</span>([\s\S]*?)&lt;/a&gt;  <span class="comment">#正则表达式</span></span><br></pre></td></tr></table></figure> <p>注意<font color="green"><font size=4>非贪婪匹配</font></font>，贪婪匹配会导致该正则表达式匹配到多余的内容，替换后使得文件损坏。<br><img src="https://s1.ax1x.com/2022/12/29/pSp8IiR.png" alt="P3图片3"></p><center><font size=4>替换前</font></center>     <p><img src="https://s1.ax1x.com/2022/12/29/pSp8gMT.png" alt="P3图片4"></p><center><font size=4>替换后</font></center><h1 id="python实现思路"><a href="#python实现思路" class="headerlink" title="python实现思路"></a>python实现思路</h1><p><strong>python提供了os模块代替手动执行命令行，示例如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&quot;java -jar Mars4_5.jar test.asm nc mc CompactTextAtZero a dump .text HexText command.txt&quot;</span>)</span><br></pre></td></tr></table></figure>  <p><strong>python提供了re模块用于正则表达式匹配替换，示例如下：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymem = re.sub(<span class="string">r&#x27;addr/data: 10 32([\s\S]*?)&lt;/a&gt;&#x27;</span>, <span class="string">&quot;addr/data: 10 32\n&quot;</span> + content + <span class="string">&quot;&lt;/a&gt;&quot;</span>, mymem)</span><br></pre></td></tr></table></figure>  <p>执行完毕后得到的结果文件可以与同学对拍。<br><strong>而python也提供了filediff.diff模块用于文本差异比对，生成html文件，若有区别，则会标红，这里是由于文本一致所以无色。</strong><br><img src="https://s1.ax1x.com/2022/12/29/pSp84o9.png" alt="P3图片7"><br>（左右各为两个CPU输出结果） 有了这些我们就可以写出.py程序直接得到最终的比较结果 </p><h1 id="自动化数据生成思路"><a href="#自动化数据生成思路" class="headerlink" title="自动化数据生成思路"></a>自动化数据生成思路</h1><p><font color="purple">测试讲完了，但测试数据怎么来？这就需要我们自动化生成测试数据。 </font><br>可以选择c,c++,java,python生成，因为它们都支持命令行的重定向操作，最终用python指挥它们干活即可。     </p><h2 id="具体思路："><a href="#具体思路：" class="headerlink" title="具体思路："></a>具体思路：</h2><p>•开局先使用ori或lui给31个寄存器用随机数乱赋初值，确保后面的指令运行时不会拿0加来加去，导致没有测试意义。<br>•构造一个字符串数组，存指令名称，用随机数生成的数字确定本次随机的指令，然后分别实现各个指令的生成，对于寄存器和立即数选择随机生成。<br>•对于一般指令这样做完全够用，但beq和jal和jr则需要仔细考虑，不然会导致程序死循环或寻址到不合适的地方而报错。<br><font color="green">在此提供我的一些思路：</font><br>•以段生成代码，将jal固定出现在入口末尾，jr固定出现在出口末尾，确保jal和jr的跳转不会导致死循环<br>•对于beq的生成，其实有一个最简单粗暴的方式是beq往后跳转，这样不满足条件，指令也会往下执行，满足，也会往下执行，不会出现问题。当然如果一定要实现往前跳转，可以固定一段代码段，将其作为计数模块，当其执行超过一定次数时直接跳出此段代码。         </p><p><img src="https://s1.ax1x.com/2022/12/29/pSp8RLF.png" alt="P3图片8"><br><img src="https://s1.ax1x.com/2022/12/29/pSp8hdJ.png" alt="P3图片9"><br><img src="https://s1.ax1x.com/2022/12/29/pSp8fZ4.png" alt="P3图片10"><br>这部分做好后同样利用Python即可将其与上述测试程序链接自动生成代码自己对拍出结果，实现<strong>自动化测试</strong>。</p><h1 id="Python代码放送"><a href="#Python代码放送" class="headerlink" title="Python代码放送"></a>Python代码放送</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import difflib</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line">import filestools</span><br><span class="line">from filediff.diff import file_diff_compare</span><br><span class="line"># <span class="number">0</span>.自动化生成数据</span><br><span class="line"><span class="built_in">print</span>(&quot;生成指令中&quot;+&#x27;\n&#x27;)</span><br><span class="line">command = &quot;C语言.exe&quot;</span><br><span class="line">os.system(command)</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>.先运行Mars生成机器码</span><br><span class="line"><span class="built_in">print</span>(&quot;生成机器码中&quot;+&#x27;\n&#x27;)</span><br><span class="line">os.system(&quot;java -jar Mars4_5.jar test.asm nc mc CompactTextAtZero a dump .text HexText command.txt&quot;)</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>.运行写好的circ文件将里面的ROM值更改为上述输出的机器码</span><br><span class="line"><span class="built_in">print</span>(&quot;添加指令至单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">content = open(&quot;command.txt&quot;).read()</span><br><span class="line">mymem = open(&quot;单周期cpu.circ&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;).read()</span><br><span class="line">mymem = re.sub(r&#x27;addr/data: <span class="number">10</span> <span class="number">32</span>([\s\S]*?)&lt;/a&gt;&#x27;, &quot;addr/data: <span class="number">10</span> <span class="number">32</span>\n&quot; + content + &quot;&lt;/a&gt;&quot;, mymem)</span><br><span class="line">with open(&quot;单周期cpu镜像.circ&quot;, &quot;w&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;) as file:</span><br><span class="line">    file.write(mymem)</span><br><span class="line"><span class="built_in">print</span>(&quot;添加指令至另一个单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">myfriendmem = open(&quot;另一个单周期cpu.circ&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;).read()</span><br><span class="line">myfriendmem = re.sub(r&#x27;addr/data: <span class="number">10</span> <span class="number">32</span>([\s\S]*?)&lt;/a&gt;&#x27;, &quot;addr/data: <span class="number">10</span> <span class="number">32</span>\n&quot; + content + &quot;&lt;/a&gt;&quot;, myfriendmem)</span><br><span class="line">with open(&quot;另一个单周期cpu镜像.circ&quot;, &quot;w&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;) as file:</span><br><span class="line">    file.write(myfriendmem)</span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>.运行logisim输出结果</span><br><span class="line"><span class="built_in">print</span>(&quot;运行单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">command = &quot;java -jar logisim-generic-<span class="number">2</span>.<span class="number">7</span>.<span class="number">1</span>.jar 单周期cpu镜像.circ -tty table &gt; 单周期cpu结果.txt&quot;</span><br><span class="line">os.system(command)</span><br><span class="line"><span class="built_in">print</span>(&quot;运行另一个单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">command = &quot;java -jar logisim-generic-<span class="number">2</span>.<span class="number">7</span>.<span class="number">1</span>.jar 另一个单周期cpu镜像.circ -tty table &gt; 另一个单周期cpu结果.txt&quot;</span><br><span class="line">os.system(command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>.找人对拍</span><br><span class="line"><span class="built_in">print</span>(&quot;正在比较结果，时间可能较长，请耐心等待&quot;+&#x27;\n&#x27;)</span><br><span class="line">def read_file(filename):</span><br><span class="line"><span class="function">    try:</span></span><br><span class="line"><span class="function">        <span class="title">with</span> <span class="title">open</span>(<span class="title">filename</span>, &#x27;<span class="title">r</span>&#x27;) <span class="title">as</span> <span class="title">f</span>:</span></span><br><span class="line"><span class="function">            <span class="title">return</span> <span class="title">f.readlines</span>()</span></span><br><span class="line"><span class="function">    <span class="title">except</span> <span class="title">IOError</span>:</span></span><br><span class="line"><span class="function">        <span class="title">print</span>(&quot;<span class="title">ERROR</span>: 没有找到文件:%<span class="title">s</span>或读取文件失败！&quot; % <span class="title">filename</span>)</span></span><br><span class="line"><span class="function">        <span class="title">sys.exit</span>(1)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">compare_file</span>(<span class="title">file1</span>, <span class="title">file2</span>, <span class="title">out_file</span>):</span></span><br><span class="line"><span class="function">    <span class="title">file1_content</span> = <span class="title">read_file</span>(<span class="title">file1</span>)</span></span><br><span class="line"><span class="function">    <span class="title">file2_content</span> = <span class="title">read_file</span>(<span class="title">file2</span>)</span></span><br><span class="line"><span class="function">    <span class="title">d</span> = <span class="title">difflib.HtmlDiff</span>()</span></span><br><span class="line"><span class="function">    <span class="title">result</span> = <span class="title">d.make_file</span>(<span class="title">file1_content</span>, <span class="title">file2_content</span>)</span></span><br><span class="line"><span class="function">    <span class="title">with</span> <span class="title">open</span>(<span class="title">out_file</span>, &#x27;<span class="title">w</span>&#x27;) <span class="title">as</span> <span class="title">f</span>:</span></span><br><span class="line"><span class="function">        <span class="title">f.writelines</span>(<span class="title">result</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">compare_file</span>(<span class="title">r</span>&#x27;单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&#x27;, <span class="title">r</span>&#x27;另一个单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&#x27;, <span class="title">r</span>&#x27;<span class="title">result.html</span>&#x27;)</span></span><br><span class="line"><span class="function"><span class="title">file_diff_compare</span>(&quot;单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&quot;,&quot;另一个单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&quot;)</span></span><br><span class="line"><span class="function"><span class="title">print</span>(&quot;比较结束，测试完毕，请查看结果&quot;+&#x27;\<span class="title">n</span>&#x27;)</span></span><br><span class="line"><span class="function">#5.到文件中查看结果</span></span><br></pre></td></tr></table></figure>  <h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/blob/main/P3">https://github.com/ForeverYolo/2022-BUAA-CO/blob/main/P3</a>  </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这篇文章是写于作者学习P3之时，回过头来还是觉得当时的自己略显稚嫩，所以笔者在这里起一个抛砖引玉的作用，希望对大家测试logisim有所启发！</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单周期CPU设计文档（Logisim）</title>
      <link href="/2022/12/29/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%EF%BC%88Logisim%EF%BC%89/"/>
      <url>/2022/12/29/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%EF%BC%88Logisim%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Logisim 单周期CPU设计文档</center></font></strong></p><h1 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h1><p>（一）总体设计概述</p><p>使用Logisim设计开发一个初步的单周期CPU，总体概述如下：</p><ol><li>此CPU为32位CPU</li><li>此CPU为单周期</li><li>此CPU支持的指令集为：{add, sub, addu, subu, ori, lw, sw, beq, lui, nop, j}</li><li>nop的机器码为0x00000000</li><li>addu,subu不支持溢出</li></ol><p>（二）关键模块定义</p><p><strong>1．IFU</strong></p><p>(1) 端口说明</p><p>表 1-IFU端口说明</p><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLK</td><td>I</td><td>时钟信号</td></tr><tr><td>2</td><td>RESET</td><td>I</td><td>异步复位信号，将PC值置为0x00000000 0：无效 1：复位</td></tr><tr><td>3</td><td>PCN[31:0]</td><td>I</td><td>PC的下一个值</td></tr><tr><td>4</td><td>Instr[31:0]</td><td>O</td><td>输出IM中将要执行的指令</td></tr><tr><td>5</td><td>PC[31:0]</td><td>O</td><td>输出当前PC值</td></tr></tbody></table><p>(2) 功能定义</p><p>表 2-IFU功能定义</p><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>当RESET有效时，将PC值置为0x00000000</td></tr><tr><td>2</td><td>更新PC值</td><td>PC&lt;&#x3D;NPC</td></tr><tr><td>3</td><td>输出指令</td><td>根据PC的值，取出IM中的指令</td></tr></tbody></table><p><strong>2．GRF</strong></p><p>(1) 端口说明</p><p>表 3-GRF端口说明</p><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLK</td><td>I</td><td>时钟信号</td></tr><tr><td>2</td><td>WE</td><td>I</td><td>写使能信号 0：不能向GRF写入数据 1：可向GRF写入数据</td></tr><tr><td>3</td><td>RESET</td><td>I</td><td>异步复位信号 1：将所有寄存器清零 0：无效</td></tr><tr><td>4</td><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>5</td><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>6</td><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将WD的数据读入到该寄存器</td></tr><tr><td>7</td><td>WD[31:0]</td><td>I</td><td>32位写入到A3所指向寄存器的数据</td></tr><tr><td>8</td><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器的32位数据</td></tr><tr><td>9</td><td>RD1[31:0]</td><td>O</td><td>输出A2指定的寄存器的32位数据</td></tr></tbody></table><p>（2）功能定义</p><p>表 4-GRF功能定义</p><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>异步复位</td><td>当RESET的值有效时，将所有寄存器异步清零</td></tr><tr><td>2</td><td>写入数据</td><td>当WE为1且时钟上升沿来临时，将WD写入到A3对应的寄存器</td></tr><tr><td>3</td><td>读出数据</td><td>将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出</td></tr></tbody></table><p><strong>3.DM</strong></p><p>（1）端口说明</p><p>表 5-DM端口说明</p><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLK</td><td>I</td><td>时钟信号</td></tr><tr><td>2</td><td>WE</td><td>I</td><td>写使能信号 0：不能向DM写入数据 1：可向DM写入数据</td></tr><tr><td>3</td><td>RESET</td><td>I</td><td>异步复位信号 0：无效 1：将DM清零</td></tr><tr><td>4</td><td>A[4:0]</td><td>I</td><td>5位读取或写入地址信号</td></tr><tr><td>5</td><td>WD[31:0]</td><td>I</td><td>32位写入数据</td></tr><tr><td>6</td><td>RD[31:0]</td><td>O</td><td>32位读出数据</td></tr></tbody></table><p>（2）功能定义</p><p>表 6-DM功能定义</p><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>异步复位</td><td>当RESET的值有效时，将DM清零</td></tr><tr><td>2</td><td>写入数据</td><td>当WE为1且时钟上升沿来临时，将WD写入A对应的地址中</td></tr><tr><td>3</td><td>读出数据</td><td>RD时刻读出A对应地址的值</td></tr></tbody></table><p><strong>4.ALU</strong></p><p>（1）端口说明</p><p>表 7-ALU端口说明</p><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>SrcA[31:0]</td><td>I</td><td>操作数1</td></tr><tr><td>2</td><td>SrcB[31:0]</td><td>I</td><td>操作数2</td></tr><tr><td>3</td><td>ALUControl[2:0]</td><td>I</td><td>决定ALU操作： 000：无符号加 001：无符号减 010：与 011：或 100：将SrcB左移10位</td></tr><tr><td>4</td><td>Bigger</td><td>O</td><td>SrcA与ScrB是否相等 0：不相等 1：相等</td></tr><tr><td>5</td><td>Res[31:0]</td><td>O</td><td>输出结果</td></tr></tbody></table><p>（2）功能定义</p><p>表 8-ALU功能定义</p><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>无符号加</td><td>Res&#x3D;SrcA+SrcB</td></tr><tr><td>2</td><td>无符号减</td><td>Res&#x3D;SrcA-SrcB</td></tr><tr><td>3</td><td>与</td><td>Res&#x3D;SrcA&amp;SrcB</td></tr><tr><td>4</td><td>或</td><td>Res&#x3D;SrcA|SrcB</td></tr><tr><td>5</td><td>将SrcB左移10位</td><td>Res&#x3D;SrcB&lt;&lt;10</td></tr></tbody></table><p><strong>5.NPC</strong></p><p>（1）端口说明</p><p>表 9-NPC端口说明</p><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>PC[31:0]</td><td>I</td><td>当前PC值</td></tr><tr><td>2</td><td>Jump</td><td>I</td><td>Jump选择信号 0：无效 1：指令是J</td></tr><tr><td>3</td><td>SignImm[31:0]</td><td>I</td><td>扩展后的32位信号</td></tr><tr><td>4</td><td>EPC[27:0]</td><td>I</td><td>扩展后的28位信号</td></tr><tr><td>5l</td><td>NPCControl</td><td>I</td><td>NPCControl选择信号 0：无效 1：指令是beq</td></tr><tr><td>6</td><td>PCN[31:0]</td><td>O</td><td>下一PC值</td></tr></tbody></table><p>（2）功能定义</p><p>表 10-NPC功能定义</p><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>选择是否为J指令</td><td>0：无效 1：是J指令</td></tr><tr><td>2</td><td>选择是否为Beq指令</td><td>0：无效 1：为Beq指令</td></tr><tr><td>3</td><td>输出下一PC值</td><td>PCN为下一PC值</td></tr></tbody></table><p><strong>6.Control</strong></p><p>(1) 端口说明</p><p>表 11-Control端口说明</p><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Op[5:0]</td><td>I</td><td>Instr[31:26] 6位控制信号</td></tr><tr><td>2</td><td>FC[5:0]</td><td>I</td><td>Instr[0:5] 6位控制信号</td></tr><tr><td>3</td><td>ALUop[2:0]</td><td>O</td><td>ALU的控制信号</td></tr><tr><td>4</td><td>Jump</td><td>O</td><td>是否为J指令 0：不是 1：是</td></tr><tr><td>5</td><td>RegWrite</td><td>O</td><td>GRF的写入信号 0：禁止写入 1：允许写入</td></tr><tr><td>6</td><td>MemWrite</td><td>O</td><td>DM的写入信号 0：禁止写入 1：允许写入</td></tr><tr><td>7</td><td>MemToReg</td><td>O</td><td>选择写入REG的数据 0：ALU 1：DM</td></tr><tr><td>8</td><td>RegDest</td><td>O</td><td>选择A3的地址 0：Instr[20:16] 1：Instr[15:11]</td></tr><tr><td>9</td><td>RegSrc</td><td>O</td><td>选择SrcB数据来源 0：GRF 1：立即数</td></tr><tr><td>10</td><td>Branch</td><td>O</td><td>是否为Beq指令 0：不是 1：是</td></tr></tbody></table><p>（2）真值表</p><p>表 12-Control真值表</p><table><thead><tr><th>端口</th><th>addu</th><th>subu</th><th>ori</th><th>lw</th><th>sw</th><th>lui</th><th>beq</th><th>J</th></tr></thead><tbody><tr><td>Op</td><td>000000</td><td>000000</td><td>001101</td><td>100011</td><td>101011</td><td>001111</td><td>000100</td><td>000010</td></tr><tr><td>FC</td><td>100001</td><td>100011</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALUop</td><td>000</td><td>001</td><td>011</td><td>000</td><td>000</td><td>100</td><td>000</td><td>000</td></tr><tr><td>Jump</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>RegWrite</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>MemWrite</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>MemToReg</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>RegDest</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>RegSrc</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Branch</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table><p>表 12-Control真值表（续）</p><table><thead><tr><th>端口</th><th>add</th><th>sub</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Op</td><td>000000</td><td>000000</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>FC</td><td>100000</td><td>100010</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALUop</td><td>000</td><td>001</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Jump</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegWrite</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MemWrite</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MemToReg</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegDest</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegSrc</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Branch</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><p>（1）测试代码</p><pre><code>ori $t1 , $t2 , 100addu(add) $t2 , $t1 , $t1subu(sub) $t3 , $t2 , $t1sw $t3 , 0($0)lw $t4 , 0($0)nopLabel:beq $t3 , $t2 , Label_Endaddu $t3 , $t3 , $t1j LabelLabel_End:</code></pre><p>（2）MARS中运行结果<br><img src="/2022/12/29/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%EF%BC%88Logisim%EF%BC%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221017235123.png"><br><img src="/2022/12/29/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%EF%BC%88Logisim%EF%BC%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221017235116.png"><br>（3）该CPU运行结果<br><img src="/2022/12/29/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%EF%BC%88Logisim%EF%BC%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221018000817.png"><br><img src="/2022/12/29/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%EF%BC%88Logisim%EF%BC%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221018000748.png"><br><img src="/2022/12/29/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%EF%BC%88Logisim%EF%BC%89/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221018000803.png"></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="（一）上面我们介绍了通过-FSM-理解单周期-CPU-的基本方法。请大家指出单周期-CPU-所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。"><a href="#（一）上面我们介绍了通过-FSM-理解单周期-CPU-的基本方法。请大家指出单周期-CPU-所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。" class="headerlink" title="（一）上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。"></a>（一）上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</h3><p>答：状态存储：DM,GRF</p><p>状态转移：IFU,NPC,EXT,ALU,Control</p><h3 id="（二）现在我们的模块中IM使用ROM，-DM使用RAM，-GRF使用Register，这种做法合理吗？-请给出分析，若有改进意见也请一并给出。"><a href="#（二）现在我们的模块中IM使用ROM，-DM使用RAM，-GRF使用Register，这种做法合理吗？-请给出分析，若有改进意见也请一并给出。" class="headerlink" title="（二）现在我们的模块中IM使用ROM， DM使用RAM， GRF使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。"></a>（二）现在我们的模块中IM使用ROM， DM使用RAM， GRF使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</h3><p>答：合理</p><p>IM是指令单元，指令在程序执行过程中不会再更改，也不应该被更改，也就是应只读，ROM就是只具有读取功能的存储器，满足要求</p><p>DM是存储单元，在程序的执行过程中需要不断地向DM中存入，读出数据，所以具有读入与读出的RAM满足要求</p><p>之所以DM不选择寄存器的原因是寄存器相比RAM是昂贵的，且DM需要存储大量数据，采用寄存器会导致成本成倍增长，得不偿失。</p><p>GRF为寄存器堆，自然选择32个寄存器去实现32个寄存器，符合要求与逻辑</p><p>没有改进意见</p><h3 id="（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。"><a href="#（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。" class="headerlink" title="（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。"></a>（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</h3><p>答：是，设计了NPC模块，介绍：NPC模块是用于计算PC的下一值的集成式计算中心，它包容了Beq j等跳转指令的计算，使得对于PC下一值的处理整体而思路清晰。设计思路：首先NPC作为计算PC下一值的模块最基本的功能就是PC&lt;&#x3D;PC+4，这个是首要实现的功能，接着就是想办法实现BEQ,J等跳转指令的功能，结合BEQ和J等指令的机器码，将其有用的部分输入进NPC当中进行计算就可得到当前指令若为BEQ和J，它们的值分别为多少，但这里就涉及到了选择的问题，NPC如何知道提供给PC的下一值是PC+4,还是BEQ的跳转，还是J的跳转？因而就需引入多路选择器，并辅以控制选择信号（Conrtol部分生成）来选择PC的下一值，由于有3个选择，我这里采用了2个多路选择器，先二选一，再加入另一个再二选一，具体如图：<br><img src="/2022/12/29/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%EF%BC%88Logisim%EF%BC%89/1234.png"></p><h3 id="（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由"><a href="#（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由" class="headerlink" title="（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由"></a>（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由</h3><p>答：nop为空指令，不会进行任何操作，仅仅占用一个指令而使得PC&lt;&#x3D;PC+4，所以不管加不加都不会影响它的效果</p><h3 id="（五）上文提到，MARS-不能导出-PC-与-DM-起始地址均为-0-的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。"><a href="#（五）上文提到，MARS-不能导出-PC-与-DM-起始地址均为-0-的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。" class="headerlink" title="（五）上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。"></a>（五）上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。</h3><p>答：其实经过研究发现，在我目前所添加的指令中，PC所影响的指令就是J指令，因为J指令是直接跳转到地址，BEQ算的是偏移量，但为了修改方便，我还是针对PC进行了修改，而不是对J指令那一路进行修改，起始时首先PC应该复位为0x3000而且保证该周期正常取指，所以选择了多路选择器，在第一周期屏蔽PC的影响，直接取0位置处的地址（利用PC起始为0与0相等），在第二周期PC被成功赋值后再由PC决定取指，之后就简单了，每次PC的值作用于ROM时都先减去0x3000即可。实现如图：</p><p><img src="/2022/12/29/%E5%8D%95%E5%91%A8%E6%9C%9FCPU%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%EF%BC%88Logisim%EF%BC%89/123.png"></p><h3 id="（六）阅读-Pre-的-“MIPS-指令集及汇编语言”-一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。"><a href="#（六）阅读-Pre-的-“MIPS-指令集及汇编语言”-一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。" class="headerlink" title="（六）阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。"></a>（六）阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</h3><p>答：测试样例反汇编为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lui $t0, 0x1</span><br><span class="line">ori $t0, $t0, 0x2f6a</span><br><span class="line">ori $a0, $0, 0x4</span><br><span class="line">ori $a1, $0, 0x1</span><br><span class="line">ori $a2, $0, 0x4</span><br><span class="line">ori $a3, $0, 0x20</span><br><span class="line">sw $a3, 0x0($0)</span><br><span class="line">lw $t2, 0x0($0)</span><br><span class="line">sw $t0, 0x0($a0)</span><br><span class="line">subu $t1, $t0, $t2</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">beq $a3, $a1, label_1</span><br></pre></td></tr></table></figure><p>首先肯定的是所有的要求实现的指令至少都出现了一次进行了测试（虽然要实现的是add和sub这里是addu和subu，但是由设计要求可知在这里add和addu等价，subu和sub等价），且除了Beq以外都测试了多次，提升了检测出Bug的概率，强度还是有的，但放到Logisim跑了一遍和观察汇编指令发现，全程并无负数出现，也就是只测试了正数，且正数不大，数据覆盖范围比较窄，同时发现检测的寄存器是固定的几个，寄存器检测范围比较窄，对于beq则没有检测原地跳，向后跳，只是检测了向前跳。跳转范围检测比较窄。</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机实验秒杀——模板化做题</title>
      <link href="/2022/12/29/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E9%AA%8C%E7%A7%92%E6%9D%80%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%81%9A%E9%A2%98/"/>
      <url>/2022/12/29/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E9%AA%8C%E7%A7%92%E6%9D%80%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E5%8C%96%E5%81%9A%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><strong><font size=5>这是一篇适用于P0,P1状态机的做题思路分享</font></strong>     </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>在度过Pre通过的快乐或是不通过的悲伤之后，很快我们会迎来真正的考验，从P0开始一直到P1，我们将要面对的一个主要问题就是状态机，而状态机一般在P0中占据两题的位置，P1中占据三题的位置，所以我们可以说，状态机这一关过不去，<font color="red">我们的实验将止步于P0。</font><br>但是，在笔者看来，状态机反而是最为简单，最为模板化的一类题，一旦掌握，则成竹在胸，很难出现意外。今天我们就来聊一聊状态机的是是非非。<br>虽然笔者也极力反对这种刻板化做题的行为，但不得不说，对于状态机而言，<font color="green">一直用一直爽！</font>      </p><h1 id="状态机基础知识"><a href="#状态机基础知识" class="headerlink" title="状态机基础知识"></a>状态机基础知识</h1><h2 id="Moore型状态机"><a href="#Moore型状态机" class="headerlink" title="Moore型状态机"></a>Moore型状态机</h2><p>关键点：输出信号<font color="red"><font size=4>仅</font></font>与当前状态相关<br><img src="https://s1.ax1x.com/2022/12/29/pSp1QyD.png" alt="Moore型状态机"></p><h2 id="Mealy型状态机"><a href="#Mealy型状态机" class="headerlink" title="Mealy型状态机"></a>Mealy型状态机</h2><p>关键点：输出信号与当前状态<font color="red"><font size=4>及</font></font>输入信号有关<br><img src="https://s1.ax1x.com/2022/12/29/pSp13eH.png" alt="Mealy型状态机"><br><strong>没错，做题只需要知道这么多，两句话两个图！</strong></p><h1 id="做题模板"><a href="#做题模板" class="headerlink" title="做题模板"></a>做题模板</h1><h2 id="Logisim"><a href="#Logisim" class="headerlink" title="Logisim"></a>Logisim</h2><p><img src="https://s1.ax1x.com/2022/12/29/pSp1Lp6.png" alt="状态机示例1"><br><img src="https://s1.ax1x.com/2022/12/29/pSp39AA.png" alt="状态机示例2"><br>仔细观察笔者每一道题，细心的大家一定会发现，笔者的搭建完全按照状态机基础知识中的那两个图进行搭建，线多也只是因为笔者图方便，每一条线代表一位，而基础知识中的那几个图一条线代表很多位，经此而已，所以，搭建：<font color="purple">输入-状态转移模块-寄存器-输出模块-输出</font>的框架,这便是第一步。<br>第二步也很简单：根据题意分析出状态转移，直接使用Logisim分析电路，利用真值表建立两个模块，游戏结束。<br><img src="https://s1.ax1x.com/2022/12/29/pSp3yuD.png" alt="分析电路"><br>第三步就是考虑题目的特殊组合电路，即有些题目会不仅仅考虑状态机的事情，可能会有一些额外的输出，这些就是利用电路的组合即可解出，比如第一张图中的Hit输出（不属于状态机的内容）</p><h2 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h2><p><strong>如果说Logsim或许由于大家不熟悉这种手搓电路的形式感觉有一点点难度，那么Verilog作为一个用代码描述电路的语言，学了一年C语言的我们将会更加得心应手</strong>  </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S0 2&#x27;b00  </span><span class="comment">//宏定义状态便于后续描述</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S1 2&#x27;b01</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S2 2&#x27;b10</span></span><br><span class="line"><span class="keyword">module</span> id_fsm(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] char, <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> out</span><br><span class="line">    );</span><br><span class="line"> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] status=<span class="number">2&#x27;b00</span>;  <span class="comment">//寄存器</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span>    <span class="comment">//输入和状态转移模块</span></span><br><span class="line"><span class="keyword">case</span> (status)</span><br><span class="line">`S0: <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d48</span> &amp;&amp; char &lt;= <span class="number">8&#x27;d57</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d65</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d90</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d97</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d122</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">`S1: <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d48</span> &amp;&amp; char &lt;= <span class="number">8&#x27;d57</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S2; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d65</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d90</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d97</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d122</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">`S2: <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d48</span> &amp;&amp; char &lt;= <span class="number">8&#x27;d57</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S2; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d65</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d90</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d97</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d122</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> out = (status==`S2)? <span class="number">1&#x27;b1</span>:<span class="number">1&#x27;b0</span>; <span class="comment">//输出模块和输出（Moore型）</span></span><br><span class="line"><span class="keyword">assign</span> out = (status==`S2 &amp;&amp; char == <span class="string">&quot;A&quot;</span>) <span class="comment">//输出模块和输出（Mealy型）</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure> <p>笔者做题感觉，在P1中对于Moore状态机的考察会比Mealy多一些，但在Verilog下这些都大差不差，都可以分解为<font color="purple">定义+always块+assign语句（输出）</font>。<br>定义：输入和状态寄存器。<br>always块：状态转移，无脑Switch+if else语句判断即可，在笔者看来比Logisim都简单。<br>assign:输出电路，根据不同状态机类型选择不一样的判断条件。<br><strong>若该题有特殊输出，则可考虑新建立信号，并继续用assign语句输出</strong>    </p><h1 id="练习方式"><a href="#练习方式" class="headerlink" title="练习方式"></a>练习方式</h1><p>当然，笔者这里所说可能对于刚入门的大家不太能理解，所以我们需要在练习中感受思路，这里提供一下当时笔者练习的方式。</p><h2 id="Logisim："><a href="#Logisim：" class="headerlink" title="Logisim："></a>Logisim：</h2><p>1.上机前一天将课下重做一遍，保持手感。<br>2.见前一篇文章，获取<a href="https://foreveryolo.github.io/2022/12/29/%E6%88%90%E7%86%9F%E7%9A%84%E5%AD%A9%E5%AD%90%E8%A6%81%E8%87%AA%E5%B7%B1%E6%89%BE%E9%A2%98%E5%81%9A%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96CSCORE%E7%99%BD%E9%87%91%E7%89%88/">白金版CSCore</a></p><h2 id="Verilog-1"><a href="#Verilog-1" class="headerlink" title="Verilog:"></a>Verilog:</h2><p>1.上机前一天将课下重做一遍，保持手感。<br>2.<a href="https://hdlbits.01xz.net/wiki/Main_Page">HDLBits</a>,这是一个Verilog联系网站，类似于大一的OJ，洛谷。学有余力可以做一做这里的题，可能会有小惊喜。<br><font color="green">（笔者只在这里做了一道题，然而这道题就成为了笔者的P1上机第三题，真是世事难预料！）</font><br><img src="https://s1.ax1x.com/2022/12/29/pSp8iVJ.png" alt="HDLBits">  </p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P0 </tag>
            
            <tag> 北航计算机组成-P1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成熟的孩子要自己找题做——获取CSCore白金版</title>
      <link href="/2022/12/29/%E6%88%90%E7%86%9F%E7%9A%84%E5%AD%A9%E5%AD%90%E8%A6%81%E8%87%AA%E5%B7%B1%E6%89%BE%E9%A2%98%E5%81%9A%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96CSCORE%E7%99%BD%E9%87%91%E7%89%88/"/>
      <url>/2022/12/29/%E6%88%90%E7%86%9F%E7%9A%84%E5%AD%A9%E5%AD%90%E8%A6%81%E8%87%AA%E5%B7%B1%E6%89%BE%E9%A2%98%E5%81%9A%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96CSCORE%E7%99%BD%E9%87%91%E7%89%88/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对CSCore的Selenium学习</font></strong>  </p><h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>在北航，有这样一群人，他享有着别人所羡慕不来的东西——<font color=purple>白金版CSCore</font>,他可以查看自己的统计图，看到自己学习的时长与成果；他可以被计组邮箱推题，评测别人看不到的题。<br>我们至今未能得知白金版CSCore的来源，或许正如助教所说，这是未开发功能，只供部分人试用，又或许这是来自计组平台对于不好好做Pre的小可爱的一种Push,我们不得而知。<br>笔者很不幸运，便是普通版的一员，即使拿到了统计图的网址，点进去也会被骗到BiliBili的《never gonna give you up》。<br>然而我们是成年人了，要学会自己去获取资源，要有自己去拿到<font color=red>王者版CSCore</font>的决心与努力，因此，我们就要学习WEB自动化工具——<strong>Selenium</strong><br>当然，不学习也可以，它毕竟只是一个<strong>自动化软件</strong>，选择用勤劳的双手创造财富也可以，再不济，笔者也为大家提供了<a href="https://www.bilibili.com/video/av156766/">亡灵版CSCore</a>,点击直接使用即可~<br><img src="https://s1.ax1x.com/2022/12/29/pSSDc34.png" alt="白金版CSCore">         </p><h2 id="Selenium安装"><a href="#Selenium安装" class="headerlink" title="Selenium安装"></a>Selenium安装</h2><p>Selenium是Python的一个工具包，所以我们需要先有Python，这里笔者推荐在安装解释器时直接使用<a href="https://anaconda.org.cn/">Anaconda</a>,其为Python的集成包，集成了Python及Python主流的工具包（库）多达1500个，让你可以开始你的Python编程。<br>如果你安装了Anaconda，那么大概率Anaconda中是有Selenium的，直接使用即可。<br>如果你只是安装了Python,那么大概率你是没有Selenium的，这时候需要在控制台输入以下指令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>如果报错，请检查Python安装的正确性。</p><h2 id="浏览器驱动安装"><a href="#浏览器驱动安装" class="headerlink" title="浏览器驱动安装"></a>浏览器驱动安装</h2><p>既然Selenium是WEB自动化工具，那么我们自然需要给浏览器安装驱动程序让Python可以驱动浏览器干活，这里针对<font color=green>不同</font>的<font color=blue>浏览器</font>我们要安装不同的驱动，针对<font color=green>不同</font>的<font color=blue>浏览器</font>版本也要选择安装不同的版本。<br><strong>Firefox浏览器驱动：</strong><a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a><br><strong>Chrome浏览器驱动：</strong><a href="https://sites.google.com/a/chromium.org/chromedriver/home">chromedriver</a><br><strong>Edge浏览器驱动：</strong><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">MicrosoftWebDriver</a><br>拿<strong>Microsoft Edge</strong>举例，点击设置中的关于Microsoft Edge，我们可以看到Microsoft Edge的版本号：<br><img src="https://s1.ax1x.com/2022/12/29/pSSsESe.png" alt="Edge版本号"><br>发现开头的是108，所以我们去官网选择开头为108的驱动进行下载，后面不一样问题不大。<br><img src="https://s1.ax1x.com/2022/12/29/pSSsVQH.png" alt="Edge驱动"> </p><h2 id="正式编写针对于CSCore的代码"><a href="#正式编写针对于CSCore的代码" class="headerlink" title="正式编写针对于CSCore的代码"></a>正式编写针对于CSCore的代码</h2><h3 id="CSCore网址分析"><a href="#CSCore网址分析" class="headerlink" title="CSCore网址分析"></a>CSCore网址分析</h3><p>以上面的那道题为例，我们贴出网址如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cscore.buaa.edu.cn/#/problem?ProblemId=336&amp;PieId=896</span><br></pre></td></tr></table></figure> <p>分析看出,如果用小区做例子的话，PieId就是居民楼，ProblemId就是每一住户，我们遍历搜索每一居民楼，每一住户，问问家里是否有人（题目），便可以得到所有的隐藏题目，直升<font color = red>王者版CSCore</font>,问题来了：<br>0.Selenium让我望而却步，我<strong>不能接受</strong>。<br>1.手动改网址需要1000x1000&#x3D;10^6次，我们<strong>不能接受</strong>。<br>2.肉眼观察每一户是否有人住（有题），我们<strong>不能接受</strong>。</p><h3 id="针对CSCore编写Selenium"><a href="#针对CSCore编写Selenium" class="headerlink" title="针对CSCore编写Selenium"></a>针对CSCore编写Selenium</h3><h4 id="Solution-Zero"><a href="#Solution-Zero" class="headerlink" title="Solution Zero"></a>Solution Zero</h4><p><strong>万事开头难，其实Selenium归根结底只是Python的一个库函数，学会则极其简单。</strong><br>我们首先进行初步的设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">edge_options = Options()</span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>) <span class="comment"># 使用无头模式</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>) <span class="comment"># 禁用GPU，防止无头模式出现莫名的BUG</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;window-size=1920x1080&#x27;</span>) <span class="comment">#设置为电脑显示分辨率大小</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--start-maximized&#x27;</span>) <span class="comment">#全屏展开浏览器</span></span><br><span class="line"><span class="comment">#以上都是对于Edge的设置，若用其他浏览器同理。</span></span><br><span class="line"><span class="comment"># 开启开发者模式</span></span><br><span class="line">edge_options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line"><span class="comment"># 禁用启用Blink运行时的功能</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line"><span class="comment"># 打开Edge</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;exercise.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">driver = webdriver.Edge(options=edge_options)</span><br><span class="line">driver.maximize_window()  <span class="comment"># 窗口最大化</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐式等待10s查询元素</span></span><br><span class="line"><span class="comment">#以上是操作Edge驱动的基本过程</span></span><br></pre></td></tr></table></figure> <p><strong>强调：</strong> 无头模式运行时不会将浏览器显示出来，所以如果你想观看自动化过程，请注释掉使用无头模式这条语句。</p><h4 id="Solution-First"><a href="#Solution-First" class="headerlink" title="Solution First"></a>Solution First</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    web = <span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span></span><br><span class="line">    driver.get(<span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[1]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;xxx&quot;</span>)   <span class="comment"># 输入账号</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[2]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;XXXX&quot;</span>)  <span class="comment"># 输入密码</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&#x27;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[3]/button/span&#x27;</span>).click()</span><br></pre></td></tr></table></figure> <p>看不懂没关系，我们慢慢解释：<br>第一行是for循环标准语句，我们需要敲响1000户的们，所以范围是1000.<br>第二行是定义了个变量用来存放网址，用于后面搜到题我们往文档里写入网址。<br>第三行是Selenium功能，利用驱动打开该网址，中间str(i)对应户，我们遍历查找896号居民楼。<br>第四行到第十二行是一个特判：第一次进入CSCore,我们自然会需要登陆，这时候利用Selenium功能，捕捉元素(find_element)捕捉到登陆框，利用Selenium功能(send_keys)将“xxx”自动输入进去。之后利用Selenium功能，模拟点击(click)点击登陆，进入计组平台。之后便是<font color = blue>天高任鸟飞，海阔凭鱼跃了</font>。<br><font size = 5><font color = red>TIPS：</font></font>Selenium有很多定位元素的方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find_element_by_id()</span><br><span class="line">find_element_by_name()</span><br><span class="line">find_element_by_class_name()</span><br><span class="line">find_element_by_tag_name()</span><br><span class="line">find_element_by_link_text()</span><br><span class="line">find_element_by_partial_link_text()</span><br><span class="line">find_element_by_xpath()</span><br><span class="line">find_element_by_css_selector()</span><br></pre></td></tr></table></figure> <p>我们采用最简单准确度高的操作，Xpath定位，毕竟我们是来学计组的，够用就行。   </p><h5 id="Xpath定位法"><a href="#Xpath定位法" class="headerlink" title="Xpath定位法"></a>Xpath定位法</h5><p>打开浏览器，F12进入开发者模式，出现如图所示画面，选择元素。<br><img src="https://s1.ax1x.com/2022/12/29/pSShBhn.png" alt="XPath定位1"><br>之后我们将鼠标移到每一行上面，会发现该行元素作用的范围将会以蓝色显示出来。<br><img src="https://s1.ax1x.com/2022/12/29/pSS4iDS.png" alt="XPath定位2"><br>如图，右侧浅蓝色为我<font color = blue>鼠标停留位置</font>，左侧为定位到的<font color = blue>元素</font>，我们以CSCore的密码为例。<br>之后我们点击右键，按照下图所示复制出完整的XPath路径，<font size = 5><font color = red>一定要完整！否则定位大概率失效！</font></font><br><img src="https://s1.ax1x.com/2022/12/29/pSS4QDU.png" alt="XPath定位3">   </p><h4 id="Solution-Second"><a href="#Solution-Second" class="headerlink" title="Solution Second"></a>Solution Second</h4><p>之后我们解决第二个问题:自动判断，那么我们如何才能实现自动判断？道理也很简单，我们只需要找出没有搜到题和搜到题的不同点即可，搜到题，会出现题目，没有搜到题，则是空白界面，所以我们只需要定位一个题目任意的元素，每次判断该元素是否出现，即可实现这个功能，代码如下： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = driver.find_element(By.XPATH, <span class="string">&#x27;/html/body/div/div[1]/div[1]/div/main/div/div/div/div[1]/h2&#x27;</span>).text</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> info:</span><br><span class="line">        f.write(web) <span class="comment">#找到就将Web里的网址写入文件中</span></span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>) <span class="comment">#换行</span></span><br></pre></td></tr></table></figure>  <p><font size = 5><font color = red>TIPS：</font></font><br>如果我们只想搜编程题，则考虑搜索编程题特有的提交题目那个框。<br>如果我们全都要，那么考虑搜索题目这个元素即可。          </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><img src="https://s1.ax1x.com/2022/12/29/pSS4HGn.png" alt="结果展示"> </p><p>至此，我们完成了Selenium针对计组的学习，之后我们想实现其他的功能按照上面类似操作即可，不记得对应的语句就去百度一下。<br>如果你真的这样做了，那么恭喜你的P0-P2将一帆风顺，因为你做到了许许多多的往年考题，还有自动评测。<br><strong><font size = 4><font color = purple>恭喜获得王者版CSCore</font></font></strong>  </p><h2 id="完整源代码放送"><a href="#完整源代码放送" class="headerlink" title="完整源代码放送"></a>完整源代码放送</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.edge.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">edge_options = Options()</span><br><span class="line"><span class="comment"># 使用无头模式</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"><span class="comment"># 禁用GPU，防止无头模式出现莫名的BUG</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;window-size=1920x1080&#x27;</span>)</span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--start-maximized&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启开发者模式</span></span><br><span class="line">edge_options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line"><span class="comment"># 禁用启用Blink运行时的功能</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line"><span class="comment"># 打开Edge</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;exercise.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">driver = webdriver.Edge(options=edge_options)</span><br><span class="line">driver.maximize_window()  <span class="comment"># 窗口最大化</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐式等待10s查询元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    web = <span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span></span><br><span class="line">    driver.get(<span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[1]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;xxx&quot;</span>)   <span class="comment"># 输入账号</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[2]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;XXXX&quot;</span>)  <span class="comment"># 输入密码</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&#x27;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[3]/button/span&#x27;</span>).click()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        info = driver.find_element(By.XPATH, <span class="string">&#x27;/html/body/div/div[1]/div[1]/div/main/div/div/div/div[1]/h2&#x27;</span>).text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> info:</span><br><span class="line">            f.write(web)</span><br><span class="line">            f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure> ]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P0 </tag>
            
            <tag> 北航计算机组成-P1 </tag>
            
            <tag> 北航计算机组成-P2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>何为从代码看Logisim?</title>
      <link href="/2022/12/28/%E4%BD%95%E4%B8%BA%E4%BB%8E%E4%BB%A3%E7%A0%81%E7%9C%8BLogisim/"/>
      <url>/2022/12/28/%E4%BD%95%E4%B8%BA%E4%BB%8E%E4%BB%A3%E7%A0%81%E7%9C%8BLogisim/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对Logisim的做题思路学习</font></strong>  </p><h1 id="何为从代码看Logisim"><a href="#何为从代码看Logisim" class="headerlink" title="何为从代码看Logisim?"></a>何为从代码看Logisim?</h1><p>• MIPS中对于递归可以直接翻译C代码，那么Logisim是否可以？这就是这个问题的来源：<br>• 从代码看Logisim，即类比程设思想解决logisim问题，那么如何类比？如何解决？我想引用组合电路一种类型题——投票类型问题对其做出解释，方便大家理解，并提供解决投票问题普通投票部分的一个可行思路。当然这里我只谈思路，不谈实现，小小的抛砖引玉一波，具体怎么应用就看大家了。 </p><h1 id="Example-1-补码解决投票问题"><a href="#Example-1-补码解决投票问题" class="headerlink" title="Example 1 补码解决投票问题"></a>Example 1 补码解决投票问题</h1><h2 id="题面及分析"><a href="#题面及分析" class="headerlink" title="题面及分析"></a>题面及分析</h2><p>这是一道考试真题，大概意思是说有几个人进行投票，统计票数，要求通过输出1，不通过则输出0，这其实是一类问题，因为有时候大家权重一样进行投票，有时候大家权重不一样进行投票（一票否决），这都是会可能出的题。<br>听起来很简单的样子，但实现上其实是有一定难度的。主要难度体现在对于如何判断是否通过的输出上。下面我们谈一谈我当初的解法：    </p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>•在初看投票类型题前，如果用C的想法去解这种题该怎么解? 主体思路便是：同意为1，弃权为0，反对为-1. 加起来看是否大于0就可以了。那么既然C可以这样实现,C归根结底是在电路上运行的，那么为什么不可以尝试转化为logisim呢？<br>•有了这样的想法，首先要解决的就是加法问题，借助一点对计算机知识的了解，我们知道计算机中加法是按补码运算的，那么我们加法器有了，我们只需解决补码部分就可以。<br>•假设投票人数有7个，那么考虑到最多7人同意，7人反对，那么值的范围就在-7~7之间，所以我们可选用4位数字位+1位符号位来表示（大于5位都可 不溢出就行）,同意则为00001,弃权则为00000，反对则为11111。蛤？你补码忘记了？<font color=red>计组pre进制介绍解君愁（笑）</font><br>•但其实logisim自带了补码器，不记得的话就去手动试试<br><img src="https://s1.ax1x.com/2022/12/28/pSSpAit.png" alt="何为从代码看Logisim-1"><br>•加法问题解决~<br>•最后我们只需要把每个人的数据相加即可，用比较器和0判断一下即可，切记别习惯性点成无符号了！<br><img src="https://s1.ax1x.com/2022/12/28/pSS9ClT.png" alt="何为从代码看Logisim-6">    </p><h1 id="Example-2-从C中if和Switch到logisim"><a href="#Example-2-从C中if和Switch到logisim" class="headerlink" title="Example 2 从C中if和Switch到logisim"></a>Example 2 从C中if和Switch到logisim</h1><p>•写C最离不开的就是if语句，现在我们实现加法之后也遇到了一个问题，怎么判断输入的数据是同意，弃权，还是反对？这显然是一个switch语句，我们可以借助MUX实现:<br><img src="https://s1.ax1x.com/2022/12/28/pSSpFII.png" alt="何为从代码看Logisim-2"><br>•if的实现：如图，比较器便是if的条件判断部分，比较器的结果作用于MUX使其实现if else 功能<br><img src="https://s1.ax1x.com/2022/12/28/pSSpidA.png" alt="何为从代码看Logisim-3"><br>•体现在投票问题当中就是最后和零的判断部分：if(结果&gt;0)执行1 else执行0<br><img src="https://s1.ax1x.com/2022/12/28/pSSpPZd.png" alt="何为从代码看Logisim-4"><br>•回到例子，现在判断的问题也已经解决，我们可以顺利的从输入当中得到我们想要的信息进行运算了！离主体实现只有一步之遥。  </p><h1 id="Example-3-从C中for到logisim"><a href="#Example-3-从C中for到logisim" class="headerlink" title="Example 3 从C中for到logisim"></a>Example 3 从C中for到logisim</h1><p>•这一部分，理论上可以用计数器来实现，设置stay at value. 外加比较器相等时freeze(跳出循环）但考虑到其实logisim并没有很复杂的循环，建议果断选择Ctrl C + Ctrl V<br>•于是经过对于n个投票人的Ctrl C和Ctrl V，以及前面的一系列工作，我们得到最终主体电路，放在C中 就是 Switch 和 C的加法运算 和 if的结合 （电路自行实现~)</p><h1 id="Example-4-从C中多条件判断到Logisim"><a href="#Example-4-从C中多条件判断到Logisim" class="headerlink" title="Example 4 从C中多条件判断到Logisim"></a>Example 4 从C中多条件判断到Logisim</h1><p>•实际过程中，if往往有多个条件，那么如何解决这个问题？其实C已经给了答案&amp;或者|对应与门或者或门，这样我们也可以完成多条件判断了.<br><img src="https://s1.ax1x.com/2022/12/28/pSSpEJP.png" alt="何为从代码看Logisim-5"><br>•Tips:对于特殊投票人的特判就是这样实现的~（提供一个思路，实现就交给大家自行完成了）      </p><h1 id="Example-5-其余C语句实现"><a href="#Example-5-其余C语句实现" class="headerlink" title="Example 5 其余C语句实现"></a>Example 5 其余C语句实现</h1><p>•根据代码意思转换普通电路即可</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>•到现在为止，C语言有的语法我们都可以借助Logisim实现，那么对于一道组合逻辑题若是实在没有思路，我们可以思考怎么用C怎么实现，进而一步步转化为Logisim电路。此法名为：翻译 （默念翻译大法好） </p><h1 id="True-END"><a href="#True-END" class="headerlink" title="True END"></a>True END</h1>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在北航计算机组成总结的开头语</title>
      <link href="/2022/12/28/%E5%86%99%E5%9C%A8%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%80%BB%E7%BB%93%E7%9A%84%E5%BC%80%E5%A4%B4%E8%AF%AD/"/>
      <url>/2022/12/28/%E5%86%99%E5%9C%A8%E5%8C%97%E8%88%AA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%80%BB%E7%BB%93%E7%9A%84%E5%BC%80%E5%A4%B4%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<p><font size=5>弹剑作歌奏苦声，曳裾王门不称情</font>  </p><h1 id="获得"><a href="#获得" class="headerlink" title="获得"></a>获得</h1><p>通过阅读本博客，你可以获得：<br>• 北航计算机组成从Pre到P8的一些经验与思考<br>• 北航计算机组成一些往年题题面及class文件（侵删）<br>• 北航计算机组成实用的Mars等工具<br>• 北航计算机组成从P3到P7的自动化测试思路分享<br>• 北航计算机组成从P3到P7的所有全自动强度较高的测试化程序<br>• 北航计算机组成从P3到P8的设计文档<br>• 北航计算机组成对笔者帮助很大的学长学姐博客传送门  </p><h1 id="行文思路"><a href="#行文思路" class="headerlink" title="行文思路"></a>行文思路</h1><p>笔者希望写一些有启发性，有独特性，有更深意义的计组学习文章，所以在笔者的博客中，你将不止看到往年题，更多的可能是一些技术性，思考性的文章，也是为了避免博客的同质化。再次先谢过大家的捧场了Orz</p><h1 id="计组实验内容"><a href="#计组实验内容" class="headerlink" title="计组实验内容"></a>计组实验内容</h1><p><strong>• Pre:</strong><br>课下内容：学习Logisim,Verilog,MIPS<br>课上内容：5-10道选择&#x2F;填空题+3道编程题（Logisim,Verilog,MIPS各一道）<br>要求：3道编程题全部通过<br><strong>• P0：</strong><br>课下内容：学习Logisim状态机写法并进一步加深Logisim的学习<br>课上内容：3道Logisim编程题<br>要求：3过2<br><strong>• P1：</strong><br>课下内容：学习Verilog状态机写法并进一步加深Verilog的学习<br>课上内容：3道Verilog编程题<br>要求：3过2<br><strong>• P2：</strong><br>课下内容：学习MIPS语言<br>课上内容：3道MIPS编程题<br>要求：3过2<br><strong>• P3：</strong><br>课下内容：利用Logisim搭建单周期CPU,并添加一些基础指令。<br>课上内容：对课下所做的Logisim单周期CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong>• P4：</strong><br>课下内容：利用Verilog搭建单周期CPU,并添加一些基础指令。<br>课上内容：对课下所做的Verilog单周期CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong><font color="red">• P5：</font></strong><br>课下内容：利用Verilog搭建流水线CPU，并添加一些基础指令。<br>课上内容：对课下所做的Verilog五级流水线CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong>• P6：</strong><br>课下内容：利用Verilog对P5搭建的流水线CPU进行迭代开发，使其拥有乘除槽并添加更多指令。<br>课上内容：对课下所做的Verilog五级流水线CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong>• P7：</strong><br>课下内容：利用Verilog对P6搭建的流水线CPU进行迭代开发，使其具备异常处理功能。<br>课上内容：强测CPU正确性，强测CPU异常处理，强测CPU中断处理，添加新异常&#x2F;中断处理规则<br>要求：CPU正确性必须通过，其余3过2<br><strong><font color="red">• P8：</font></strong><br>课下内容：利用Verilog对P7搭建的流水线CPU进行迭代开发，使其成为MIPS微处理器，并进行板级验证<br>课上内容：编写MIPS程序，使得该MIPS微处理器实现新功能<br>要求：根据完成度给分</p><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>这一系列开始于笔者学完计算机组成的寒假时光，在这一学期的学习中，<font color="blue">笔者受益于助教团队们的耐心解答</font>，<font color="green">受益于计算机组成课程平台的严谨教程</font>，<font color="red">受益于各大学长学姐的博客帮助</font>，一路走来，从初学者变为学者，再到如今成为了过来人，<del>即将接受新一轮OO OS摧残的初学者</del>，笔者深感计组学习之不易，也因此想贡献自己的一份力量，这促成了这篇博客的产生。         </p><p>然，笔者已经尽量在学期中收集计算机组成实验的各种材料，可笔者真正坐在电脑前，开始写这一系列时也感受到了记忆的大量缺失，所以期望大家带有审慎的态度去观看笔者的每一篇博客，谢谢！      </p><p>作为过来人的笔者，教学谈不上，指导更谈不上，在此也就只是起一个抛砖引玉的作用，期盼大家在计算机组成上的优异表现！<br><img src="https://s1.ax1x.com/2022/12/28/pSS1kuQ.png" alt="通关图"><br><img src="https://s1.ax1x.com/2022/12/28/pSS1ABj.png" alt="AK图"><br><strong><font color="purple"><font size=5>善始善终，Pre-P8无一次不通过记录，给自己留个纪念~非常感谢助教们的帮助Orz</font></font></strong>  </p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>archives</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>北航——_____！</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>书籍</title>
      <link href="/books/index.html"/>
      <url>/books/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
