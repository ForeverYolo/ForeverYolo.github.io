<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++不常见但很好用的Api整理</title>
      <link href="/posts/25567/"/>
      <url>/posts/25567/</url>
      
        <content type="html"><![CDATA[<p>本帖持续更新</p><h1 id="algorithm库"><a href="#algorithm库" class="headerlink" title="algorithm库"></a>algorithm库</h1><h2 id="全排列函数"><a href="#全排列函数" class="headerlink" title="全排列函数"></a>全排列函数</h2><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation()"></a>next_permutation()</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>对于next_permutation函数，其函数原型为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">next_permutation</span><span class="params">(iterator start,iterator end)</span></span></span><br></pre></td></tr></table></figure> <p>当当前序列不存在下一个排列时，函数返回false，否则返回true（字典升序）</p><h3 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation()"></a>prev_permutation()</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>next_permutation() 是按照字典升序的方式生成的排列。当我们想以降序的方式生成排列时，可以使用 prev_permutation()</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p style="color: #FF0000;">下一个排列的基准以当前容器的元素顺序为准</p>   <h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; arr;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">arr.<span class="built_in">push_back</span>(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">char</span>&gt;::iterator it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>()));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a b c</span><br><span class="line">a c b</span><br><span class="line">b a c</span><br><span class="line">b c a</span><br><span class="line">c a b</span><br><span class="line">c b a</span><br></pre></td></tr></table></figure> <h2 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverse</span> <span class="params">(BidirectionalIterator first, BidirectionalIterator last)</span></span></span><br></pre></td></tr></table></figure> <h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>reverse函数用于反转在[first,last)范围内的顺序（包括first指向的元素，不包括last指向的元素），reverse函数没有返回值</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string ans</span></span><br><span class="line"><span class="function"><span class="title">reverse</span><span class="params">(ans.begin(), ans.end())</span></span>;</span><br></pre></td></tr></table></figure> <p>具体参看<a href="https://foreveryolo.github.io/posts/65270/">高精度模板</a></p><h1 id="sstream库"><a href="#sstream库" class="headerlink" title="sstream库"></a>sstream库</h1><h2 id="定行不定列输入"><a href="#定行不定列输入" class="headerlink" title="定行不定列输入"></a>定行不定列输入</h2><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>n为行数，每行有不止一个数字输入，所以用Getline得到一行数据，用空格分割<p style="color: #FF0000;">Getline有自动分割的同名函数，但输入流不能是键盘，所以我们需要用到istringstream,让Getline从isttringstream中得到数据</p> </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="built_in">getchar</span>(); <span class="comment">//吃掉n后面的回车</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="built_in">getline</span>(cin, s); <span class="comment">//getline会自动吃掉回车</span></span><br><span class="line"><span class="function">istringstream <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">string tmp;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(iss, tmp, <span class="string">&#x27; &#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; tmp;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">ss &gt;&gt; a;</span><br><span class="line">arr.<span class="built_in">push_back</span>(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">stringstream s</span><br><span class="line">s&lt;&lt;<span class="type">int</span></span><br><span class="line">s&gt;&gt;string</span><br></pre></td></tr></table></figure> <h2 id="string转int"><a href="#string转int" class="headerlink" title="string转int"></a>string转int</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">stringstream s</span><br><span class="line">s&lt;&lt;string</span><br><span class="line">s&gt;&gt;<span class="type">int</span></span><br></pre></td></tr></table></figure> <h1 id="string库"><a href="#string库" class="headerlink" title="string库"></a>string库</h1><h2 id="find-first-not-of"><a href="#find-first-not-of" class="headerlink" title="find_first_not_of()"></a>find_first_not_of()</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">( <span class="type">const</span> basic_string &amp;str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, size_type index = <span class="number">0</span> )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">( <span class="type">const</span> <span class="type">char</span> *str, size_type index, size_type num )</span></span>;</span><br><span class="line"><span class="function">size_type <span class="title">find_first_not_of</span><span class="params">( <span class="type">char</span> ch, size_type index = <span class="number">0</span> )</span></span>;</span><br></pre></td></tr></table></figure> <h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nops<br>在字符串中查找第一个与str中的字符都不匹配的字符，返回它的位置。搜索从index开始，最多查找num个字符。如果没找到就返回string::nops<br>在字符串中查找第一个与ch不匹配的字符，返回它的位置。搜索从index开始。如果没找到就返回string::nops</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>) 找到第一个不是<span class="number">0</span>的位置</span><br></pre></td></tr></table></figure> <p>具体参看<a href="https://foreveryolo.github.io/posts/65270/">高精度模板</a></p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>使用string ans(数量, ‘0’)可以直接初始化asn为数量长，全部填充0</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级语言 </tag>
            
            <tag> 奇技淫巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正整数C++高精度模板</title>
      <link href="/posts/65270/"/>
      <url>/posts/65270/</url>
      
        <content type="html"><![CDATA[<h1 id="前置函数"><a href="#前置函数" class="headerlink" title="前置函数"></a>前置函数</h1><h2 id="数学取模"><a href="#数学取模" class="headerlink" title="数学取模"></a>数学取模</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x % mod + mod) % mod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmp</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a.<span class="built_in">length</span>() &lt; b.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="int转string"><a href="#int转string" class="headerlink" title="int转string"></a>int转string</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">i2s</span><span class="params">(<span class="type">int</span>&amp; x,string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream ss;</span><br><span class="line">    ss &lt;&lt; x;</span><br><span class="line">    ss &gt;&gt; s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用代码模拟小学所学的竖式加/减<br>将乘除转化为加/减</p><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Myadd</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//a = a.substr(a.find_first_not_of(&#x27;0&#x27;));</span></span><br><span class="line">    <span class="comment">//b = b.substr(b.find_first_not_of(&#x27;0&#x27;));</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        len = a.<span class="built_in">length</span>() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = b.<span class="built_in">length</span>() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">string <span class="title">ans</span><span class="params">(len, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; b.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += (ans[i] - <span class="string">&#x27;0&#x27;</span>) + (b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans[i] = tmp % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp += (ans[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans[i] = tmp % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = ans.<span class="built_in">substr</span>(ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Mysub</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(a, b)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        string tmp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//a = a.substr(a.find_first_not_of(&#x27;0&#x27;));</span></span><br><span class="line">    <span class="comment">//b = b.substr(b.find_first_not_of(&#x27;0&#x27;));</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">length</span>() &gt; b.<span class="built_in">length</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        len = a.<span class="built_in">length</span>() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        len = b.<span class="built_in">length</span>() + <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">string <span class="title">ans</span><span class="params">(len, <span class="string">&#x27;0&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; b.<span class="built_in">length</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            tmp += (ans[i] - <span class="string">&#x27;0&#x27;</span>) - (b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans[i] = <span class="built_in">Mod</span>(tmp,<span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            tmp = (tmp - <span class="number">9</span>) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp += (ans[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            ans[i] = <span class="built_in">Mod</span>(tmp, <span class="number">10</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            tmp = (tmp - <span class="number">9</span>) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>) != string::npos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>) - <span class="number">1</span>] = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = ans.<span class="built_in">substr</span>(ans.<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;0&#x27;</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Mymul</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string cnt;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="keyword">while</span> (cnt != b)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">Myadd</span>(ans, a);</span><br><span class="line">        cnt = <span class="built_in">Myadd</span>(cnt, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Mydiv</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cmp</span>(a, b) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">Mysub</span>(a, b);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    string ans;</span><br><span class="line">    <span class="built_in">i2s</span>(cnt, ans);</span><br><span class="line">    ans.<span class="built_in">append</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">101</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        a.<span class="built_in">append</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(a, b) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a.<span class="built_in">append</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            ans.<span class="built_in">append</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">cmp</span>(a, b) &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">             a = <span class="built_in">Mysub</span>(a, b);</span><br><span class="line">             t++;</span><br><span class="line">        &#125;</span><br><span class="line">        string t_str;</span><br><span class="line">        <span class="built_in">i2s</span>(t, t_str);</span><br><span class="line">        ans.<span class="built_in">append</span>(t_str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">Mymod</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cmp</span>(a, b) &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">Mysub</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高级语言 </tag>
            
            <tag> 算法模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>由波动数列对高级语言取模的思考</title>
      <link href="/posts/54458/"/>
      <url>/posts/54458/</url>
      
        <content type="html"><![CDATA[<h1 id="波动数列"><a href="#波动数列" class="headerlink" title="波动数列"></a>波动数列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>观察这个数列：</p>$$1,3,0,2, - 1,1, - 2$$<p>这个数列中后一项总是比前一项增加2或者减少3。<br>栋栋对这种数列很好奇，他想知道长度为n或为s而且后一项总是比前一项增加a或者减少b的整数数列可能有多少种呢？</p><h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入的第一行包含四个整数n,s,a,b,含义如前面所述，其中：</p>$$1 \le n \le 1000, - {10^{^9}} \le s \le {10^9},1 \le a,b \le {10^6}$$<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出一行，包含一个整数，表示满足条件的方案数。由于这个数很大，请输出方案数除以 $ {10^8}{\rm{ + }}7 $ 的余数。</p><h1 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h1><h2 id="第一层（10分）"><a href="#第一层（10分）" class="headerlink" title="第一层（10分）"></a>第一层（10分）</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>考虑极限情况：</p>$$\eqalign{  & {\rm{x,x}} + a,x + 2a,x + 3a,...x + (n - 1)a = nx + {{n(n - 1)} \over 2}a = s  \cr   & x,x - b,x - 2b,x - 3b,...x - (n - 1)b = nx - {{n(n - 1)} \over 2}b = s \cr} $$<p>一式中x为最小值，二式中x为最大值，由此得到x的范围，进而可以枚举每一个x进行DFS</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, s, a, b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cnt, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum == s)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans &gt; MOD)</span><br><span class="line">&#123;</span><br><span class="line">ans %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(x + a, cnt + <span class="number">1</span>, sum + x + a);</span><br><span class="line"><span class="built_in">dfs</span>(x - b, cnt + <span class="number">1</span>, sum + x - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x1 = s / n - a * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x2 = <span class="number">1</span> + s / n + b * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = x1; x &lt;= x2; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs</span>(x, <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">slove</span>();</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="第二层（20分）"><a href="#第二层（20分）" class="headerlink" title="第二层（20分）"></a>第二层（20分）</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>对枚举数量进行缩减，将a,b一同看为p,原式合并为：</p>$${\rm{x,x}} + p,x + 2p,x + 3p,...x + (n - 1)p = nx + {{n(n - 1)} \over 2}p = s$$<p>所以a,b共有${{n(n - 1)} \over 2}$个，选定x,在DFS前枚举a的个数,如果所有a都不能满足$nx + {t_a}a - ({{n(n - 1)} \over 2} - {t_a})b = s$，则不进行对此x的DFS。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, s, a, b;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cnt, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (cnt == n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum == s)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ans &gt; MOD)</span><br><span class="line">&#123;</span><br><span class="line">ans %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(x + a, cnt + <span class="number">1</span>, sum + x + a);</span><br><span class="line"><span class="built_in">dfs</span>(x - b, cnt + <span class="number">1</span>, sum + x - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">slove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t = n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x1 = s / n - a * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> x2 = <span class="number">1</span> + s / n + b * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = x1; x &lt;= x2; x++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> cntA = <span class="number">0</span>; cntA &lt;= t; cntA++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> cal = x * n + cntA * a - (t - cntA) * b;</span><br><span class="line"><span class="keyword">if</span> (cal == s)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs</span>(x, <span class="number">1</span>, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n)</span> </span>&#123; <span class="keyword">return</span> (x % n + n) % n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; s &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">slove</span>();</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h2 id="第三层（100分）"><a href="#第三层（100分）" class="headerlink" title="第三层（100分）"></a>第三层（100分）</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>令：</p>$${{n(n - 1)} \over 2}p = z$$<p>原式解出x:</p>$$x = {{s - z} \over n}$$<p>由于x作为首项，必为整数，所以得到：</p>$$s = z(\bmod n)$$<p>即s与z同余。<br>现在我们将p再次转化为f[i]={a,b},原式可写为：<br>$$x,x + f[1],x + f[1] + f[2],x + f[1] + f[2] + f[3],...,x + f[1] + ... + f[n - 1]$$</p><p>合并后为：</p>$$nx + (n - 1)f[1] + (n - 2)f[2] + ... + f[n - 1] = s$$<p>由前面同余的关系，两边取模：</p>$$( - f[1] - 2f[2]... - f[n - 1])\% n = s\% n$$ <p>取反：</p>$$( f[1] + 2f[2]... + f[n - 1])\% n = (-s)\% n$$ <p>因此我们可以对f[1]-f[n-1]进行动态规划：</p>$$dp[i][j] = dp[i][j - i \times a] + dp[i][j + i \times b]$$<p>dp[i][j]表示前i项余数为j的组合数。<br>最后我们取dp[n-1][(-s)%n]即可得解。</p><h3 id="问题产生"><a href="#问题产生" class="headerlink" title="问题产生"></a>问题产生</h3><h4 id="取模异常"><a href="#取模异常" class="headerlink" title="取模异常"></a>取模异常</h4><p>笔者在查阅题解时发现题解中对于取模并不是直接取模，而是进行了这样的操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (x % n + n) % n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p>而使用Python3的选手则是像思路那样直接取模。</p><p>笔者对此十分的不理解，起初认为是忽略了题目的条件，经过几个小时的查阅笔者找到了这样做的理由：与数学取模保持一致/维护数组下标大于0。</p><h4 id="数学取模"><a href="#数学取模" class="headerlink" title="数学取模"></a>数学取模</h4><p>定义：如果a和d是两个自然数，d非零，可以证明存在两个唯一的整数q和r，满足a = qd+r 且（0 &lt;= r &lt; d&gt;。其中，q被称为商,r被称为余数。<br>所以对于（-7）%3,答案应该是2。  </p><p style="color: #FF0000;">但高级语言并不一定为2</p>    <p>C++：cout&lt;&lt;(-7)%3;//输出为-1    </p><p>Java:System.out.println((-7)%3);//输出为-1      </p><p>Python:print((-7)%3)//输出为2   </p><p>结果让我大跌眼镜，查阅资料得知，C++和Java通常会让<b>商大一点</b>，Python通常会让<b>商小一点</b>。所以C++和Java商为-2.Python为-3，进而导致了结果的不同。 </p><p>所以，为了和我们的认知——数学取模保持一致，我们利用Mod(int x)这个函数让C++的取模和Python和数学取模保持了一致。这也就回答了为什么C++有一种多此一举的感觉。    </p><p>但是其实，从另一个角度想，就算C++不这样取模，难道答案就会错吗？有没有可能这样做只是为了维护下标大于0？<p style="color: #FF0000;">确实会错</p>  </p><p>这是在C++下直接取模（下标同+1000）：</p><p><img src="错误答案.png" alt="错误答案">   </p><p>这是在C++下函数取模：<br><img src="正确答案.png" alt="正确答案"></p><p>所以，做题还是严格按照数学取模来叭</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e3</span>+<span class="number">3</span>,mod=<span class="number">1e8</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> n,dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Mod</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> (x%n+n)%n;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> s,a,b; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;s,&amp;a,&amp;b);</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">dp[i][j]=(dp[i<span class="number">-1</span>][<span class="built_in">Mod</span>(j-a*i)]+dp[i<span class="number">-1</span>][<span class="built_in">Mod</span>(j+b*i)])%mod;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[n<span class="number">-1</span>][<span class="built_in">Mod</span>(s)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 高级语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法——数论整理</title>
      <link href="/posts/2344/"/>
      <url>/posts/2344/</url>
      
        <content type="html"><![CDATA[<p>本帖持续更新<br><strong><font size = 5>这是编程算法计算加速总结</font></strong></p><h1 id="快速乘法"><a href="#快速乘法" class="headerlink" title="快速乘法"></a>快速乘法</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>假设当前计算a*b,应用二进制，将a,b中较大的一位数转化为二进制表示，例如11转化为1011，然后类比利用竖式计算乘法那样，用较小的数乘以每一位代表的2次幂，最后相加。</p><h2 id="加速点"><a href="#加速点" class="headerlink" title="加速点"></a>加速点</h2><p>乘法转为logn量级的乘法+加法</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="无取模"><a href="#无取模" class="headerlink" title="无取模"></a>无取模</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Imul</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = x + a;</span><br><span class="line">&#125;</span><br><span class="line">a = a * <span class="number">2</span>;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Imul</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> b,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> tmp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = (x + a) % mod;</span><br><span class="line">&#125;</span><br><span class="line">a = (a * <span class="number">2</span>) % mod;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>类似于快速乘法，同样利用二进制，这里利用的是幂次的二进制位。<br>例如： $ 7^{11} $ ,幂次的二进制位为:1011，因而可以拆分为：  ${7^8} \times {7^2} \times 7$  ，而这些幂次都可通过7的不断自乘得到。只需乘6次即可得到结果。</p><h2 id="加速点-1"><a href="#加速点-1" class="headerlink" title="加速点"></a>加速点</h2><p>利用二进制的特性，直接不断自乘本身即可得到结果，可以跳过一些次幂的运算。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">M* <span class="title">Mpow</span><span class="params">(M* m, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">M* ans = <span class="keyword">new</span> <span class="built_in">M</span>(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans = <span class="built_in">Mmul</span>(ans, m, mod);</span><br><span class="line">&#125;</span><br><span class="line">m = <span class="built_in">Mmul</span>(m, m, mod);</span><br><span class="line">n = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="快速斐波那契数列"><a href="#快速斐波那契数列" class="headerlink" title="快速斐波那契数列"></a>快速斐波那契数列</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2>$$\left[ {\matrix{   {f(2)} & {f(1)}  \cr    0 & 0  \cr  } } \right] \times {\left[ {\matrix{   1 & 1  \cr    1 & 0  \cr  } } \right]^{n - 2}} = \left[ {\matrix{   {f(n)} & {f(n - 1)}  \cr    0 & 0  \cr  } } \right]$$ <p>其中， ${\left[ {\matrix{   1 & 1  \cr    1 & 0  \cr  } } \right]^{n - 2}}$可以用快速幂计算</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">fib</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">M* A = <span class="keyword">new</span> <span class="built_in">M</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">M* B = <span class="keyword">new</span> <span class="built_in">M</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">M* ans = <span class="built_in">Mmul</span>(A, <span class="built_in">Mpow</span>(B, i - <span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> ans-&gt;data[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <h1 id="快速斐波那契求和"><a href="#快速斐波那契求和" class="headerlink" title="快速斐波那契求和"></a>快速斐波那契求和</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2>$$\sum\limits_{i = 1}^n {f(i)}  = f(n + 2) - 1$$<h1 id="买不到的数目"><a href="#买不到的数目" class="headerlink" title="买不到的数目"></a>买不到的数目</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小明开了一家糖果店。他别出心裁：把水果糖包成 4 颗一包和 7 颗一包的两种。糖果不能拆包卖。<br>小朋友来买糖的时候，他就用这两种包装来组合。当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。<br>你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是 17。大于 17 的任何数字都可以用 4 和 7 组合出来。<br>本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><h3 id="对于方程"><a href="#对于方程" class="headerlink" title="对于方程"></a>对于方程</h3><script type="math/tex; mode=display">{\rm{ax}} + by = c</script><p>1.a,b互质，一定有解且解的数目无穷<br>2.C是gcd(a,b)的倍数，方程一定有解，且有无穷多解    </p><h3 id="对于本题"><a href="#对于本题" class="headerlink" title="对于本题"></a>对于本题</h3><p>最大不能组合出的数字：n*m-n-m</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIPS微系统设计注意事项</title>
      <link href="/posts/39608/"/>
      <url>/posts/39608/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P8的一些注意事项</font></strong></p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>如果大家是以P8课下的身份来到这个，笔者首先恭喜大家来到P8，计组实验最终回。<br>P8，是笔者认为debug de起来最痛苦的一个Project,没有之一。这是因为<font color="red">P8作为板级验证的Project，是最接近硬件的一个Project,而硬件Bug一般是难以定位的。</font> </p><font color="purple">特别是ISE十分万恶，有些不可综合的语句不会给你做出相关警报，只会一声不吭的切割掉整个CPU,然后让你的CPU上板则寄，笔者被活活折磨了好几天</font></br><font color="green">因此，笔者认为出一篇注意事项的博客是很有必要的，话不多说，Here We Go!</font>    <h1 id="不可综合"><a href="#不可综合" class="headerlink" title="不可综合"></a>不可综合</h1><p>在Verilog中，有很多语句是不可综合的，我们在P8要避免出现这种情况。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>（1）不使用initial。</strong><br>（2）不使用#10。<br>（3）不使用循环次数不确定的循环语句，如forever、while等。<br>（4）不使用用户自定义原语（UDP元件）。<br>（5）尽量使用同步方式设计电路。<br>（6）除非是关键路径的设计，一般不采用调用门级元件来描述设计的方法，建议采用行为语句来完成设计。<br><strong>（7）用always过程块描述组合逻辑，应在敏感信号列表中列出所有的输入信号。</strong><br>（8）所有的内部寄存器都应该能够被复位，在使用FPGA实现设计时，应尽量使用器件的全局复位端作为系统总的复位。<br><strong>（9）对时序逻辑描述和建模，应尽量使用非阻塞赋值方式。对组合逻辑描述和建模，既可以用阻塞赋值，也可以用非阻塞赋值。但在同一个过程块中，最好不要同时用阻塞赋值和非阻塞赋值。</strong><br><strong>（10）不能在一个以上的always过程块中对同一个变量赋值。而对同一个赋值对象不能既使用阻塞式赋值，又使用非阻塞式赋值。</strong><br>（11）如果不打算把变量推导成锁存器，那么必须在if语句或case语句的所有条件分支中都对变量明确地赋值。<br>（12）避免混合使用上升沿和下降沿触发的触发器。<br>（13）同一个变量的赋值不能受多个时钟控制，也不能受两种不同的时钟条件（或者不同的时钟沿）控制。<br><strong>（14）避免在case语句的分支项中使用x值或z值。</strong></p><h2 id="不可综合语句"><a href="#不可综合语句" class="headerlink" title="不可综合语句"></a>不可综合语句</h2><p>（1）initial<br>只能在test bench中使用，不能综合。<br>（2）events<br>event在同步test bench时更有用，不能综合。<br>（3）real<br>不支持real数据类型的综合。<br>（4）time<br>不支持time数据类型的综合。<br>（5）force 和release<br>不支持force和release的综合。<br>(6）assign 和deassign<br>不支持对reg 数据类型的assign或deassign进行综合，支持对wire数据类型的assign或deassign进行综合。<br>(7) fork join<br>不可综合，可以使用非块语句达到同样的效果。<br>(8) primitives<br>支持门级原语的综合，不支持非门级原语的综合。<br>(9) table<br>不支持UDP 和table的综合。<br><strong>(10) 敏感列表里同时带有posedge和negedge</strong><br>如：always @(posedge clk or negedge clk) begin…end<br>这个always块不可综合。<br>(11) 同一个reg变量被多个always块驱动<br>(12) 延时<br>以#开头的延时不可综合成硬件电路延时，综合工具会忽略所有延时代码，但不会报错。<br>如：a=#10 b;<br>这里的#10是用于仿真时的延时，在综合的时候综合工具会忽略它。也就是说，在综合的时候上式等同于a=b;<br><strong>(13) 与X、Z的比较</strong><br>可能会有人喜欢在条件表达式中把数据和X(或Z)进行比较，殊不知这是不可综合的，综合工具同样会忽略。所以要确保信号只有两个状态：0或1。</p><font color="green">这个是最坑的，笔者就是死在了这里，一定不能用“!==”和“===”，这个综合错误ISE不会报出，因此极难De出</font> <h2 id="文末"><a href="#文末" class="headerlink" title="文末"></a>文末</h2><p>以上转载自<a href="https://zhuanlan.zhihu.com/p/146034068">https://zhuanlan.zhihu.com/p/146034068</a> ，侵删</p><h1 id="回显少值"><a href="#回显少值" class="headerlink" title="回显少值"></a>回显少值</h1><p><img src="回显少值.png" alt="数据示意1"><br>本来是4个5，但回显只有3个5，有时候有4个5，这个bug也是比较难以处理，经过对于UART_tx和UART_rx的研究，意识到丢5的可能性只能在于我原先的设计中，命令UART_tx发送的开始信号只有一周期，不管UART_tx什么状态，所以可能出现UART_tx不处于IDLE状态而给UART_tx一个开始信号，这时候这个开始信号将被忽略，导致本次发送被忽略，所以更改代码，利用UART_avi信号，开始信号将一直置高，直到UART_avi有效，这时候可以表明这个开始信号一定会被接收，所以可以放心置0，解决了这个问题。</p><h1 id="强制板子下线"><a href="#强制板子下线" class="headerlink" title="强制板子下线"></a>强制板子下线</h1><p>（然后这个板子就会消失在可选列表中10-15分钟不等）<br><strong>注意</strong>，此种现象的发生并非网络问题，而是源于串口短时间内回显大量数据，炸掉了串口缓冲区导致的板子崩溃下线，之所以发生这个问题是由于，Req处理的不合理导致的，如图：<br><img src="问题出现.png" alt="数据示意1"><br>仔细观察，会发现D_PC为0x4180时，会出现两条指令，若前面那条指令没有在D级执行的操作，则无需考虑，反正到E级时候会被清掉，但若此指令如图中一般是在D级就有操作的beq指令，则该beq仍会执行，而众所周知beq的跳转其实只是相对位置，所以他会在0x4180上进行错误跳转，导致程序出错，为了解决这个问题，我同样同步化了Req信号用来控制ID_Instr_Real，代码如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">reg</span> Delay_Stall_sign;</span><br><span class="line">    <span class="keyword">reg</span> Delay_Req_sign;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(reset||Req) <span class="keyword">begin</span></span><br><span class="line">        Delay_Stall_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">  Delay_Req_sign &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line">        ID_Instr_MEM &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Stall_sign)  <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span>(Delay_Stall_sign) <span class="keyword">begin</span></span><br><span class="line">ID_Instr_MEM &lt;=  ID_Instr_MEM; </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">ID_Instr_MEM &lt;= ID_Instr_Wire;  </span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">        Delay_Stall_sign &lt;= <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        ID_Instr_MEM &lt;= ID_Instr_Wire; </span><br><span class="line">        Delay_Stall_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">  Delay_Req_sign &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] ID_Instr_Wire;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] ID_Instr_MEM;</span><br><span class="line">    <span class="keyword">assign</span> ID_Instr_Wire = F_Instr;</span><br><span class="line">    <span class="keyword">assign</span> ID_Instr_Real =  (F_PC == <span class="number">32&#x27;h3000</span> || Delay_Req_sign) ? <span class="number">32&#x27;d0</span> :</span><br><span class="line">(Delay_Stall_sign) ? ID_Instr_MEM : ID_Instr_Wire;</span><br><span class="line">解决后如图，在进入异常处理程序时，第一个错误指令将被抹除，变为<span class="number">32&#x27;d0</span>：</span><br></pre></td></tr></table></figure><br><img src="问题解决.png" alt="数据示意1"> </p><h1 id="回显异常和计时器异常冲突"><a href="#回显异常和计时器异常冲突" class="headerlink" title="回显异常和计时器异常冲突"></a>回显异常和计时器异常冲突</h1><p>在实现计时器功能时，若采用TC模块，则不得不考虑一个问题，由于UART回显必须全过程支持，所以回显通过异常实现，当接受完毕时，UART模块产生中断信号执行回显指令，但TC也会在每一秒产生中断信号，在异常处理程序中实现计数减1，输出到数码管等工作，但异常程序入口只有一个，那就是0x4180，若不做处理，则不管谁发出中断信号，两个中断处理程序都将处理一遍，那么现在就需要一个信号甄别这个中断到底是谁引起的，环顾CP0，发现没有这种信号，唯一有可能的HWINT是每周期都会更新，根本来不及接受它的值，所以，我对CP0进行了<strong>魔改</strong>，将HWINT转变为了只会在进入异常程序时更新，这样，我们可以通过Cause寄存器哪一位置为1找出当前中断是谁引起的，用beq进行区分，防止中断进行互相干扰，有了区分的数据，我们的问题便得到了解决。<br><img src="魔改CP0.png" alt="数据示意1"> </p><h1 id="接入乘除法器与外设驱动模块注意事项"><a href="#接入乘除法器与外设驱动模块注意事项" class="headerlink" title="接入乘除法器与外设驱动模块注意事项"></a>接入乘除法器与外设驱动模块注意事项</h1><h2 id="接入乘除法器"><a href="#接入乘除法器" class="headerlink" title="接入乘除法器"></a>接入乘除法器</h2><p>删去原有的MDU中乘除执行语句，主要是包含“<em>“与“/”的语句，因为他们不可综合，之后将教程所给的乘除按<strong>E_MDU-&gt;MulDivUnit-&gt;MulUnit</strong>和<em>*E_MDU-&gt;MulDivUnit-&gt;DivUnit</em></em>的结构生成模块并复制导入，如图：<br><img src="层次结构.png" alt="数据示意1"><br>之后则根据接口进行连线，将顶层MulDivUnit所需信号在E_MDU生成接入即可，如图：<br><img src="E_MDU.png" alt="数据示意1"><br>连线的时候其实无需做太大的改动，只需意识到原来乘法除法语句让MulDivUnit模块执行，相当于一个等价替换，即可做最小的改动。</p><h2 id="接入外设驱动模块"><a href="#接入外设驱动模块" class="headerlink" title="接入外设驱动模块"></a>接入外设驱动模块</h2><p>P7已经做下了很好的铺垫，只需继续在系统桥上添加新接口即可，如图：<br><img src="系统桥.png" alt="数据示意1"><br>我们要做的不过是延长代码,但事情显然不会这么简单，注意到DM也是接在Bridge上的，但DM已经今非昔比，它变成了一个时序模块，即需要Clk信号，<br><img src="总图.png" alt="数据示意1"><br>在上升沿才能读出数据，如果只是按原来的处理，其余外设正常工作，DM会出问题，因为他的读已经区别于了其他模块，为了消除这种区别，我直接将所有的模块读全部变为了同步读。实现如下：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(reset) <span class="keyword">begin</span></span><br><span class="line">TC1_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">UART_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">Digital_Tube_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">Switch_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">User_Key_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">LED_RD_S &lt;= <span class="number">0</span>;</span><br><span class="line">HitTC1_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitDM_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitUART_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitDigital_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitSwitch_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitUserKey_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">HitLED_S &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">TC1_RD_S &lt;= TC1_RD;</span><br><span class="line">UART_RD_S &lt;= UART_RD;</span><br><span class="line">Digital_Tube_RD_S &lt;= Digital_Tube_RD;</span><br><span class="line">Switch_RD_S &lt;= Switch_RD;</span><br><span class="line">User_Key_RD_S &lt;= User_Key_RD;</span><br><span class="line">LED_RD_S &lt;= LED_RD;</span><br><span class="line">HitTC1_S &lt;= HitTC1;</span><br><span class="line">HitDM_S &lt;= HitDM;</span><br><span class="line">HitUART_S &lt;= HitUART;</span><br><span class="line">HitDigital_S &lt;= HitDigital;</span><br><span class="line">HitSwitch_S &lt;= HitSwitch;</span><br><span class="line">HitUserKey_S &lt;= HitUserKey;</span><br><span class="line">HitLED_S &lt;= HitLED;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br>我将所有HitXX信号都存了一周期，将除了DM的读出数据都存了一周期，让本来在上一周期读出的数据读出在了下一周期，这样人为的将除了DM之外的外设变成了同步读，和DM行为同步，保证了系统桥稳定正确工作。<br>唯一特殊的就是UART，但类似于MDU的处理，生成了<strong>UART-&gt;UART_TX</strong>和<strong>UART-&gt;UART_RX</strong>的结构，连线在UART完成，即可归一化解决UART的问题。如图：<br><img src="UART.png" alt="数据示意1"> </p><h1 id="优化技巧"><a href="#优化技巧" class="headerlink" title="优化技巧"></a>优化技巧</h1><h3 id="1-拒绝过度优化"><a href="#1-拒绝过度优化" class="headerlink" title="1.拒绝过度优化"></a>1.拒绝过度优化</h3><p>如果实在是害怕优化使得CPU功能出现错误，可以加入(*KEEP = “TRUE”*)在寄存器，wire前面，则综合时不管这个寄存器或者线路多没用，综合器也不会将其优化掉。<br><img src="KEEP.png" alt="数据示意1"></p><h3 id="2-调教（bushi-ISE"><a href="#2-调教（bushi-ISE" class="headerlink" title="2.调教（bushi)ISE"></a>2.调教（bushi)ISE</h3><p><img src="ISE设置.png" alt="数据示意1"><br>如上所示，右键XST将优化调整如上可以保留层次结构，避免一些不同层次相同命名去掉层次结构时可能引起的冲突问题。</p><h1 id="自动生成IP核可用-coe文件"><a href="#自动生成IP核可用-coe文件" class="headerlink" title="自动生成IP核可用.coe文件"></a>自动生成IP核可用.coe文件</h1><p>这是一个用Python实现的小玩意，运行此程序可以将同一目录下的test.asm转换成IP核可用的test.coe，且直接存放到ipcore_dir目录下，便于选择。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>更改dir_name_3目录为自己CPU的ipcore_dir即可</p><h2 id="代码呈现"><a href="#代码呈现" class="headerlink" title="代码呈现"></a>代码呈现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> filestools</span><br><span class="line"><span class="keyword">from</span> filediff.diff <span class="keyword">import</span> file_diff_compare</span><br><span class="line">dir_name_3 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P8\\The End\\FlowCpu\\ipcore_dir\\&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mar</span>(<span class="params">test_order</span>):</span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText a dump .text HexText machine.txt nc test.asm&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText a dump 0x00004180-0x00006000 HexText handler.txt nc test.asm&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;机器码合成.exe&quot;</span>)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;code.coe&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name_3 + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.coe&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText nc db lg ex me 65536 test.asm &gt; mar.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">run_mar(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="Mar代码"><a href="#Mar代码" class="headerlink" title="Mar代码"></a>Mar代码</h1><p>2022年P8要求实现功能：在一个Mars文件中同时实现计算器，计时器并全程带有串口回显功能。代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">#PC 初始值0x3000</span><br><span class="line">#异常中断入口0x4180</span><br><span class="line">#数据存储器0x0000 - 0x2FFF</span><br><span class="line">#指令存储器0x3000 - 0x6FFF</span><br><span class="line">#定时器        0x7F00 - 0x7F0B</span><br><span class="line">#UART        0x7F30 - 0x7F3F</span><br><span class="line">#数码管        0x7F50 - 0x7F57</span><br><span class="line">#拨码开关       0x7F60 - 0x7F67</span><br><span class="line">#按键开关        0x7F68 - 0x7F6B</span><br><span class="line">#LED        0x7F70 - 0x7F73</span><br><span class="line">.text</span><br><span class="line">#打开中断</span><br><span class="line">ori $t1,0x1100</span><br><span class="line">sw $t1,0x7F70($0)</span><br><span class="line">nop</span><br><span class="line">ori $t3,0XFC01</span><br><span class="line">mtc0 $t3,$12</span><br><span class="line"></span><br><span class="line">#模式切换</span><br><span class="line">lw $s3,0x7F68($0)</span><br><span class="line">andi $s6,$s3,3</span><br><span class="line">li $s0,1</span><br><span class="line">li $s1,2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bne $s6,$s0,cal</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">tim:</span><br><span class="line">#计时器模式</span><br><span class="line">li $t7,0</span><br><span class="line">li $t3,25000000 #配置1s</span><br><span class="line">sw $t3,0x7F04($0) #配置1s</span><br><span class="line">li $t3,0xB #配置计时器</span><br><span class="line">sw $t3,0x7F00($0) #配置计时器</span><br><span class="line">lw $s4,0x7F60($0) #读入计时数据</span><br><span class="line">move $t4,$s4 #复制计时数据</span><br><span class="line">andi $s7,$s3,4</span><br><span class="line">beq $s7,$0,Adda_1</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#减法最大数</span><br><span class="line">Suba_1:</span><br><span class="line">sw $s4,0x7F50($0)</span><br><span class="line">jal wait</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#加法最大数</span><br><span class="line">Adda_1:</span><br><span class="line">sw $0,0x7F50($0)</span><br><span class="line">jal wait</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#判断初值是否改变</span><br><span class="line">Judge:</span><br><span class="line">lw $s7,0x7F60($0)</span><br><span class="line">beq $s7,$s4,wait</span><br><span class="line">nop</span><br><span class="line">jal tim</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#等待中断</span><br><span class="line">wait:</span><br><span class="line">beq $0,$0,wait</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#计时结束</span><br><span class="line">jal end_time</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#结束标志</span><br><span class="line">end_time:</span><br><span class="line">ori $t1,$0,1</span><br><span class="line">sw $t1,0x7F70($0)</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#结尾循环</span><br><span class="line">end_1:beq $0,$0,end_1</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cal:</span><br><span class="line">bne $s6,$s1,end</span><br><span class="line">nop</span><br><span class="line">#计算器模式</span><br><span class="line">calc:</span><br><span class="line">andi $s6,$s3,0XFC</span><br><span class="line">addu $a1,$s6,$0</span><br><span class="line">lw $t1,0x7F64($0)</span><br><span class="line">lw $t2,0x7F60($0)</span><br><span class="line">#加</span><br><span class="line">addd:</span><br><span class="line">li $a0,4</span><br><span class="line">bne $s6,$a0,subb</span><br><span class="line">nop</span><br><span class="line">addu $t3,$t1,$t2</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#减</span><br><span class="line">subb:</span><br><span class="line">li $a0,8</span><br><span class="line">bne $s6,$a0,multt</span><br><span class="line">nop</span><br><span class="line">subu $t3,$t1,$t2</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#乘</span><br><span class="line">multt:</span><br><span class="line">li $a0,16</span><br><span class="line">bne $s6,$a0,divv</span><br><span class="line">nop</span><br><span class="line">mult $t1,$t2</span><br><span class="line">mflo $t3</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#除</span><br><span class="line">divv:</span><br><span class="line">li $a0,32</span><br><span class="line">bne $s6,$a0,andd</span><br><span class="line">nop</span><br><span class="line">div $t1,$t2</span><br><span class="line">mflo $t3</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#与</span><br><span class="line">andd:</span><br><span class="line">li $a0,64</span><br><span class="line">bne $s6,$a0,orr</span><br><span class="line">nop</span><br><span class="line">and $t3,$t1,$t2</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#或</span><br><span class="line">orr:</span><br><span class="line">li $a0,128</span><br><span class="line">bne $s6,$a0,end_cal</span><br><span class="line">nop</span><br><span class="line">or $t3,$t1,$t2</span><br><span class="line">jal output</span><br><span class="line">nop</span><br><span class="line">#输出结果</span><br><span class="line">output:</span><br><span class="line">sw $t3,0x7F50($0)</span><br><span class="line"></span><br><span class="line">#计算结束</span><br><span class="line">end_cal:</span><br><span class="line">lw $s3,0x7F68($0)</span><br><span class="line">andi $s6,$s3,0XFC</span><br><span class="line">beq $s6,$a1,nochange</span><br><span class="line">nop</span><br><span class="line">beq $s6,$0,nochange</span><br><span class="line">nop</span><br><span class="line">jal calc</span><br><span class="line">nop</span><br><span class="line">nochange:</span><br><span class="line">beq $0,$0,end_cal</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#全程序结束</span><br><span class="line">end:</span><br><span class="line">beq $0,$0,end</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.ktext 0x4180 #魔改CP0 INT</span><br><span class="line">#判断异常类型</span><br><span class="line">mfc0 $s5,$13</span><br><span class="line">andi $s5,$s5,0x400</span><br><span class="line">beq $s5,$0,UART</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#计时模块</span><br><span class="line"></span><br><span class="line">Timing:</span><br><span class="line"></span><br><span class="line">#回退检测</span><br><span class="line">mfc0 $k0,$14</span><br><span class="line">addi $k0,$k0,-20</span><br><span class="line">mtc0 $k0,$14</span><br><span class="line"></span><br><span class="line">#判断增减</span><br><span class="line">andi $s7,$s3,4</span><br><span class="line">beq $s7,$0,Adda</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#减</span><br><span class="line">Suba:</span><br><span class="line">sub $t4,$t4,$s0</span><br><span class="line">sw $t4,0x7F50($0)</span><br><span class="line">beq $t4,$0,endtime</span><br><span class="line">nop</span><br><span class="line">jal Endhandler</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#增</span><br><span class="line">Adda:</span><br><span class="line">addi $t7,$t7,1</span><br><span class="line">sw $t7,0x7F50($0)</span><br><span class="line">beq $t7,$s4,endtime</span><br><span class="line">nop</span><br><span class="line">jal Endhandler</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#计时结束</span><br><span class="line">endtime:</span><br><span class="line">sw $0,0x7F00($0)</span><br><span class="line">mfc0 $k0,$14</span><br><span class="line">addi $k0,$k0,24</span><br><span class="line">mtc0 $k0,$14</span><br><span class="line">jal Endhandler</span><br><span class="line">nop</span><br><span class="line"></span><br><span class="line">#回显模块</span><br><span class="line">UART:</span><br><span class="line">lw $a2,0x7F30($0)</span><br><span class="line">sw $a2 0x7F30($0)</span><br><span class="line"></span><br><span class="line">Endhandler:</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">eret</span><br></pre></td></tr></table></figure></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>更多信息查看我的Github仓库-&gt; <a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P8">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P8</a><br>这是最后一个Project,相信走到这里的各位一定都很有所感触，笔者在这里祝大家武运昌隆！</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断支持流水线CPU设计文档（Verilog）</title>
      <link href="/posts/14079/"/>
      <url>/posts/14079/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Verilog 异常中断支持流水线CPU设计文档</center></font></strong></p><h1 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h1><h2 id="总体设计综述"><a href="#总体设计综述" class="headerlink" title="总体设计综述"></a>总体设计综述</h2><p>使用Verilog开发一个流水线CPU,总体概述如下：<br>1.此流水线CPU为32位CPU<br>2.此CPU为流水线设计<br>3.此CPU支持的指令集为:{add,sub,and,or,slt,sltu,addi,andi,ori,lb,lh,lw,sb,sh,sw,mult,multu,div,divu,mfhi,mflo,mthi,mtlo,beq,bne,lui,jal,jr,nop,mtc0,mfc0,syscall}<br>4.nop的机器码为0x0000000<br>5.该CPU支持对来自计数器和外部的中断进行处理<br>6，该CPU支持对于部分异常进行处理，例如字不对齐，存取位置异常，溢出异常等</p><h2 id="关键模块定义"><a href="#关键模块定义" class="headerlink" title="关键模块定义"></a>关键模块定义</h2><h3 id="IM-外置"><a href="#IM-外置" class="headerlink" title="IM(外置)"></a>IM(外置)</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i_inst_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">需要进行取指操作的流水级 PC（一般为 F 级）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i_inst_rdata[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">i_inst_addr 对应的 32 位指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">取指</td><td style="text-align:center">利用PC取出对应位置处的指令</td></tr></tbody></table></div><h3 id="F-PC"><a href="#F-PC" class="headerlink" title="F_PC"></a>F_PC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前PC值</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">更改PC值</td><td style="text-align:center">利用NPC更改PC值</td></tr></tbody></table></div><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">A3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其作为RD的写入地址</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位写入数据</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A2指定寄存器的32位数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号，清零32个寄存器中的数据</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">同步复位</td><td style="text-align:center">时钟上升沿到来时，若RESET信号有效，则将32个寄存器中的数据全部清除</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A1与A2所存地址对应的寄存器的数据读出到RD1和RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD写入到A3所存地址对应的寄存器中</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">转发数据</td><td style="text-align:center">当A3\==A2或A3\==A1且WE有效，A3!=0时，将WD中的数据作为RD1或RD2的输出</td></tr></tbody></table></div><h3 id="IF-ID-REG"><a href="#IF-ID-REG" class="headerlink" title="IF_ID_REG"></a>IF_ID_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">IF_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段机器码</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">IF_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">ID阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">O</td><td style="text-align:center">扩展类型信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">O</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RegWrite</td><td style="text-align:center">O</td><td style="text-align:center">寄存器写使能信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MemWrite</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">MemToReg[2:0]</td><td style="text-align:center">O</td><td style="text-align:center">Reg写入数据类型信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">RegDest[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">A3寄存器选择信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ALUop[3:0]</td><td style="text-align:center">O</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">O</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">O</td><td style="text-align:center">Jr信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">RegSrc</td><td style="text-align:center">O</td><td style="text-align:center">ALU数据来源选择信号</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">imm16[15:0]</td><td style="text-align:center">O</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">imm26[25:0]</td><td style="text-align:center">O</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">rs[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rs寄存器编号</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">rt[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rt寄存器编号</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">rd[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rd寄存器编号</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">load</td><td style="text-align:center">O</td><td style="text-align:center">是否为lw指令</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">store</td><td style="text-align:center">O</td><td style="text-align:center">是否为sw指令</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">cal_r</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_r类指令</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">cal_i</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_i类指令</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">jal</td><td style="text-align:center">O</td><td style="text-align:center">是否为jal指令</td></tr></tbody></table></div><p>(2)真值表</p><div class="table-container"><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">add</th><th style="text-align:center">sub</th><th style="text-align:center">ori</th><th style="text-align:center">lw</th><th style="text-align:center">sw</th><th style="text-align:center">lui</th><th style="text-align:center">beq</th><th style="text-align:center">Jal</th><th style="text-align:center">Jr</th></tr></thead><tbody><tr><td style="text-align:center">OP</td><td style="text-align:center">000000</td><td style="text-align:center">000000</td><td style="text-align:center">001101</td><td style="text-align:center">100011</td><td style="text-align:center">101011</td><td style="text-align:center">001111</td><td style="text-align:center">000100</td><td style="text-align:center">000011</td><td style="text-align:center">000000</td></tr><tr><td style="text-align:center">FC</td><td style="text-align:center">100000</td><td style="text-align:center">100010</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">001000</td></tr><tr><td style="text-align:center">ALUop</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0011</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0100</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">Jump</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">RegWrite</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemWrite</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemToReg</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegDest</td><td style="text-align:center">01</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegSrc</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Branch</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jreg</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">B[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Equal</td><td style="text-align:center">O</td><td style="text-align:center">A==B？1：0</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">比较</td><td style="text-align:center">比较操作数A与B是否相等，相等则Equal有效</td></tr></tbody></table></div><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">F_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段的PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段的PC值</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Beq指令</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jal指令</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jr指令</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Jal_imm26[25:0]</td><td style="text-align:center">I</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">D_GRF_Jr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">Jr目标寄存器数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">Beq_imm16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">Equal</td><td style="text-align:center">I</td><td style="text-align:center">D_CMP两操作数是否相等</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">PC的下一值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">计算下一PC的值</td><td style="text-align:center">根据指令和当前PC值计算下一PC值</td></tr></tbody></table></div><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">经过扩展后的32位立即数</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">I</td><td style="text-align:center">选择扩展类型信号  0：符号扩展 1：无符号扩展</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">符号扩展</td><td style="text-align:center">将16位立即数符号扩展为32位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">无符号扩展</td><td style="text-align:center">将16位立即数无符号扩展为32位立即数</td></tr></tbody></table></div><h3 id="ID-EX-REG"><a href="#ID-EX-REG" class="headerlink" title="ID_EX_REG"></a>ID_EX_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_RD1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">D_imm32[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段32位立即数</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">EX_RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">EX_imm32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段32位立即数</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">EX阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ALUControl[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">运算结果</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">判断两个操作数是否相等</td><td style="text-align:center">相等则Bigger输出1否则为0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">加运算</td><td style="text-align:center">res=SrcA+SrcB</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">减运算</td><td style="text-align:center">res=SrcA-SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">与运算</td><td style="text-align:center">res=SrcA$SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">或运算</td><td style="text-align:center">res=SrcB或SrcB</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">加载高位运算</td><td style="text-align:center">res={SrcB[15:0],16’h0}</td></tr></tbody></table></div><h3 id="E-MDU"><a href="#E-MDU" class="headerlink" title="E_MDU"></a>E_MDU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">start</td><td style="text-align:center">I</td><td style="text-align:center">开始信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MDUop[2:0]</td><td style="text-align:center">I</td><td style="text-align:center">MDU功能选择信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">HIWrite</td><td style="text-align:center">I</td><td style="text-align:center">HI寄存器写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">LOWrite</td><td style="text-align:center">I</td><td style="text-align:center">LO寄存器写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">HIRead</td><td style="text-align:center">I</td><td style="text-align:center">读HI寄存器信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">LORead</td><td style="text-align:center">I</td><td style="text-align:center">读LO寄存器信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">HI[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">HI寄存器</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">LO[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">LO寄存器</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">busy</td><td style="text-align:center">O</td><td style="text-align:center">MDU模块忙信号</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">MDU_res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MDU结果信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">无符号乘</td><td style="text-align:center">{HI_temp,LO_temp} = SrcA * SrcB</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">符号乘</td><td style="text-align:center">{HI_temp,LO_temp} = $signed(SrcA) * $signed(SrcB)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">符号除</td><td style="text-align:center">HI = $signed(SrcA) % $signed(SrcB)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">符号除</td><td style="text-align:center">LO = $signed(SrcA) \ $signed(SrcB)</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">无符号除</td><td style="text-align:center">HI = SrcA % SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">无符号除</td><td style="text-align:center">LO = SrcA \ SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">读写HI寄存器</td><td style="text-align:center">mfhi读，mthi写</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">读写LO寄存器</td><td style="text-align:center">mflo读，mflo写</td></tr></tbody></table></div><h3 id="EX-MEM-REG"><a href="#EX-MEM-REG" class="headerlink" title="EX_MEM_REG"></a>EX_MEM_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">MEM_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">MEM阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="DM（外置）"><a href="#DM（外置）" class="headerlink" title="DM（外置）"></a>DM（外置）</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">m_data_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">m_data_rdata[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">32位数据输出</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">m_data_wdata[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位数据输入</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">m_inst_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">M级PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">m_inst_byteen[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">字节使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">写入数据</td><td style="text-align:center">当时钟上升沿到来时，根据字节使能信号中的有效位将WD中的数据写入到A所存地址所对应的位处</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A所存地址对应位置的数据读出到RD</td></tr></tbody></table></div><h3 id="M-CP0"><a href="#M-CP0" class="headerlink" title="M_CP0"></a>M_CP0</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">en</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">CP0Add[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">寄存器选择信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">CP0In[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">读入数据</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CP0Out[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">读出数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">VPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">受害PC</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">BDIn</td><td style="text-align:center">I</td><td style="text-align:center">延迟槽指令信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ExcCodeIn[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">异常类型</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">HWInt[5:0]</td><td style="text-align:center">I</td><td style="text-align:center">中断信号输入</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">EXLClr</td><td style="text-align:center">I</td><td style="text-align:center">EXL复位信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">EPCOut[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EPC值</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">Req</td><td style="text-align:center">O</td><td style="text-align:center">进入处理程序请求</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">配置异常</td><td style="text-align:center">根据EXL Cause SR信号不同位决定中断能否产生</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">记录异常</td><td style="text-align:center">利用SR Cause EPC记录异常信息</td></tr></tbody></table></div><h3 id="M-BE"><a href="#M-BE" class="headerlink" title="M_BE"></a>M_BE</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[1:0]</td><td style="text-align:center">I</td><td style="text-align:center">DM地址的低两位</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">DM读出数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Op[2:0]</td><td style="text-align:center">I</td><td style="text-align:center">BE功能选择</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">BE数据输出</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">处理DM数据</td><td style="text-align:center">根据A和OP处理数据，使其符合指令行为</td></tr></tbody></table></div><h3 id="MEM-WB-REG"><a href="#MEM-WB-REG" class="headerlink" title="MEM_WB_REG"></a>MEM_WB_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">MEM_DM_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段DM读出数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WB_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WB_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">WB_DM_RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段DM读出数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">WB_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">WB阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Stall"><a href="#Stall" class="headerlink" title="Stall"></a>Stall</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">D_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Stall</td><td style="text-align:center">O</td><td style="text-align:center">阻塞信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">阻塞功能</td><td style="text-align:center">判断当前流水线是否需要在ID阶段阻塞</td></tr></tbody></table></div><p>(3)判断方法——AT法</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">rsTuse</th><th style="text-align:center">rtTuse</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">slt</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sltu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">addi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">andi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lb</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lh</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sb</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">sh</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">bne</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">mult</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">multu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">div</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">divu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">mthi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mtlo</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">0</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mtc0</td><td style="text-align:center">2</td><td style="text-align:center">0</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">E_Tnew</th><th style="text-align:center">M_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">slt</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sltu</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">addi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">andi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">lh</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">lb</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sh</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sb</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mfhi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">mflo</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">bne</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mfc0</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr></tbody></table></div><h4 id="特殊"><a href="#特殊" class="headerlink" title="特殊"></a>特殊</h4><pre><code>Stall_eret = (D_eret) &amp;&amp; ((E_mtc0 &amp;&amp; E_rd == 5&#39;d14) || (M_mtc0 &amp;&amp; M_rd == 5&#39;d14));</code></pre><h3 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">W_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_Forward</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">MEM_Forward</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">WB_Forward</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段数据是否可以转发信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">转发信号</td><td style="text-align:center">判断每个阶段是否可以为前面转发数据</td></tr></tbody></table></div><h3 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h3><p>(1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">PrAddr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">CPU地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">PrRD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">读出到CPU的数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">PrWD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">读入到外设的数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">DevAddr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">外设地址</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">DevWD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">输出到外设的数据</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">TC1_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">来自TC1的数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">TC2_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">来自TC2的数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">DM_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">来自DM的数据</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">PrWe</td><td style="text-align:center">I</td><td style="text-align:center">桥写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">TC1_WE</td><td style="text-align:center">O</td><td style="text-align:center">TC1写使能信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">TC2_WE</td><td style="text-align:center">O</td><td style="text-align:center">TC2写使能信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">DM_WE</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">信息交换</td><td style="text-align:center">用于CPU和外设之间的信息交换</td></tr></tbody></table></div><p>19.TC</p><p>(1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Addr[31:2]</td><td style="text-align:center">I</td><td style="text-align:center">地址数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">读入数据</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">读出数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">IRQ</td><td style="text-align:center">O</td><td style="text-align:center">计时器中断信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">定时产生中断信号</td><td style="text-align:center">通过计数模式定期产生中断信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">模式0</td><td style="text-align:center">计数为0时，若不复位，持续产生IRQ信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">模式1</td><td style="text-align:center">计数为0时，产生一周期IRQ信号后重新计数</td></tr></tbody></table></div><h1 id="转发暂停控制"><a href="#转发暂停控制" class="headerlink" title="转发暂停控制"></a>转发暂停控制</h1><h2 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h2><pre><code>wire Stall_eret = (D_eret) &amp;&amp; ((E_mtc0 &amp;&amp; E_rd == 5&#39;d14) || (M_mtc0 &amp;&amp; M_rd == 5&#39;d14));wire Stall_MDU = busy &amp;&amp; ( D_MDU_c || D_MDU_f || D_MDU_t );wire Stall_rs_E = (E_RegDest == D_rs) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rs &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_rt_E = (E_RegDest == D_rt) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rt &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_E = Stall_rs_E || Stall_rt_E;wire Stall_rs_M = (M_RegDest == D_rs) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rs &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_rt_M = (M_RegDest == D_rt) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rt &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_M = Stall_rs_M || Stall_rt_M;assign Stall = Stall_M || Stall_E || Stall_MDU;     </code></pre><h2 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h2><pre><code>wire [31:0] D_Forward_rs = (D_rs == 0)? 0 :            ((E_RegDest == D_rs) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :        ((M_RegDest == D_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD1;wire [31:0] D_Forward_rt = (D_rt == 0)? 0 :            ((E_RegDest == D_rt) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :            ((M_RegDest == D_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD2;wire [31:0] E_Forward_rs =   (E_rs == 0) ? 0 :        ((M_RegDest == E_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rs) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD1;wire [31:0] E_Forward_rt =   (E_rt == 0) ? 0 :        ((M_RegDest == E_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rt) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD2;wire [31:0] M_WD_Forward = (M_rt == 0) ? 0 :        ((W_RegDest == M_rt) &amp;&amp; (WB_Forward) &amp;&amp; (W_RegWrite)) ? W_MemToReg : MEM_RD2;</code></pre><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>为<strong>自动化测试，测试异常部分</strong>：<br>共随机生成1000组数据包括handler<br><img src="微信截图_20221106010804.png" alt="数据示意1"><br>并生成1000组比对文件<br><img src="微信截图_20221106010955.png" alt="数据示意2"><br>和一个总体结果文件<br><img src="微信截图_20221106011047.png" alt="数据示意3"></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="请查阅相关资料，说明鼠标和键盘的输入信号是如何被-CPU-知晓的？"><a href="#请查阅相关资料，说明鼠标和键盘的输入信号是如何被-CPU-知晓的？" class="headerlink" title="请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？"></a>请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？</h3><p>答：鼠标和键盘产生信息，这些信息或是被读到内存，或是被读到CPU的寄存器中，并同时产生中断信号，中断当前CPU的运行，CPU进入中断状态执行中断处理程序读入键盘和鼠标的信息进行处理。</p><h3 id="请思考为什么我们的-CPU-处理中断异常必须是已经指定好的地址？如果你的-CPU-支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）"><a href="#请思考为什么我们的-CPU-处理中断异常必须是已经指定好的地址？如果你的-CPU-支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）" class="headerlink" title="请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）"></a>请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）</h3><p>答：我认为依旧可以实现，无非是需要更改一下CPU中当出现异常或中断时要跳转到的异常处理程序地址，之后由用户提供的程序依旧可以对中断和异常进行处理。但入口常常变动会导致该CPU的适用性降低，换个执行指令段执行可能就需要换个入口。</p><h3 id="为何与外设通信需要-Bridge？"><a href="#为何与外设通信需要-Bridge？" class="headerlink" title="为何与外设通信需要 Bridge？"></a>为何与外设通信需要 Bridge？</h3><p>答：外设实在是太多了，如果每个外设都要针对CPU做单独处理那么时间与经济成本实在是过于昂贵且没必要了，所以采用Bridge方式，通过一个 CPU 视图下的内存地址，读写相应数据即可达到与外设沟通的目的，统一化了外设，DM处理起来十分方便，且扩展性好，新加外设在系统桥进行添加即可，无需单独为其设计一套读写逻辑。</p><h3 id="请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。"><a href="#请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。" class="headerlink" title="请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。"></a>请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。</h3><p>答：相同之处：在允许计数的情况下，都是从初值寄存器中获取初数值到计数值寄存器中开始计数，两种模式都受控制寄存器的控制<br>区别之处：模式0在计数结束后，会一直提供中断信号，直到IM或者EN被修改使其禁止中断或停止计数，模式1在计数结束后，只会提供一周期的中断信号，然后自动再次赋初值开始计数，知道IM或者EN被修改行为才会被改变。<br><img src="模式零.jpg" alt="数据示意3"><br><img src="模式一.jpg" alt="数据示意3"></p><h3 id="倘若中断信号流入的时候，在检测宏观-PC-的一级如果是一条空泡（你的-CPU-该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在-P7-中，清空流水线产生的空泡指令应该保留原指令的哪些信息？"><a href="#倘若中断信号流入的时候，在检测宏观-PC-的一级如果是一条空泡（你的-CPU-该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在-P7-中，清空流水线产生的空泡指令应该保留原指令的哪些信息？" class="headerlink" title="倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？"></a>倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？</h3><p>答：会发生宏观PC出现0的情况，这显然是不合理的，所以应该保留原PC值。</p><h3 id="为什么-jalr-指令为什么不能写成-jalr-31-31？"><a href="#为什么-jalr-指令为什么不能写成-jalr-31-31？" class="headerlink" title="为什么 jalr 指令为什么不能写成 jalr 31,31？"></a>为什么 jalr 指令为什么不能写成 jalr 31,31？</h3><p>答：根据英文指令集的解释，该寄存器的rs和rd不能相等，因为这样的指令在重新执行时不会有相同的效果，执行这种指令的结果是UB，如果这样做了，假如延迟槽指令出现了异常，那么该异常是无法通过重新执行jalr来恢复执行的，因为$31寄存器的值已改变。</p><h3 id="请详细描述你的测试方案及测试数据构造策略。"><a href="#请详细描述你的测试方案及测试数据构造策略。" class="headerlink" title="请详细描述你的测试方案及测试数据构造策略。"></a>请详细描述你的测试方案及测试数据构造策略。</h3><p>答：本次P7我全覆盖测试了异常的产生，对于中断则测试了计时器中断，外部中断只能是找人对拍，Mars没有暴露外部中断的API，对于异常的产生，由于异常种类数量可以接受，为了保证覆盖率，我对于每种情况都在代码生成里进行了特定的判定，确保一但判断生效，则生成的代码必定会出现异常，例如随机一个判定，若判断为1，我会采取如下的方式构造PC异常：<br><img src="异常.png" alt="数据示意3"><br>这种构造保证了PC不对齐，PC溢出的问题一定会生成，且保证了PC的随机性，因为PC的值是随机的，提高测试强度。之后的一些诸如AdEL.AdEs都是采取这种半随机半特判的方式生成，主要是为了兼顾覆盖性与完备性。</p><p>其次我专门对延迟槽进行了构造处理，保证一个测试文件中至少有一个会出现延迟槽异常，其实也很简单，在延迟槽中加入syscall即可，<br><img src="异常2.png" alt="数据示意3"><br>再其次我也没有丢掉P6的数据生成，这些异常将夹杂在P6的正常代码生成之中生成，目的是防止在对CPU进行P7修改时破坏了P6的体系完整，利用这样的代码生成可以直接测出这个问题。</p><p>然后是一些特殊处理，我也在生成器中加入了会连续出现异常的可能性，便于测试该CPU能否连续处理异常，提高测试的完备性。SUB构造如图：<br><img src="异常3.png" alt="数据示意3"><br>最后我也实现了handler（异常处理模块）的生成，主题思路为，前面固定生成对于各类异常的处理，后面则是一些随机指令，注意这些随机指令中add用addu代替，sub用subu代替，addi用addiu代替，load,store确保不会溢出或字不对齐，目的是防止在异常处理程序中再次出现异常，使程序循环执行。<br>对于各类异常的处理，采用if思想的beq，若PC不对齐，则取其[31:2]位，若PC越界，则直接将EPC改为末尾的无限自循环PC值，结束程序，之后考虑若为延迟槽，则EPC+8,若不为延迟槽，则EPC+4，这些固定化的模块保证了异常得到妥善处理，并顺利结束程序。<br>eret后面有一个指令，用于测试eret的无延迟槽性。<br><img src="异常4.png" alt="数据示意3"><br>之后则是一些机器码的生成，另写了一个.cpp文件用于text和ktext的合并，中间则用Nop填充，最终实现了如同P6一般只需输入测试次数即可一键测试的效果。       </p><p>整体思路大概就是这样，如有不合适之处还请斧正，谢谢！具体实现可以参看我的CPU自动化提交文件中的代码。</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中断支持流水线CPU全自动测试思路（Verilog）</title>
      <link href="/posts/47414/"/>
      <url>/posts/47414/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P7的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><font color="purple">由于P7是P6的迭代开发，因此本次工作将主要体现在数据生成上，而且由于Mars的局限性，我们将编写两个测试程序<b>（一个对拍Mars，一个对拍CPU）</b>，分别用于测试功能/异常和中断</font><h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><h2 id="导出0x4180位置处的机器码"><a href="#导出0x4180位置处的机器码" class="headerlink" title="导出0x4180位置处的机器码"></a>导出0x4180位置处的机器码</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars.jar mc LargeText a dump <span class="number">0</span>x00004180-<span class="number">0</span>x00006000 HexText handler.txt nc test.asm</span><br></pre></td></tr></table></figure><p>在Mars中，我们是无法导出0x4180位置的机器码的，但我们可以通过命令行进行导出，上面的命令行就是以16进制导出test.asm中的0x4180-0x6000位置处的机器码，导出到handler.txt文件中。  </p><h2 id="限制Mars运行指令数"><a href="#限制Mars运行指令数" class="headerlink" title="限制Mars运行指令数"></a>限制Mars运行指令数</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars.jar mc LargeText nc db lg ex me <span class="number">65536</span> test.asm &gt; mar.txt</span><br></pre></td></tr></table></figure><p>在P7中，最起码对于笔者来说，是经常会将程序指引向一个死循环的，所以我们需要给Mars设置指令条数上限，这样Mars才能结束运行，否则将会一直运行。指令中65536就是运行上限。</p><h1 id="机器码合成"><a href="#机器码合成" class="headerlink" title="机器码合成"></a>机器码合成</h1><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>在P7中，机器码被分为了两部分，正常程序部分从0x3000开始，异常处理部分从0x4180部分开始，但我们<strong>只能给CPU输入一个文件</strong>，所以我们就需要进行合成。<br>但合成仍然有一个问题，我们<strong>如何保证异常处理代码位于0X4180处？</strong>，毕竟很少有正常程序可以填充满0x3000-0x4180。在这种情况下直接合成则异常程序会低于0x4180。<br>因此我们需要添加Nop在正常程序后面，直到填充到0x4180位置，然后拼接异常处理机器码。 </p><h2 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> IM[<span class="number">5000</span>][<span class="number">32</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">FILE* in;</span><br><span class="line">in = fopen(<span class="string">&quot;machine.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">fscanf</span>(in, <span class="string">&quot;%s&quot;</span>, IM[i])) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">fclose(in);</span><br><span class="line">FILE* handler;</span><br><span class="line">handler = fopen(<span class="string">&quot;handler.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="type">int</span> j = <span class="number">1120</span>;</span><br><span class="line"><span class="keyword">while</span> ((<span class="built_in">fscanf</span>(handler, <span class="string">&quot;%s&quot;</span>, IM[j])) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">fclose(handler);</span><br><span class="line">freopen(<span class="string">&quot;code.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">5000</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (IM[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;00000000\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, IM[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Python实现（数据执行器）"><a href="#Python实现（数据执行器）" class="headerlink" title="Python实现（数据执行器）"></a>Python实现（数据执行器）</h1><h2 id="异常-功能正确性测试"><a href="#异常-功能正确性测试" class="headerlink" title="异常/功能正确性测试"></a>异常/功能正确性测试</h2><font color="red">需要修改，全部修改是更改命令行为上述命令行，修改比较简单，示例就不放了</font><h2 id="中断正确性测试"><a href="#中断正确性测试" class="headerlink" title="中断正确性测试"></a>中断正确性测试</h2><h3 id="实现思路-1"><a href="#实现思路-1" class="headerlink" title="实现思路"></a>实现思路</h3><font color="red">需要修改，主要修改是将对拍对象由Mars改成另一个CPU，将Mars生成的机器码给两个CPU吃，然后对比这两个CPU的文件是否相同</font><h3 id="实现示例-1"><a href="#实现示例-1" class="headerlink" title="实现示例"></a>实现示例</h3><p>友情提醒：代码段可以点击右上角收起<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> filestools</span><br><span class="line"><span class="keyword">from</span> filediff.diff <span class="keyword">import</span> file_diff_compare</span><br><span class="line">p_road = <span class="string">&quot;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\FlowCpu&quot;</span></span><br><span class="line">d_road = <span class="string">&quot;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7jbw&quot;</span></span><br><span class="line">run_time = <span class="string">&quot;100us&quot;</span></span><br><span class="line">xilinx_path = <span class="string">&quot;G:\\ISE\\14.7\\ISE_DS\\ISE&quot;</span></span><br><span class="line">dir_name = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\测试记录\\mars文件\\&#x27;</span></span><br><span class="line">dir_name_3 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\测试记录\\机器码文件\\&#x27;</span></span><br><span class="line">dir_name_1 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\测试记录\\比较文件\\&#x27;</span></span><br><span class="line">dir_name_2 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\测试记录\\&#x27;</span></span><br><span class="line">error = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成指令中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    command = <span class="string">&quot;C语言.exe&quot;</span></span><br><span class="line">    os.system(command)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;test.asm&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.asm&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mar</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成机器码中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText a dump .text HexText machine.txt nc test.asm&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText a dump 0x00004180-0x00006000 HexText handler.txt nc test.asm&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;机器码合成.exe&quot;</span>)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;code.txt&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name_3 + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.txt&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line">    <span class="comment"># print(&quot;生成标准答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars.jar mc LargeText nc db lg ex me 65536 test.asm &gt; mar.txt&quot;</span>)</span><br><span class="line"><span class="comment"># 循环结尾 os.system(&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc db me 65536  test.asm &gt; mar.txt&quot;)</span></span><br><span class="line"><span class="comment"># 延迟槽 os.system(&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc db test.asm &gt; mar.txt&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ise_p</span>():</span><br><span class="line">    <span class="comment"># print(&quot;运行ise中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(p_road):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">                file_list.append(file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">            prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + p_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">        tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">    prj.close()</span><br><span class="line">    tcl.close()</span><br><span class="line">    os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path</span><br><span class="line">    os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + p_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_txt &gt; compile_log.txt&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + p_road + <span class="string">&quot;\\mips.tcl&gt; raw_out_p.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ise_d</span>():</span><br><span class="line">    <span class="comment"># print(&quot;运行ise中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(d_road):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">                file_list.append(file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(d_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">            prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + d_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(d_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">        tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">    prj.close()</span><br><span class="line">    tcl.close()</span><br><span class="line">    os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path</span><br><span class="line">    os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + d_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_txt &gt; compile_log.txt&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + d_road + <span class="string">&quot;\\mips.tcl&gt; raw_out_d.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_p</span>():</span><br><span class="line">    <span class="comment"># print(&quot;转换ise答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out_p.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">        mymem = mymem + myfriendmem[i]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog_p.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(mymem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_d</span>():</span><br><span class="line">    <span class="comment"># print(&quot;转换ise答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out_d.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">        mymem = mymem + myfriendmem[i]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog_d.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(mymem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_file</span>(<span class="params">name, target_road</span>):</span><br><span class="line">    f_1 = <span class="built_in">open</span>(name, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(target_road + <span class="string">&quot;\\&quot;</span> + name, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_cmp</span>(<span class="params">test_order</span>):</span><br><span class="line">    co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    co.write(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog_p.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> out_1:</span><br><span class="line">        out_std = out_1.readlines()</span><br><span class="line">        <span class="comment"># out_std.remove(&#x27;\n&#x27;)</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog_d.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> out_2:</span><br><span class="line">        out_test = out_2.readlines()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.\\log.txt&quot;</span>.<span class="built_in">format</span>(test_order), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(out_std) &gt; <span class="built_in">len</span>(out_test):</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out_std)):</span><br><span class="line">                <span class="keyword">if</span> out_std[i] != out_test[i]:</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">                    log.write(<span class="string">&quot;error in line &#123;&#125;\n expected output is &#123;&#125;\nyour outout is &#123;&#125;\n\n&quot;</span>.<span class="built_in">format</span>(i, out_std[i], out_test[i]))</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Wrong Answer!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Wrong Answer!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="comment"># os.makedirs(&quot;.\\test_log_file\\log_&#123;&#125;\\&quot;.format(i))</span></span><br><span class="line">            <span class="comment"># copy_file(&quot;log.txt&quot;, &quot;.\\test_log_file\\log_&#123;&#125;&quot;.format(i))</span></span><br><span class="line">            <span class="comment"># copy_file(&quot;test.asm&quot;, &quot;.\\test_log_file\\log_&#123;&#125;&quot;.format(i))</span></span><br><span class="line">            <span class="comment"># copy_file(&quot;mar.txt&quot;, &quot;.\\test_log_file\\log_&#123;&#125;&quot;.format(i))</span></span><br><span class="line">            <span class="comment"># copy_file(&quot;verilog.txt&quot;, &quot;.\\test_log_file\\log_&#123;&#125;&quot;.format(i))</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Accepted!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Accepted!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    co.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> f.readlines()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: 没有找到文件:%s或读取文件失败！&quot;</span> % filename)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_file</span>(<span class="params">file1, file2, out_file</span>):</span><br><span class="line">    file1_content = read_file(file1)</span><br><span class="line">    file2_content = read_file(file2)</span><br><span class="line">    d = difflib.HtmlDiff()</span><br><span class="line">    result = d.make_file(file1_content, file2_content)</span><br><span class="line">    fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    fb.write(result)</span><br><span class="line">    <span class="comment"># with open(dir_name + out_file, &#x27;w&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     f.writelines(result)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zip</span>(<span class="params">test_order</span>):</span><br><span class="line">    os.system(<span class="string">&quot;\&quot;C:\\Program Files (x86)\\360\\360zip\\360zip.exe\&quot; -ar code.txt C:\\Users\\Unicorn\\Desktop\\P7\\P7exp\\P7全自动测试_对拍\\压缩文件\\P7_Q&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;.zip&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入测试次数:&quot;</span>)</span><br><span class="line">test_times =<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">co.write(<span class="string">&quot;测试次数:&quot;</span>+<span class="built_in">str</span>(test_times)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">co.close()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">    generate(i+<span class="number">1</span>)</span><br><span class="line">    run_mar(i+<span class="number">1</span>)</span><br><span class="line">    run_ise_p()</span><br><span class="line">    run_ise_d()</span><br><span class="line">    process_p()</span><br><span class="line">    process_d()</span><br><span class="line">    <span class="comment"># zip(i+1)</span></span><br><span class="line">    <span class="comment"># print(&quot;比较答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    compare_file(<span class="string">r&#x27;verilog_p.txt&#x27;</span>, <span class="string">r&#x27;verilog_d.txt&#x27;</span>, <span class="string">&#x27;result&#x27;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">    file_cmp(i+<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure></p><h1 id="数据生成器迭代思路"><a href="#数据生成器迭代思路" class="headerlink" title="数据生成器迭代思路"></a>数据生成器迭代思路</h1><h2 id="P7指令集"><a href="#P7指令集" class="headerlink" title="P7指令集"></a>P7指令集</h2><p><strong>{add,sub,and,or,slt,sltu,addi,andi,ori,lb,lh,lw,sb,sh,sw,mult,multu,div,divu,mfhi,mflo,mthi,mtlo,beq,bne,lui,jal,jr,nop,mtc0,mfc0,syscall}</strong></p><h2 id="迭代思路"><a href="#迭代思路" class="headerlink" title="迭代思路"></a>迭代思路</h2><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><h3 id="CPU功能正确性测试"><a href="#CPU功能正确性测试" class="headerlink" title="CPU功能正确性测试"></a>CPU功能正确性测试</h3><p>根据P6的介绍，mtc0,mfc0,syscall均为安全指令，所以可以加入全局生成中。</p><h3 id="CPU异常正确性测试"><a href="#CPU异常正确性测试" class="headerlink" title="CPU异常正确性测试"></a>CPU异常正确性测试</h3><p>根据P7课程网站，我们会发现，异常的可能性是可以穷举的，而且考虑到一个很难受的事情：P6的数据生成器是绝对正确的（我们已经de过了万千Bug，是绝对跑不出问题的），所以我们直接在数据生成中将<font color="red">所有可能的异常加入，然后随机产生。</font></p><h3 id="CPU中断正确性测试"><a href="#CPU中断正确性测试" class="headerlink" title="CPU中断正确性测试"></a>CPU中断正确性测试</h3><p>课程组给的Mars是稍微有点问题的，首先它<font color="red">无法测试外部中断</font>，而且计时中断测试，也会由于<font color="blue">阻塞的问题导致和CPU行为不一致。</font>因此，Mars在中断测试中无用，我们只能选择对拍。<br>我们只需修改数据生成，让其开头固定生成一段打开计时器中断的代码即可。</p><h3 id="通用Handler"><a href="#通用Handler" class="headerlink" title="通用Handler"></a>通用Handler</h3><h4 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h4><p>通用的Handler需要我们实现：<br>（1）检测是什么异常<br>（2）根据检测到的异常进入不同的异常处理模块<br>（3）处理异常<br>（4）恢复<br>笔者的通用Handler思路实现比较简单，主要是区分一下是否是延迟槽异常，区分一下是否是PC异常，如果是延迟槽异常，就PC+8（分为两次PC+4）,如果是PC异常，就跳到开头的死循环位置。其余直接PC+4跳过这条异常指令。</p><h4 id="实现示例："><a href="#实现示例：" class="headerlink" title="实现示例："></a>实现示例：</h4><p>笔者这里实现了一个通用的Handler模型，可以给大家使用。<br><strong>当笔者实现后，CRT助教哥哥告诉笔者Github好像有现成的，笔者哭死T-T</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">.ktext 0x4180</span><br><span class="line">mfc0 $k1,$13</span><br><span class="line">andi $k1,$k1,0x80000000</span><br><span class="line">beq $k1,$0,nodelay  //判断是否是延迟槽里的异常</span><br><span class="line">nop</span><br><span class="line">mfc0 $k0, $14</span><br><span class="line">andi $k0,$k0,0xfffffffc</span><br><span class="line">addu $k0, $k0, 4</span><br><span class="line">mtc0 $k0, $14</span><br><span class="line">nodelay:</span><br><span class="line">mfc0 $k0, $14</span><br><span class="line">andi $k0,$k0,0xfffffffc</span><br><span class="line">addu $k0, $k0, 4</span><br><span class="line">mtc0 $k0, $14</span><br><span class="line">subu $k1,$k1,$k1</span><br><span class="line">ori $k1,$0,0x3008</span><br><span class="line">subu $8,$8,$8</span><br><span class="line">ori $8,$0,0x6ffc</span><br><span class="line">slt $9,$8,$k0</span><br><span class="line">beq $9,$0,nopc_0 //判断是否是PC异常</span><br><span class="line">nop</span><br><span class="line">mtc0 $k1,$14</span><br><span class="line">addiu $k0,$k1,0</span><br><span class="line">nopc_0:</span><br><span class="line">subu $10,$10,$10</span><br><span class="line">ori $10,$0,0x3000</span><br><span class="line">slt $9,$k0,$10</span><br><span class="line">beq $9,$0,nopc_1</span><br><span class="line">nop</span><br><span class="line">mtc0 $k1,$14</span><br><span class="line">addiu $k0,$k1,0</span><br><span class="line">nopc_1:</span><br></pre></td></tr></table></figure></p><p><strong>TIPS:</strong>使用笔者的通用Handler需要在代码开头实现一个beq的死循环，这是因为在笔者的通用Handler中，一旦出现PC错误，将直接跳到开头进行死循环刷到指令执行上限结束程序。</p><h3 id="功能正确"><a href="#功能正确" class="headerlink" title="功能正确"></a>功能正确</h3><p>写3个生成函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">mfc0:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mfc0</span><span class="params">(<span class="type">int</span> rs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (random == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mfc0 $%d $12\n&quot;</span>, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mfc0 $%d $13\n&quot;</span>, rs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mfc0 $%d $14\n&quot;</span>, rs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">mtc0:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mtc0</span><span class="params">(<span class="type">int</span> rs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mtc0 $%d $14\n&quot;</span>, rs);</span><br><span class="line">&#125;</span><br><span class="line">syscall:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">syscall</span><span class="params">()</span>  #这个其实可有可无，毕竟就一句话，在我们枚举异常所有情况时写在那里就行</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;syscall\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>加入全局生成即可完成功能正确性测试。    </p><h3 id="异常正确"><a href="#异常正确" class="headerlink" title="异常正确"></a>异常正确</h3><p>枚举所有异常情况，随机生成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">32</span>: <span class="comment">//异常特加</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;#Exc:\n&quot;</span>);</span><br><span class="line">        radom = <span class="built_in">rand</span>() % <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (radom == <span class="number">0</span>)  <span class="comment">//ADEL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//PC异常</span></span><br><span class="line">            <span class="type">int</span> Imm = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (Reg % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Imm = <span class="number">28668</span> + <span class="built_in">rand</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (((Imm % <span class="number">4</span>) == <span class="number">0</span>) &amp;&amp; (Imm &gt;= <span class="number">16768</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    Imm = <span class="built_in">rand</span>() % <span class="number">28669</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sub</span>(rs, rs, rs,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">ori</span>(rs, rs, Imm, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;jr $%d\n&quot;</span>, rs);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;nop\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">1</span>)  <span class="comment">//ADEL</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (random == <span class="number">0</span>)  <span class="comment">//取指不对齐</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Imm = <span class="built_in">rand</span>() % <span class="number">32548</span>;</span><br><span class="line">                <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">12</span>;  <span class="comment">//取到错误地方</span></span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>)        <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32512($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32516($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32512($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32516($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">6</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32528($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">7</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32532($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">8</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">9</span>)   <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32528($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">10</span>)  <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32532($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">11</span>)  <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sub</span>(rt, rt, rt,<span class="number">1</span>);   <span class="comment">//取指超范围</span></span><br><span class="line">                <span class="built_in">ori</span>(rt, rt, <span class="number">2147480000</span> + I, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">2</span>) <span class="comment">//ADES</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span> (random == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> Imm = <span class="built_in">rand</span>() % <span class="number">32548</span>;  <span class="comment">//取指不对齐</span></span><br><span class="line">                <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($0)\n&quot;</span>, rt, Imm);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">13</span>; <span class="comment">//取到错误地方</span></span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>)       <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32512($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32516($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">3</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32512($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">4</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32516($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">5</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">6</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32528($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">7</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32532($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">8</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">9</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32528($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">10</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32532($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">11</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">11</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,32520($0)\n&quot;</span>, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">12</span>)  <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,32536($0)\n&quot;</span>, rt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (random == <span class="number">2</span>) <span class="comment">//取指超范围</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sub</span>(rt, rt, rt,<span class="number">1</span>);</span><br><span class="line">                <span class="built_in">ori</span>(rt, rt, <span class="number">2147480000</span> + I, <span class="number">0</span>);</span><br><span class="line">                <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($%d)\n&quot;</span>, rs, <span class="number">2147480000</span> + I, rt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">3</span>)  <span class="comment">//syscall异常</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;syscall\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">4</span>) <span class="comment">//未知指令</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ftrap\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (radom == <span class="number">5</span>) <span class="comment">//加减溢出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs == <span class="number">1</span> || rs == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                rs = Reg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rt == <span class="number">1</span> || rt == <span class="number">0</span> || rt == rs)</span><br><span class="line">            &#123;</span><br><span class="line">                rt = Reg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rd == <span class="number">1</span> || rd == <span class="number">0</span> || rd == rs || rd == rt)</span><br><span class="line">            &#123;</span><br><span class="line">                rd = Reg;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line">            <span class="built_in">sub</span>(rs, rs, rs,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">ori</span>(rs, rs, <span class="number">2147480000</span> + I, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">sub</span>(rt, rt, rt,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">ori</span>(rt, rt, <span class="number">2147480000</span> + I, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">add</span>(rd, rs, rt,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">addi</span>(rs, rd, <span class="number">2147480000</span> + I,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>  <span class="comment">//测减法溢出的同时测连续异常的处理能力</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">                <span class="built_in">sub</span>(rs, rt, rt,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;#ExcEnd:\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>以上包含了所有异常的可能，我们在生成时在其中抽取异常生成即可，我将它称为异常池。</p><font color="red">注意减法溢出，笔者在这里写了很多个sub是为了检测CPU连续处理异常的能力</font>   <h3 id="中断正确"><a href="#中断正确" class="headerlink" title="中断正确"></a>中断正确</h3><p>因为我们是全自动测试，所以我们无需仔细考虑中断和异常同时发生的各种情况，因为我们的样本数据够多，随机生成总会碰到的，所以我们直接采用计时器生成，每隔5个指令进行一次中断，因此我们需要配置计时器中断，固定生成以下代码在开头：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ori $t1,11\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ori $t2,20\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ori $t3,0xFC01\n&quot;</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;mtc0 $t3,$12\n&quot;</span>);</span><br></pre></td></tr></table></figure><br>之后正常对拍即可</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>P7对于自动化测试的压力还是比较大的，毕竟课上就是对P7的强测，只要强测全部过了都可以直接交卷了，所以课下做的好，课上5分钟。<br>课上分为三个强测：功能，异常，中断强测，因此根据Mars发挥的作用笔者也做了两个测试程序：功能/异常测试,中断测试。</p><p><font color="red">笔者的自动化测试甚至测出了强测没考的点（x</font><br>可惜，P7没有P5,P6那种覆盖率测试程序QAQ，一人血书求出P7覆盖率测试程序。</p><h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>两个都太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P7">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P7</a><br><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P7课上强测！</font></strong><br><strong><font size = 5>P7功能\异常数据生成器代码行数：1178行</font></strong><br><strong><font size = 5>P7中断数据生成器代码行数：1229行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流水线设计与添加指令经验总结</title>
      <link href="/posts/33345/"/>
      <url>/posts/33345/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P5,P6的流水线搭建和课上添加指令的经验总结</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>虽然这么说有搞心态的嫌疑x，但笔者认为，P5是计组难度的分水岭，难度同时体现在课下和课上当中，课下CPU做不好，做出Bug,课上强测也过不去，而且课上加指令本来就比较难做，所以被P5卡一两回也是理所应当的，同时，P5和P6同作为流水线的开发，课上指令将具有极大的<font color="red">相似性</font>，因此笔者认为，开一篇博客来分享一下笔者P5,P6流水线搭建和课上添加指令是必要的，话不多说，<strong>Here We Go!</strong></p><h1 id="预留扩展空间"><a href="#预留扩展空间" class="headerlink" title="预留扩展空间"></a>预留扩展空间</h1><p>如果大家是以顺利通过P3,P4的身份来看这一篇文章的，大家就会明白，一个好的架构对于课上的帮助将有多么巨大，特别是针对于P5,P6这种千行级代码的开发，笔者这里主要说一下扩展空间的事情。</p><h2 id="MUX的非模块化"><a href="#MUX的非模块化" class="headerlink" title="MUX的非模块化"></a>MUX的非模块化</h2><p>很多人在P4，包括我会这样模块化写MUX：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> MUX_4_32(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data0,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data2,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data3,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] out</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assign</span> out = (sel==<span class="number">2&#x27;b00</span>) ? data0 : </span><br><span class="line">                    (sel==<span class="number">2&#x27;b01</span>) ? data1 :</span><br><span class="line">                        (sel==<span class="number">2&#x27;b10</span>) ? data2 : data3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> MUX_4_5(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] data0,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] data1,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] data2,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] data3,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] out</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assign</span> out = (sel==<span class="number">2&#x27;b00</span>) ? data0 : </span><br><span class="line">                    (sel==<span class="number">2&#x27;b01</span>) ? data1 :</span><br><span class="line">                        (sel==<span class="number">2&#x27;b10</span>) ? data2 : data3;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> MUX_2_32(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data0,</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] data1,</span><br><span class="line">    <span class="keyword">input</span> sel,</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">31</span>:<span class="number">0</span>] out</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">assign</span> out = (sel==<span class="number">2&#x27;b00</span>) ? data0 : data1;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br>之后在DataPath里面将这些模块连起来就好，<strong>确实，这样做十分的直观，就是对P3CPU的一个翻译</strong>，但对于扩展是极为不友好的，输入位数，输入个数这两个里面有一个变了，就要写一个新的MUX，那么在上机中，我们的时间就会被浪费，因此，笔者认为应直接在DataPath中采用这样的写法：<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MEM_ToReg</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] E_MemToReg = (E_MemToReg_sign == <span class="number">1</span>) ? <span class="number">32&#x27;d0</span> : </span><br><span class="line">                            (E_MemToReg_sign == <span class="number">2</span>) ?  EX_PC + <span class="number">8</span> : <span class="number">32&#x27;d0</span>;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] M_MemToReg = (M_MemToReg_sign == <span class="number">1</span>) ? <span class="number">32&#x27;d0</span> : </span><br><span class="line">                            (M_MemToReg_sign == <span class="number">2</span>) ?  MEM_PC + <span class="number">8</span> : MEM_ALU_Result;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">31</span>:<span class="number">0</span>] W_MemToReg = (W_MemToReg_sign == <span class="number">1</span>) ? WB_DM_RD : </span><br><span class="line">                            (W_MemToReg_sign == <span class="number">2</span>) ?  WB_PC + <span class="number">8</span> : WB_ALU_Result;</span><br><span class="line"><span class="comment">//MEM_ToReg</span></span><br></pre></td></tr></table></figure><br>这样的写法或许不如前面那种模块化写法理解直观，但这样写的好处就是，扩展十分的方便，只需在三目运算符中再次添加条件即可，是<strong>绝对快于</strong>添加MUX然后再连线的。</p><h2 id="删除转发模块"><a href="#删除转发模块" class="headerlink" title="删除转发模块"></a>删除转发模块</h2><p>有一种东西叫全力转发，这个已经是被证明是理论正确的了，如果想了解更多可以看一下这位学长的博客(<a href="https://thysrael.github.io/posts/59164957/">https://thysrael.github.io/posts/59164957/</a>)<br>采用全力转发将无需转发模块（Forward）的存在，可以减轻在课上加指令时还需要考虑转发的负担，只需考虑阻塞即可。<br>细心的小伙伴可以发现，笔者并没有采用全力转发的思路，这是因为笔者在一开始认为这种全力转发会导致一些特殊指令的难以添加，所以不敢以身试险，做了一个保守决策，但笔者一学期下来并没有遇到这种特殊指令，所以大家应该是可以放心使用的。</p><h1 id="解读指令集描述"><a href="#解读指令集描述" class="headerlink" title="解读指令集描述"></a>解读指令集描述</h1><h2 id="I和I-1"><a href="#I和I-1" class="headerlink" title="I和I+1"></a>I和I+1</h2><p>原文如下：<br><img src="I和I+1.png" alt="I和I+1"><br>大意是讲，I和I+1分类的标准在于效果生效的时间，I表示I内的内容效果在<font color="red">本条指令</font>生效，I+1则表示I+1内的内容效果在<font color="red">下一条指令</font>生效。<br>Tips:这里的下一条指的是正常顺序执行的下一条指令，而且I+1与下一条指令生效的先后顺序不会影响结果。<br>其实看到这里，有聪明的小伙伴就可以看出，I+1这种东西，大概率是和延迟槽挂钩的，如果不存在延迟槽，就不会存在本条指令的执行效果在下一条指令生效的情况。举个例子：Beq这条指令，STL描述如下：<br><img src="Beq.png" alt="Beq"><br>它的PC&lt;-PC+target是在I+1中的，想一想为什么会这样？<br>假如PC&lt;-PC+target在I中，那么在本条指令中，PC值就已经跳转，那么下一条指令就已经执行的是跳转后的指令了，<font color="red">延迟槽消失了！</font><br>假如PC&lt;-PC+target在I+1中，在执行下一条指令时才改变PC的值，<font color="red">延迟槽是不是就出现了？ </font><br><strong>现在，大家明白了I和I+1的区别了吗？进而，大家明白I+n和I-n的含义了吗？</strong><br>但其实，根据笔者上机经验来看，无需考虑这么多，<font color="red">把I和I+1的功能直接实现了即可</font>，这里就算个小科普吧！   </p><h2 id="NullilyCurrentInstruction"><a href="#NullilyCurrentInstruction" class="headerlink" title="NullilyCurrentInstruction()"></a>NullilyCurrentInstruction()</h2><p>意思为清空延迟槽，我们以一道例题做解释：</p><h3 id="例题：Bonall"><a href="#例题：Bonall" class="headerlink" title="例题：Bonall"></a>例题：Bonall</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RTL：</span><br><span class="line">I:   target_offest &lt;- sign(offest||0^2)</span><br><span class="line">     condition &lt;- GPR[rs] + GPR[rt] = 0</span><br><span class="line">     GPR[31] &lt;- PC + 8</span><br><span class="line">  </span><br><span class="line">I+1: if condition:</span><br><span class="line">PC &lt;- PC + starget_offest</span><br><span class="line">      else:</span><br><span class="line">NullilyCurrentInstruction()</span><br><span class="line">      endif</span><br></pre></td></tr></table></figure>  <p><strong>顺带大家可以复习一下第一条知识:</strong>为什么NullilyCurrentInstruction会被翻译为清空延迟槽而不是直译为清空当前指令？<br>这个操作理解起来很好理解，就是把延迟槽的指令屏蔽掉嘛，但怎么实现需要我们好好考虑一下：</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>以bonall为例，如果是bonall指令并且不跳转，则要清除延迟槽，则生成一个flush信号，如果flush有效<font color="red">并且没有处于阻塞状态</font>，则 flush一下FD级流水线寄存器即可。<br><strong>Tips:</strong>如果在阻塞状态下清楚了FD流水线寄存器，则相当于清除了bonall这条指令，这显然不正确。   </p><p><strong>记住我们的目标：清除的是延迟槽，只有不在阻塞的状态下，下一次流水到FD寄存器的才正好是延迟槽指令！</strong></p><h2 id=""><a href="#" class="headerlink" title="||"></a>||</h2><h3 id="例题：Lwbti"><a href="#例题：Lwbti" class="headerlink" title="例题：Lwbti"></a>例题：Lwbti</h3><p>在lw指令的基础上，将要写入的寄存器的编号改为rt的访存结果前五位这两者无符号比较结果的最大值。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RTL：</span><br><span class="line">vaddr &lt;- GRF[base] + sign_extend(offset)</span><br><span class="line">paddr &lt;- vaddr31...2||0^2</span><br><span class="line">memWord &lt;- memory[paddr]</span><br><span class="line">index &lt;- max(memWord[31:27],rt)</span><br><span class="line">GRF[index] &lt;- memWord</span><br></pre></td></tr></table></figure>  </p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>由memory[paddr],知paddr为32位，所以，<strong>||的意思就是拼接</strong></p><h2 id="x…y"><a href="#x…y" class="headerlink" title="x…y"></a>x…y</h2><h3 id="例题：Lwbti-1"><a href="#例题：Lwbti-1" class="headerlink" title="例题：Lwbti"></a>例题：Lwbti</h3><h3 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h3><p>由memory[paddr],知paddr为32位，所以，<strong>x…y的意思就是取变量的x-y位</strong></p><h1 id="添加指令"><a href="#添加指令" class="headerlink" title="添加指令"></a>添加指令</h1><h2 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h2><p>（1）Control模块添加指令对应的OPCode<br>（2）在对应模块中实现相应功能<br>（3）在Datapath中连线<br>（4）回到Control写控制信号<br>（5）转发阻塞</p><h2 id="Fuction"><a href="#Fuction" class="headerlink" title="Fuction"></a>Fuction</h2><p>很多时候，如果一个功能实现过于复杂，我们有希望将其用assign实现，那么我们往往需要函数作为支持 <strong>（always@（*）块可以直接替代）</strong></p><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><p>1）不含有任何延迟、时序或时序控制逻辑<br>2）至少有一个输入变量<br>3）只有一个返回值，且没有输出<br>4）不含有非阻塞赋值语句<br>5）函数可以调用其他函数，但是不能调用任务</p><h3 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> [range]     function_id ;</span><br><span class="line">input_declaration ;</span><br><span class="line">other_declaration ;</span><br><span class="line">procedural_statement ;</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>  <h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><p>函数通过指明函数名与输入变量进行调用。函数结束时，返回值被传递到调用处。</p><h3 id="调用实例"><a href="#调用实例" class="headerlink" title="调用实例"></a>调用实例</h3><pre><code>function [31:0] cal;input [31:0] RDD:input [l:0] Lower;input iss_lbget;begin    if(iss lbget &amp;_ Lower == 2&#39;d0) begin        cal = &#123; &#123;24&#123;RDD[7]&#125;&#125;,RDD[7:0] &#125;;    end    else if(iss lbget &amp;&amp; Lower = 2&#39;dl) begin        cal = &#123; &#123;24&#123;RDD[15]&#125;&#125;,RDD[15:8] &#125;;    end    else if(iss lbget &amp; Lower == 2&#39;d2) begin        cal = &#123; &#123;24&#123;RDD[23]&#125;&#125;,RDD[23:16] &#125;;    end    else if(iss lbget &amp; Lower == 2&#39;d3) begin        cal = &#123; &#123;24&#123;RDD[31]&#125;&#125;,RDD[31:24] &#125;;    end    else begin        cal = RDD:    endendendfunction</code></pre><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>如果你加入了 <strong>`default_nettype none</strong> 这条代码,注意别将函数写成这样：</p><pre><code>function [31:0] cal;input wire [31:0] RDD:input wire [l:0] Lower;input wire iss_lbget;begin    if(iss lbget &amp;_ Lower == 2&#39;d0) begin        cal = &#123; &#123;24&#123;RDD[7]&#125;&#125;,RDD[7:0] &#125;;    end    else if(iss lbget &amp;&amp; Lower = 2&#39;dl) begin        cal = &#123; &#123;24&#123;RDD[15]&#125;&#125;,RDD[15:8] &#125;;    end    else if(iss lbget &amp; Lower == 2&#39;d2) begin        cal = &#123; &#123;24&#123;RDD[23]&#125;&#125;,RDD[23:16] &#125;;    end    else if(iss lbget &amp; Lower == 2&#39;d3) begin        cal = &#123; &#123;24&#123;RDD[31]&#125;&#125;,RDD[31:24] &#125;;    end    else begin        cal = RDD:    endendendfunction</code></pre><p><strong>这样会直接报错，因为函数的定义内不能写明wire或者reg</strong></p><h2 id="计算指令，跳转指令，访存指令添加方法论"><a href="#计算指令，跳转指令，访存指令添加方法论" class="headerlink" title="计算指令，跳转指令，访存指令添加方法论"></a>计算指令，跳转指令，访存指令添加方法论</h2><h3 id="计算指令"><a href="#计算指令" class="headerlink" title="计算指令"></a>计算指令</h3><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><strong>鲁迅说：计算简单，上来先秒计算。</strong><br>笔者说：别听他胡咧咧，笔者被坑成傻子了。<br>综上所述：计算一般而言是比较简单的，但要难也可以难到爆炸，比如：实现二维数组冒泡排序<br>或者我们换句话说：计算的难度永远都在实现计算功能这个操作上，阻塞和转发都是十分简单的。<br>因此在这里，没有什么具体的方法论，重心就在于实现功能上，P5大概率ALU，P6大概率MDU，而这个往往因题而异。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="SWC.png" alt="SWC"></p><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p>跳转指令是有规律可循的，大概分为两类，一种是条件链接，一种是非条件链接。<br>对于条件链接，需要我们流水线传递一个信号D_jump，在D级得出是否需要写入，在W级根据D_jump进行写入<br>对于非条件链接，直接写5’d31<br>其余就是正常的更改CMP产生比较信号，在NPC中根据比较信号和比较指令信号进行PC值的更改。<br>阻塞和转发类似于Jal和Beq的混合处理，也比较简单。<br><strong>Tips</strong> 这个题几乎是必做， <strong>因为掌握后它的变化最少，最容易实现</strong></p><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><h5 id="条件链接"><a href="#条件链接" class="headerlink" title="条件链接"></a>条件链接</h5><p><img src="BLZTAL.png" alt="BLZTAL">   </p><h5 id="非条件链接"><a href="#非条件链接" class="headerlink" title="非条件链接"></a>非条件链接</h5><p><strong>Bgezall</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RTL：</span><br><span class="line">I:</span><br><span class="line">  target_offset &lt;- signed_ext(offset||0^2)</span><br><span class="line">  condition &lt;- GPR[rs] &gt;= 0 </span><br><span class="line">  GPR[31] &lt;- PC + 8</span><br><span class="line">I+1: </span><br><span class="line">  if condition then</span><br><span class="line">    PC &lt;- PC + 4 + target_offset</span><br><span class="line">  else</span><br><span class="line">    NullilyCurrentInstruction()</span><br></pre></td></tr></table></figure></p><h3 id="访存指令"><a href="#访存指令" class="headerlink" title="访存指令"></a>访存指令</h3><h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>访存被很多人认为是最难的，但其实掌握后也不难。<br>它其实也是那种一眼难，会了以后也是有一定的规律的题<br>他们大多都是条件访存，只有从DM取出来内容后我们才知道到底往哪里写，我们这里可以统一在WB写的时候在Datapath中生成一个条件信号。<br>例如judge信号，直接在Datapath写组合逻辑判断好后送给Control，结合指令信号进行一起判断，产生控制信号<br>例如grf信号，直接在Datapath写组合逻辑判断好后送给Control作为一个备选的grf目标。<br><strong>阻塞和转发一定要尽力做好，在D级可以排除一些寄存器我们就要尽力排除，让无关指令不需暂停，否则大概率TLE，这点和往年不太一样，往年可能暴力阻塞也可以通过</strong></p><h4 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h4><h5 id="Judge信号"><a href="#Judge信号" class="headerlink" title="Judge信号"></a>Judge信号</h5><p><img src="LWIE.png" alt="LWIE"></p><h5 id="Grf信号"><a href="#Grf信号" class="headerlink" title="Grf信号"></a>Grf信号</h5><p><img src="Lwbti.png" alt="Lwbti"></p><h1 id="Mars课上测试指令构造技巧"><a href="#Mars课上测试指令构造技巧" class="headerlink" title="Mars课上测试指令构造技巧"></a>Mars课上测试指令构造技巧</h1><h2 id="写在开头-1"><a href="#写在开头-1" class="headerlink" title="写在开头"></a>写在开头</h2><font size = 5><font color="red">一定要做Mars测试！</font></font>   <font size = 5><font color="red">一定要做Mars测试！</font></font><font size = 5><font color="red">一定要做Mars测试！</font></font>   <p>不管是为正确性也好，还是为了RTL表述错误/不准确，我们都必须使用class文件进行测试。而测试点是绝对以class文件的行为为准的。<br>不要相信自己一定可以肉眼de出来，这种自信是盲目的自信，笔者深受其害，大多数时候做一条指令就能复现的问题，肉眼可能得考虑半天也出不来。<br>笔者亲身体会P5时跳转指令RTL描述和class文件有一点点的出入，按照RTL全错，按照Class直接过，如果不拿class文件做测试，这道题必定过不了。</p><h2 id="计算指令-1"><a href="#计算指令-1" class="headerlink" title="计算指令"></a>计算指令</h2><p>正数，负数，0都测试一下，只需三条，也比较简单。</p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p><strong>原地跳</strong>，向前跳，向后跳<br>一定注意原地跳，这个是错点最多的情况，我眼睁睁看着我的一个好友没有测原地跳导致挂了一P。</p><h2 id="条件访存"><a href="#条件访存" class="headerlink" title="条件访存"></a>条件访存</h2><p>先存一个数值进去<br>然后进行条件访存<br>确保访存内容不为0即可</p><h1 id="悄悄话"><a href="#悄悄话" class="headerlink" title="悄悄话"></a>悄悄话</h1><p>更多课上习题见:<br><a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P5">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P5</a><br><a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P6">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P6</a></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P6 </tag>
            
            <tag> 北航计算机组成-P5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂流水线CPU全自动测试思路（Verilog）</title>
      <link href="/posts/42542/"/>
      <url>/posts/42542/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P6的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><font size = 3><font color="purple">由于P6是P5的迭代开发，因此本次工作将主要体现在数据生成上</font></font><h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><font size = 3><font color="red">无需，前面的完全够用</font></font><h1 id="Python实现（数据执行器）"><a href="#Python实现（数据执行器）" class="headerlink" title="Python实现（数据执行器）"></a>Python实现（数据执行器）</h1><font size = 3><font color="red">无需，照搬P5即可，具体见我的前几篇博客</font></font><h1 id="数据生成器迭代思路"><a href="#数据生成器迭代思路" class="headerlink" title="数据生成器迭代思路"></a>数据生成器迭代思路</h1><h2 id="P6指令集"><a href="#P6指令集" class="headerlink" title="P6指令集"></a>P6指令集</h2><p><strong>{add,sub,and,or,slt,sltu,addi,andi,ori,lb,lh,lw,sb,sh,sw,mult,multu,div,divu,mfhi,mflo,mthi,mtlo,beq,bne,lui,jal,jr,nop}</strong></p><h2 id="迭代思路"><a href="#迭代思路" class="headerlink" title="迭代思路"></a>迭代思路</h2><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><h4 id="等同与不等同"><a href="#等同与不等同" class="headerlink" title="等同与不等同"></a>等同与不等同</h4><font color="purple">找到同类，直接归类</font>  <font color="red">没有同类，单独添加</font>         <p>我举个例子，or,and,slt,sltu都是cal_r类型，可以直接和P5数据生成器中的add,sub等同处理。<br>lb,lh可以等同lw处理。<br>sb,sh可以等同sw处理。<br>等同的意思是，代码可以复用，规则可以复用。<br>对于mult,div则不可以，需要新规则的限制。<br>做完这些，大部分我们就归类完毕了，之后就是对于新规则的修修补补，维持程序正确</p><h4 id="危险指令与安全指令"><a href="#危险指令与安全指令" class="headerlink" title="危险指令与安全指令"></a>危险指令与安全指令</h4><p>要这样考虑是为了逻辑上的简便，和作为指令生成时随机范围的依据，例如add,sub,and,or这些，就是安全指令，因为他们无论如何都不会引起异常，所以他们可以在任何位置生成（开头，代码块，延迟槽）……<br>而lw,sw,div这些，则是危险指令，对他们的操作稍有不慎，就会导致Mars报错，div不能除0，lw，sw要求地址合理，要求字对齐，而这些规则的处理，在随机生成中是需要我们提前用一些指令规避这些问题的，所以某些规则下生成的他们就不能出现在延迟槽中，因为不止一条指令。</p><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><h4 id="div除0的处理"><a href="#div除0的处理" class="headerlink" title="div除0的处理"></a>div除0的处理</h4><p>div和divu是不能除0的，这在数学上本就不被允许，在Mars中是一种UB（未定义）行为，所以我们需要添加规则避免除0现象的产生：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rss= rs;</span><br><span class="line"><span class="type">int</span> rtt = rt;</span><br><span class="line"><span class="keyword">while</span>(rtt==<span class="number">0</span>) #避免<span class="number">0</span>号寄存器对后面的影响</span><br><span class="line">&#123;</span><br><span class="line">    rtt = Reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(rss==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">rss = Reg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ori</span>(rtt,rss,I+<span class="number">4</span>,<span class="number">0</span>); </span><br><span class="line"><span class="built_in">ori</span>(rtt,rss,I+<span class="number">4</span>,<span class="number">0</span>); <span class="meta">#ori两个不同的立即数保证除数不为0</span></span><br><span class="line"><span class="type">int</span> delay = Delayinstr; #抽取随机数决定抽取指令池中的哪条指令</span><br><span class="line"><span class="keyword">while</span>(delay == <span class="number">8</span>||delay == <span class="number">9</span>) # <span class="number">8</span>，<span class="number">9</span>为div和divu，我们这里不允许嵌套，所以要重新抽取</span><br><span class="line">&#123;</span><br><span class="line">delay = Delayinstr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Choose</span>(delay, <span class="number">0</span>, rss, rtt, rs, rt, <span class="number">0</span>); #生成抽取好的指令，后面的参数是生成时寄存器不会选择rss,rtt,rs,rt（概率不生成）</span><br><span class="line">delay = Delayinstr;</span><br><span class="line"><span class="keyword">while</span>(delay == <span class="number">8</span>||delay == <span class="number">9</span>)</span><br><span class="line">&#123;</span><br><span class="line">delay = Delayinstr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Choose</span>(delay, <span class="number">0</span>, rss, rtt, rs, rt, <span class="number">0</span>);  #同理（概率不生成）</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;divu $%d,$%d\n&quot;</span>, rtt, rss); 核心人物</span><br></pre></td></tr></table></figure><br>以上代码便是对div,divu规则的具体表现，具体体现为，避免0寄存器的影响；在div这条指令的前1-2，2-3或3-4均为ori，保证除数不为0，至于为什么中间可能会插入两条指令，就是为了我P5时所说的那样，<strong>实现不同的转发级别。增强测试能力。</strong></p><h4 id="指令类的生成"><a href="#指令类的生成" class="headerlink" title="指令类的生成"></a>指令类的生成</h4><p>细细察看我的代码生成，会发现我在尽力保持一种原则，及时是固定3条指令，我也会尽可能将这3条指令变为指令类，进行生成，这样既保证了正确性，也能提高随机性：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sw $0,0($0)\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> imm = Ib;</span><br><span class="line"><span class="built_in">sub</span>(rt, rt, rt);</span><br><span class="line"><span class="built_in">ori</span>(rt, rt, <span class="number">12</span>, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> random = <span class="built_in">rand</span>() % <span class="number">3</span>; </span><br><span class="line"><span class="keyword">if</span>(random == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,0($0)\n&quot;</span>, rt);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,0($0)\n&quot;</span>, rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,0($0)\n&quot;</span>, rt);</span><br><span class="line">&#125;</span><br><span class="line">random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(random == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lw $%d,0($0)\n&quot;</span>, rs);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,0($0)\n&quot;</span>, rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,0($0)\n&quot;</span>, rs);</span><br><span class="line">&#125;</span><br><span class="line">random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(random == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lh $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lb $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125;</span><br><span class="line">random = <span class="built_in">rand</span>() % <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span>(random == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($0)\n&quot;</span>, rt, Ib);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($0)\n&quot;</span>, rt, Ib);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(random == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($0)\n&quot;</span>, rt, Ib);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><br>这一段代码是我为了解决load和store指令冲突的规则之一，会发现，我在生成这些指令时，看着复杂，实际上就是指令类的随机生成，store-load-load-store,这样既能测试转发和阻塞，又能保证正确性。   </p><font color="red">TIPS：由于Lb只能存1个字节，所以随机数Ib的生成范围应该在0-255之间，否则可能会出现sw了一个400，lb取出来就不是400，导致后面出错。</font><h4 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h4><p>刚才我在总体思路里说明了，对于类似指令下的已有规则，我们可以直接复用，不需创造新规则，这样稳定又高效，展示一个例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sw_sh_sb</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> rt)</span> #原来是sw的生成函数的一部分，直接改为sw_sh_sb的生成函数</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = Reg % <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> imm = Ib;</span><br><span class="line">        <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">        <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rs == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rs++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> imm1 = Ib;</span><br><span class="line">        <span class="type">int</span> imm2 = Ib;</span><br><span class="line">        <span class="keyword">if</span> (imm1 &lt; imm2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = imm1;</span><br><span class="line">            imm1 = imm2;</span><br><span class="line">            imm2 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">        <span class="built_in">ori</span>(rs, rs, imm1, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> imm3 = <span class="number">0</span> - imm2;</span><br><span class="line">        <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rt, imm3, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((Reg % <span class="number">3</span>) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sh $%d,%d($%d)\n&quot;</span>, rt, imm3, rs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sb $%d,%d($%d)\n&quot;</span>, rt, imm3, rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如上，这个函数在P5中是sw生成规则的一部分，具体是为了加入负数检验EXT模块的正确性，在P6它便可以摇身一变，成为sw_sh_sb生成规则的一部分，我们要做的，只是添加一个随机的功能，抽取一个Store类即可。  </p><h4 id="jr和jal的处理"><a href="#jr和jal的处理" class="headerlink" title="jr和jal的处理"></a>jr和jal的处理</h4><p>这个话题是老生常谈的，也是数据生成中最大的问题，稍微动错一点，就会导致跳转错误。所以我们对这两个的转发和阻塞实现可以从两个方面下手：<br>（1）让他们作为转发人，作为阻塞源：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#前面是jal,刚对$<span class="number">31</span>进行了写入</span><br><span class="line"><span class="keyword">if</span>(Reg%<span class="number">3</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;mult $31,$%d\n&quot;</span>,Reg);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Reg%<span class="number">3</span>==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;multu $31,$%d\n&quot;</span>,Reg);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(Reg%<span class="number">3</span>==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;divu $%d,$31\n&quot;</span>,Reg);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;div $%d,$31\n&quot;</span>,Reg);</span><br></pre></td></tr></table></figure><br>这是我生成规则中，对于jal和乘除指令的一个特殊生成规则，有个小细节就是，在div中，保证$31作为除数，因为它绝对不为0，可以省去考虑div为0的步骤。<br>（2）作为被转发人，作为被阻塞源：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g = Reg % <span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span> (g == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">    <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">    <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  </span></span><br><span class="line">    <span class="built_in">add</span>(rd, <span class="number">0</span>, <span class="number">31</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">    <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">    <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  $31=0</span></span><br><span class="line">    <span class="built_in">ori</span>(rd, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> immi = I;</span><br><span class="line">    <span class="built_in">sub</span>(rt, rt, rt);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, <span class="number">31</span>, immi, rt);</span><br><span class="line">    <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, <span class="number">31</span>, immi, rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">    <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="built_in">sub</span>(rd, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g==<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">mtlo</span>(<span class="number">31</span>);</span><br><span class="line">    <span class="built_in">mthi</span>(<span class="number">31</span>);</span><br><span class="line">    <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">if</span>(Reg%<span class="number">2</span>) <span class="built_in">mflo</span>(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">mfhi</span>(<span class="number">31</span>);      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总体思路就是：把$31的值挪走，再挪回来。 </p><font color="red">有一个很遗憾的一点是，在这里对于$31的处理要小心加小心，因此难以实现指令类的随机，导致了随机性的有所下降，这个也只能通过不断地添加特殊指令序列去增强随机，笔者由于时间原因也只写了5条，这可能就是随机生成法的一个缺陷吧.</font>            <font color="purple">所以笔者寒假也在尝试一些新的数据生成方式，有所作为的话一定会再次开贴更新，先画个饼先~</font>   <h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;grade&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;forward&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;average&quot;</span>: <span class="number">95.06304176516942</span>,</span><br><span class="line">    <span class="string">&quot;stall&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;average&quot;</span>: <span class="number">95.52380952380952</span>,</span><br></pre></td></tr></table></figure><h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P6">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P6</a></p><p><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P6课上强测！</font></strong></p><p><strong><font size = 5>P6数据生成器代码行数：823行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂流水线CPU设计文档（Verilog）</title>
      <link href="/posts/45102/"/>
      <url>/posts/45102/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Verilog 复杂流水线CPU设计文档</center></font></strong></p><h1 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h1><h2 id="总体设计综述"><a href="#总体设计综述" class="headerlink" title="总体设计综述"></a>总体设计综述</h2><p>使用Verilog开发一个流水线CPU,总体概述如下：<br>1.此流水线CPU为32位CPU<br>2.此CPU为流水线设计<br>3.此CPU支持的指令集为:{add,sub,and,or,slt,sltu,addi,andi,ori,lb,lh,lw,sb,sh,sw,mult,multu,div,divu,mfhi,mflo,mthi,mtlo,beq,bne,lui,jal,jr,nop}<br>4.nop的机器码为0x0000000<br>5.add，sub不支持溢出</p><h2 id="关键模块定义"><a href="#关键模块定义" class="headerlink" title="关键模块定义"></a>关键模块定义</h2><h3 id="IM-外置"><a href="#IM-外置" class="headerlink" title="IM(外置)"></a>IM(外置)</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i_inst_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">需要进行取指操作的流水级 PC（一般为 F 级）</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i_inst_rdata[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">i_inst_addr 对应的 32 位指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">取指</td><td style="text-align:center">利用PC取出对应位置处的指令</td></tr></tbody></table></div><h3 id="F-PC"><a href="#F-PC" class="headerlink" title="F_PC"></a>F_PC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前PC值</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">更改PC值</td><td style="text-align:center">利用NPC更改PC值</td></tr></tbody></table></div><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">A3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其作为RD的写入地址</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位写入数据</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A2指定寄存器的32位数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号，清零32个寄存器中的数据</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">同步复位</td><td style="text-align:center">时钟上升沿到来时，若RESET信号有效，则将32个寄存器中的数据全部清除</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A1与A2所存地址对应的寄存器的数据读出到RD1和RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD写入到A3所存地址对应的寄存器中</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">转发数据</td><td style="text-align:center">当A3\==A2或A3\==A1且WE有效，A3!=0时，将WD中的数据作为RD1或RD2的输出</td></tr></tbody></table></div><h3 id="ID-ID-REG"><a href="#ID-ID-REG" class="headerlink" title="ID_ID_REG"></a>ID_ID_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">IF_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段机器码</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">IF_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">ID阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">O</td><td style="text-align:center">扩展类型信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">O</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RegWrite</td><td style="text-align:center">O</td><td style="text-align:center">寄存器写使能信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MemWrite</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">MemToReg[2:0]</td><td style="text-align:center">O</td><td style="text-align:center">Reg写入数据类型信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">RegDest[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">A3寄存器选择信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ALUop[3:0]</td><td style="text-align:center">O</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">O</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">O</td><td style="text-align:center">Jr信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">RegSrc</td><td style="text-align:center">O</td><td style="text-align:center">ALU数据来源选择信号</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">imm16[15:0]</td><td style="text-align:center">O</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">imm26[25:0]</td><td style="text-align:center">O</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">rs[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rs寄存器编号</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">rt[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rt寄存器编号</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">rd[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rd寄存器编号</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">load</td><td style="text-align:center">O</td><td style="text-align:center">是否为lw指令</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">store</td><td style="text-align:center">O</td><td style="text-align:center">是否为sw指令</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">cal_r</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_r类指令</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">cal_i</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_i类指令</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">jal</td><td style="text-align:center">O</td><td style="text-align:center">是否为jal指令</td></tr></tbody></table></div><p>(2)真值表</p><div class="table-container"><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">add</th><th style="text-align:center">sub</th><th style="text-align:center">ori</th><th style="text-align:center">lw</th><th style="text-align:center">sw</th><th style="text-align:center">lui</th><th style="text-align:center">beq</th><th style="text-align:center">Jal</th><th style="text-align:center">Jr</th></tr></thead><tbody><tr><td style="text-align:center">OP</td><td style="text-align:center">000000</td><td style="text-align:center">000000</td><td style="text-align:center">001101</td><td style="text-align:center">100011</td><td style="text-align:center">101011</td><td style="text-align:center">001111</td><td style="text-align:center">000100</td><td style="text-align:center">000011</td><td style="text-align:center">000000</td></tr><tr><td style="text-align:center">FC</td><td style="text-align:center">100000</td><td style="text-align:center">100010</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">001000</td></tr><tr><td style="text-align:center">ALUop</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0011</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0100</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">Jump</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">RegWrite</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemWrite</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemToReg</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegDest</td><td style="text-align:center">01</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegSrc</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Branch</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jreg</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">B[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Equal</td><td style="text-align:center">O</td><td style="text-align:center">A==B？1：0</td></tr></tbody></table></div><p>(2)功能定义<br>|  序号   | 功能 | 描述 |<br>|  :——:  | :——:  | :——: |<br>|1|比较|比较操作数A与B是否相等，相等则Equal有效|</p><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">F_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段的PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段的PC值</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Beq指令</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jal指令</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jr指令</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Jal_imm26[25:0]</td><td style="text-align:center">I</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">D_GRF_Jr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">Jr目标寄存器数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">Beq_imm16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">Equal</td><td style="text-align:center">I</td><td style="text-align:center">D_CMP两操作数是否相等</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">PC的下一值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">计算下一PC的值</td><td style="text-align:center">根据指令和当前PC值计算下一PC值</td></tr></tbody></table></div><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">经过扩展后的32位立即数</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">I</td><td style="text-align:center">选择扩展类型信号  0：符号扩展 1：无符号扩展</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">符号扩展</td><td style="text-align:center">将16位立即数符号扩展为32位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">无符号扩展</td><td style="text-align:center">将16位立即数无符号扩展为32位立即数</td></tr></tbody></table></div><h3 id="ID-EX-REG"><a href="#ID-EX-REG" class="headerlink" title="ID_EX_REG"></a>ID_EX_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_RD1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">D_imm32[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段32位立即数</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">EX_RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">EX_imm32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段32位立即数</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">EX阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ALUControl[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">运算结果</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">判断两个操作数是否相等</td><td style="text-align:center">相等则Bigger输出1否则为0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">加运算</td><td style="text-align:center">res=SrcA+SrcB</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">减运算</td><td style="text-align:center">res=SrcA-SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">与运算</td><td style="text-align:center">res=SrcA$SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">或运算</td><td style="text-align:center">res=SrcA或SrcB</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">加载高位运算</td><td style="text-align:center">res={SrcB[15:0],16’h0}</td></tr></tbody></table></div><h3 id="E-MDU"><a href="#E-MDU" class="headerlink" title="E_MDU"></a>E_MDU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">start</td><td style="text-align:center">I</td><td style="text-align:center">开始信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MDUop[2:0]</td><td style="text-align:center">I</td><td style="text-align:center">MDU功能选择信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">HIWrite</td><td style="text-align:center">I</td><td style="text-align:center">HI寄存器写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">LOWrite</td><td style="text-align:center">I</td><td style="text-align:center">LO寄存器写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">HIRead</td><td style="text-align:center">I</td><td style="text-align:center">读HI寄存器信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">LORead</td><td style="text-align:center">I</td><td style="text-align:center">读LO寄存器信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">HI[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">HI寄存器</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">LO[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">LO寄存器</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">busy</td><td style="text-align:center">O</td><td style="text-align:center">MDU模块忙信号</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">MDU_res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MDU结果信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">无符号乘</td><td style="text-align:center">{HI_temp,LO_temp} = SrcA * SrcB</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">符号乘</td><td style="text-align:center">{HI_temp,LO_temp} = $signed(SrcA) * $signed(SrcB)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">符号除</td><td style="text-align:center">HI = $signed(SrcA) % $signed(SrcB)</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">符号除</td><td style="text-align:center">LO = $signed(SrcA) \ $signed(SrcB)</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">无符号除</td><td style="text-align:center">HI = SrcA % SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">无符号除</td><td style="text-align:center">LO = SrcA \ SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">读写HI寄存器</td><td style="text-align:center">mfhi读，mthi写</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">读写LO寄存器</td><td style="text-align:center">mflo读，mflo写</td></tr></tbody></table></div><h3 id="EX-MEM-REG"><a href="#EX-MEM-REG" class="headerlink" title="EX_MEM_REG"></a>EX_MEM_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">MEM_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">MEM阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="DM（外置）"><a href="#DM（外置）" class="headerlink" title="DM（外置）"></a>DM（外置）</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">m_data_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">m_data_rdata[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">32位数据输出</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">m_data_wdata[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位数据输入</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">m_inst_addr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">M级PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">m_inst_byteen[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">字节使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">写入数据</td><td style="text-align:center">当时钟上升沿到来时，根据字节使能信号中的有效位将WD中的数据写入到A所存地址所对应的位处</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A所存地址对应位置的数据读出到RD</td></tr></tbody></table></div><h3 id="M-BE"><a href="#M-BE" class="headerlink" title="M_BE"></a>M_BE</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[1:0]</td><td style="text-align:center">I</td><td style="text-align:center">DM地址的低两位</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Din[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">DM读出数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Op[2:0]</td><td style="text-align:center">I</td><td style="text-align:center">BE功能选择</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Dout[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">BE数据输出</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">处理DM数据</td><td style="text-align:center">根据A和OP处理数据，使其符合指令行为</td></tr></tbody></table></div><h3 id="MEM-WB-REG"><a href="#MEM-WB-REG" class="headerlink" title="MEM_WB_REG"></a>MEM_WB_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">MEM_DM_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段DM读出数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WB_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WB_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">WB_DM_RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段DM读出数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">WB_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">WB阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Stall"><a href="#Stall" class="headerlink" title="Stall"></a>Stall</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">D_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Stall</td><td style="text-align:center">O</td><td style="text-align:center">阻塞信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">阻塞功能</td><td style="text-align:center">判断当前流水线是否需要在ID阶段阻塞</td></tr></tbody></table></div><p>(3)判断方法——AT法</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">rsTuse</th><th style="text-align:center">rtTuse</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">slt</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sltu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">addi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">andi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lb</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lh</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sb</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">sh</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">bne</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">mult</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">multu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">div</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">divu</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">mthi</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mtlo</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">0</td><td style="text-align:center">-</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">E_Tnew</th><th style="text-align:center">M_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">slt</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sltu</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">addi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">andi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">lh</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">lb</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sh</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sb</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">mfhi</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">mflo</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">bne</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><h3 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">W_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_Forward</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">MEM_Forward</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">WB_Forward</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段数据是否可以转发信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">转发信号</td><td style="text-align:center">判断每个阶段是否可以为前面转发数据</td></tr></tbody></table></div><h1 id="转发暂停控制"><a href="#转发暂停控制" class="headerlink" title="转发暂停控制"></a>转发暂停控制</h1><h2 id="暂停："><a href="#暂停：" class="headerlink" title="暂停："></a>暂停：</h2><pre><code>wire Stall_MDU = busy &amp;&amp; ( D_MDU_c || D_MDU_f || D_MDU_t );wire Stall_rs_E = (E_RegDest == D_rs) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rs &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_rt_E = (E_RegDest == D_rt) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rt &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_E = Stall_rs_E || Stall_rt_E;wire Stall_rs_M = (M_RegDest == D_rs) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rs &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_rt_M = (M_RegDest == D_rt) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rt &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_M = Stall_rs_M || Stall_rt_M;assign Stall = Stall_M || Stall_E || Stall_MDU;     </code></pre><h2 id="转发："><a href="#转发：" class="headerlink" title="转发："></a>转发：</h2><pre><code>wire [31:0] D_Forward_rs = (D_rs == 0)? 0 :            ((E_RegDest == D_rs) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :        ((M_RegDest == D_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD1;wire [31:0] D_Forward_rt = (D_rt == 0)? 0 :            ((E_RegDest == D_rt) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :            ((M_RegDest == D_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD2;wire [31:0] E_Forward_rs =   (E_rs == 0) ? 0 :        ((M_RegDest == E_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rs) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD1;wire [31:0] E_Forward_rt =   (E_rt == 0) ? 0 :        ((M_RegDest == E_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rt) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD2;wire [31:0] M_WD_Forward = (M_rt == 0) ? 0 :        ((W_RegDest == M_rt) &amp;&amp; (WB_Forward) &amp;&amp; (W_RegWrite)) ? W_MemToReg : MEM_RD2;</code></pre><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><h2 id="（1）测试代码"><a href="#（1）测试代码" class="headerlink" title="（1）测试代码"></a>（1）测试代码</h2><p>为<strong>自动化测试</strong>：<br>共随机生成1000组数据<br><img src="微信截图_20221106010804.png" alt="数据示意1"><br>并生成1000组比对文件<br><img src="微信截图_20221106010955.png" alt="数据示意2"><br>和一个总体结果文件<br><img src="微信截图_20221106011047.png" alt="数据示意3"></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="（1）为什么需要有单独的乘除法部件而不是整合进-ALU？为何需要有独立的-HI、LO-寄存器？"><a href="#（1）为什么需要有单独的乘除法部件而不是整合进-ALU？为何需要有独立的-HI、LO-寄存器？" class="headerlink" title="（1）为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？"></a>（1）为什么需要有单独的乘除法部件而不是整合进 ALU？为何需要有独立的 HI、LO 寄存器？</h3><p>答：要遵循“高内聚，低耦合”的设计思想。MDU有着和ALU截然不同的特性，首先最根本的就是它是一个时序逻辑<br>有独立的HI和LO，操作会更加灵活，便于运算。存取也会更加方便一些</p><h3 id="（2）真实的流水线-CPU-是如何使用实现乘除法的？请查阅相关资料进行简单说明。"><a href="#（2）真实的流水线-CPU-是如何使用实现乘除法的？请查阅相关资料进行简单说明。" class="headerlink" title="（2）真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。"></a>（2）真实的流水线 CPU 是如何使用实现乘除法的？请查阅相关资料进行简单说明。</h3><p>答：实现方式有很多种，在这里举一个我能理解的乘法器和除法器：<br><img src="20201120193209527.png" alt="数据示意1"><br>如图为乘法实现原理：类比10进制乘法，利用移位运算。每次对两因数中的一个的第一位进行判断，一共判断32位共循环32次，若该位为1，则将积加上另一因数，若为0，则不用加。每次循环结束将用于判断的因数右移一位，用于和积相加的因数左移一位，循环完成后，积即为两因数的积。<br><img src="20201120193356865.png" alt="数据示意1"><br>如图为除法实现原理：类比十进制除法，利用移位运算。将被除数前32位拼接上32位的0，一共判断32位共循环32次，每次比较被除数前32位与除数相比，若大于除数，则将被除数前32位减去除数，并将整个64位的被除数加上1，若小于除数，则什么也不做，每次循环完成后将被除数左移一位。循环完成后，被除数前32位为余数，后32位为商。</p><h3 id="（3）请结合自己的实现分析，你是如何处理-Busy-信号带来的周期阻塞的？"><a href="#（3）请结合自己的实现分析，你是如何处理-Busy-信号带来的周期阻塞的？" class="headerlink" title="（3）请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？"></a>（3）请结合自己的实现分析，你是如何处理 Busy 信号带来的周期阻塞的？</h3><p>答：我将其独立于一般的指令阻塞，专门写了一路用于处理其阻塞问题，只要Busy一直有效，且遇到了D级指令需要使用MDU的情况，该路便一直有效，进而导致Stall信号一直有效</p><pre><code> wire Stall_MDU = busy &amp;&amp; ( D_MDU_c || D_MDU_f ||D_MDU_t );</code></pre><h3 id="（4）请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）"><a href="#（4）请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）" class="headerlink" title="（4）请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）"></a>（4）请问采用字节使能信号的方式处理写指令有什么好处？（提示：从清晰性、统一性等角度考虑）</h3><p>答：清晰性：相较于单一的WE使能信号来说，字节使能让读者可以清晰看出哪一位字节是需要写入的，更加直观明了。<br>统一性：统一了SW,SB,SH三个指令的使能信号，只需要更改对应的字节使能即可实现三个指令，统一性较好</p><h3 id="（5）请思考，我们在按字节读和按字节写时，实际从-DM-获得的数据和向-DM-写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？"><a href="#（5）请思考，我们在按字节读和按字节写时，实际从-DM-获得的数据和向-DM-写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？" class="headerlink" title="（5）请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？"></a>（5）请思考，我们在按字节读和按字节写时，实际从 DM 获得的数据和向 DM 写入的数据是否是一字节？在什么情况下我们按字节读和按字节写的效率会高于按字读和按字写呢？</h3><p>答：不为一字节，仍为按字读取。<br>如果有这样一种指令，他会读第一个字的最后一个字节的高四位，读二个字的第一个字节低四位，拼成一个半字，那么此时按字读需要读两次，而按字节读只需1次，此时效率会高。</p><h3 id="（6）为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？"><a href="#（6）为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？" class="headerlink" title="（6）为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？"></a>（6）为了对抗复杂性你采取了哪些抽象和规范手段？这些手段在译码和处理数据冲突的时候有什么样的特点与帮助？</h3><p>答：比如将不同的指令在同一模块中的行为用一个信号的不同值来表示，这样减少了信号量，提高了统一性，减少了手滑写出例如：extendsign变成exrtendsign的行为产生，提高debug效率。<br><img src="微信截图_20221120204502.png" alt="数据示意1"><br>又比如对指令进行归类：将例如add,sub指令归为cal_r,addi,andi这种立即数指令归为cal_t,这样在考虑阻塞与转发时可以统一考虑，也是提高了统一性，且简洁明了<br><img src="微信截图_20221120204513.png" alt="数据示意1"></p><h3 id="（7）在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？"><a href="#（7）在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？" class="headerlink" title="（7）在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？"></a>（7）在本实验中你遇到了哪些不同指令类型组合产生的冲突？你又是如何解决的？相应的测试样例是什么样的？</h3><p>在覆盖率测试软件的结果中其实对于冲突的展示已经完全明了    </p><pre><code>转发：            &quot;average&quot;: 95.06304176516942,            &quot;cal_rr &lt;~~ cal_rr&quot;: 100.0,            &quot;cal_rr &lt;~~ cal_ri&quot;: 100.0,            &quot;cal_rr &lt;~~ mv_fr&quot;: 100.0,            &quot;cal_rr &lt;~~ load&quot;: 100.0,            &quot;cal_rr &lt;~~ lui&quot;: 100.0,            &quot;cal_rr &lt;~~ jal&quot;: 100.0,            &quot;cal_ri &lt;~~ cal_rr&quot;: 100.0,            &quot;cal_ri &lt;~~ cal_ri&quot;: 100.0,            &quot;cal_ri &lt;~~ mv_fr&quot;: 100.0,            &quot;cal_ri &lt;~~ load&quot;: 100.0,            &quot;cal_ri &lt;~~ lui&quot;: 100.0,            &quot;cal_ri &lt;~~ jal&quot;: 100.0,            &quot;br_r2 &lt;~~ cal_rr&quot;: 100.0,            &quot;br_r2 &lt;~~ cal_ri&quot;: 100.0,            &quot;br_r2 &lt;~~ mv_fr&quot;: 100.0,            &quot;br_r2 &lt;~~ load&quot;: 100.0,            &quot;br_r2 &lt;~~ lui&quot;: 100.0,            &quot;br_r2 &lt;~~ jal&quot;: 100.0,            &quot;mv_to &lt;~~ cal_rr&quot;: 100.0,            &quot;mv_to &lt;~~ cal_ri&quot;: 100.0,            &quot;mv_to &lt;~~ mv_fr&quot;: 100.0,            &quot;mv_to &lt;~~ load&quot;: 100.0,            &quot;mv_to &lt;~~ lui&quot;: 100.0,            &quot;mv_to &lt;~~ jal&quot;: 100.0,            &quot;load &lt;~~ cal_rr&quot;: 75.18518518518519,            &quot;load &lt;~~ cal_ri&quot;: 64.44444444444444,            &quot;load &lt;~~ mv_fr&quot;: 86.66666666666666,            &quot;load &lt;~~ load&quot;: 80.0,            &quot;load &lt;~~ lui&quot;: 73.33333333333333,            &quot;load &lt;~~ jal&quot;: 91.11111111111111,            &quot;store &lt;~~ cal_rr&quot;: 100.0,            &quot;store &lt;~~ cal_ri&quot;: 100.0,            &quot;store &lt;~~ mv_fr&quot;: 100.0,            &quot;store &lt;~~ load&quot;: 100.0,            &quot;store &lt;~~ lui&quot;: 100.0,            &quot;store &lt;~~ jal&quot;: 95.55555555555556,            &quot;mul_div &lt;~~ cal_rr&quot;: 92.22222222222223,            &quot;mul_div &lt;~~ cal_ri&quot;: 91.11111111111111,            &quot;mul_div &lt;~~ mv_fr&quot;: 93.33333333333334,            &quot;mul_div &lt;~~ load&quot;: 88.33333333333334,            &quot;mul_div &lt;~~ lui&quot;: 90.0,            &quot;mul_div &lt;~~ jal&quot;: 100.0,            &quot;jr &lt;~~ cal_rr&quot;: 80.0,            &quot;jr &lt;~~ cal_ri&quot;: 73.33333333333333,            &quot;jr &lt;~~ mv_fr&quot;: 80.0,            &quot;jr &lt;~~ load&quot;: 80.0,            &quot;jr &lt;~~ jal&quot;: 100.0暂停：            &quot;average&quot;: 95.52380952380952            &quot;cal_rr &lt;~~ load&quot;: 100.0,            &quot;cal_ri &lt;~~ load&quot;: 100.0,            &quot;br_r2 &lt;~~ cal_rr&quot;: 100.0,            &quot;br_r2 &lt;~~ cal_ri&quot;: 100.0,            &quot;br_r2 &lt;~~ mv_fr&quot;: 100.0,            &quot;br_r2 &lt;~~ load&quot;: 100.0,            &quot;mv_to &lt;~~ load&quot;: 100.0,            &quot;load &lt;~~ load&quot;: 100.0,            &quot;store &lt;~~ load&quot;: 100.0,            &quot;mul_div &lt;~~ load&quot;: 90.0,            &quot;jr &lt;~~ cal_rr&quot;: 80.0,            &quot;jr &lt;~~ cal_ri&quot;: 83.33333333333333,            &quot;jr &lt;~~ mv_fr&quot;: 100.0,            &quot;jr &lt;~~ load&quot;: 80.0   </code></pre><p>以上为全部P6会遇到的转发阻塞情况，这里我采用了随机+特判的方式自动化生成数据，随机可以随机出大部分的阻塞和转发情况，但由于为了保证jal,jr的跳转正确性，jal和jr的转发与阻塞则需要我构造特判指令去保证在测试完毕后$31寄存器的值不会被改变，并且可以实现转发和阻塞，以及load和store也需要我进行一些辅助特判保证不会超范围，例如：   </p><pre><code>解决 &quot;load &lt;~~ mv_fr&quot;&#123;    int base = Reg;    int rtt = rt;    int rss = rs;    while(rtt==0||rtt==base)    &#123;        rtt = Reg;        &#125;     while(rss==0||rss==rtt||rss==base)    &#123;        rss = Reg;    &#125;    sub(rtt, rtt, rtt);    sub(rss,rss,rss);    int num_1 = rand()%10;    while(num_1&lt;=4)    &#123;        num_1 = rand()%10;    &#125;    int num = (((rand()%10)+1)*4)*num_1+4;    ori(0,rtt,num_1,0);    ori(0,rss,num,0);    printf(&quot;divu $%d,$%d\n&quot;, rss, rtt);    if(Reg % 2 == 1)    &#123;        printf(&quot;mfhi $%d\n&quot;,base);    &#125;    else    &#123;        printf(&quot;mflo $%d\n&quot;,base);    &#125;    if(Reg % 3)    &#123;        int rad= Delayinstr;        while(rad == 8 || rad == 9)        &#123;            rad = Delayinstr;            &#125;         Choose(rad, 0, rss, rtt, base, 0, 0);    &#125;    int random = Reg;    if((random % 3) == 0)    &#123;        printf(&quot;lw $%d,0($%d)\n&quot;, rss,base);    &#125;    else if((random % 3) == 1)    &#123;        printf(&quot;lh $%d,0($%d)\n&quot;, rss,base);    &#125;    else    &#123;        printf(&quot;lb $%d,0($%d)\n&quot;, rss,base);     &#125;</code></pre><p>在这个程序段中，我会构造出不会超出load地址范围的数据，并进行乘法，除法（随机）运算并Mflo或Mfhi(随机），并紧跟或隔一条无关指令（随机）<br>在紧接lb,lw,lh（随机）且寄存器就是mfhi/mflo的目标寄存器实现保证正确运行下的阻塞与运行</p><h3 id="（8）如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。"><a href="#（8）如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。" class="headerlink" title="（8）如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。"></a>（8）如果你是手动构造的样例，请说明构造策略，说明你的测试程序如何保证覆盖了所有需要测试的情况；如果你是完全随机生成的测试样例，请思考完全随机的测试程序有何不足之处；如果你在生成测试样例时采用了特殊的策略，比如构造连续数据冒险序列，请你描述一下你使用的策略如何结合了随机性达到强测的效果。</h3><p>答：我选择的是随机+特判的方式构造数据，随机可以覆盖大部分的阻塞和转发，但正如我前面所说，为了保证程序的正确运行完全随机是不可信的，这必然导致一些代码的固定化，而一些代码的固定化必然导致一些阻塞与转发的无效化，所以为了保证正确性与覆盖率兼得，所以引入特判是必须的，比如，如果load指令Base不为0就需要对这个寄存器提前处理，不要让其数据太大，导致加和超出范围，store同理，jal和jr则需要测试前后$31的寄存器值不变，才能正确跳转，这便是特判+随机Orz （虽然P5教程上的一些构造方法真的很吸引人，但时间成本对我来说有点高，所以最终出此下策）<br>至于如何结合随机性，具体来说：固定的指令段之间会随机插入不影响这一段固定指令对应寄存器值的指令，固定的指令段的寄存器随机产生，而且，不影响正确结果的情况下，指令段的固定其实是指令类的固定，比如ori+load（lb,lh,lw)这种,最后效果还是蛮好的。</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易流水线CPU全自动测试思路（Verilog）</title>
      <link href="/posts/5928/"/>
      <url>/posts/5928/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P5的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><font size = 3><font color="purple">如果P3,P4大家有好好的做数据生成，那么P5的数据生成的工作将主要体现在对于数据生成器的优化上，对于数据执行器则无需太大的优化。</font></font>      <font size = 3><font color="green">如果大家是从P5才开始做测试，那么建议看看笔者博客中P3 P4的自动化测试，很多工作在那时就已经完成，P5的自动化将迭代开发，在本篇博客中将不再赘述。</font></font>    <h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars_perfect.jar mc CompactDataAtZero nc db test.asm &gt; mar.txt</span><br></pre></td></tr></table></figure> <p><strong>有小问号可能要问了，这和P4没啥区别啊这？其实区别就在于”db”，这是要求Mars执行时按延迟槽执行的指令。</strong>  </p><h1 id="Python实现（数据执行器）"><a href="#Python实现（数据执行器）" class="headerlink" title="Python实现（数据执行器）"></a>Python实现（数据执行器）</h1><h2 id="基础功能迭代"><a href="#基础功能迭代" class="headerlink" title="基础功能迭代"></a>基础功能迭代</h2><p>迭代在P4的基础，我们只需要更改命令行学习中的那一条指令即可完成P5的数据执行器。  </p><h2 id="自动存储机器码"><a href="#自动存储机器码" class="headerlink" title="自动存储机器码"></a>自动存储机器码</h2><p>在P4中笔者只是将asm文件和比较结果进行了存储，并没有保存机器码，在P5笔者建议保留机器码文件，具体原因见后。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dir_name_3 = &#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\机器码文件\\&#x27;</span><br><span class="line">f_1 = open(&#x27;code.txt&#x27;, &quot;r&quot;)</span><br><span class="line">list_temp = f_1.readlines()</span><br><span class="line">f_2 = open(dir_name_3 + &#x27;test&#x27;+str(test_order)+&#x27;.txt&#x27;, &quot;w&quot;)</span><br><span class="line">f_2.writelines(list_temp)</span><br><span class="line">f_1.close()</span><br><span class="line">f_2.close()</span><br></pre></td></tr></table></figure><br>功能：将生成的机器码文件Code.txt的内容复制到test+第几次测试.txt中，并放到dir_name_3的目录下。<strong>（此处使用绝对目录）</strong></p><h2 id="自动打包"><a href="#自动打包" class="headerlink" title="自动打包"></a>自动打包</h2><p>机器码其实本来就是可有可无的东西，毕竟只要有asm,需要时我们就能手动生成，但是，考虑到从P5开始，计组提供了数据构造测试器，可以测试我们构造数据的强度，但数据构造测试器有一个极其阴间的一点是：    </p><p><strong><font color="green">我们必须将每一个机器码打包成一个压缩包，再将整体压缩包打包成一个压缩包，对于命名还有很多的要求，比如P5的数据必须以P5开头等等，初期手搓的笔者已经累傻了，所以我们要自动化打包。</font></strong>   </p><p>笔者打包使用360压缩，建议大家同样使用360压缩进行打包，因为360压缩支持<strong>命令行操作</strong>，我们因此得以利用Python的OS库调用360压缩<strong>自动化打包</strong>每一次生成的机器码文件，并命名。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zip(i+<span class="number">1</span>)</span><br><span class="line">def zip(test_order):</span><br><span class="line">os.system(&quot;\&quot;<span class="number">360</span>压缩安装目录&quot; -ar code.txt 打包好的压缩包存放位置\\&quot;命名.zip&quot;)</span><br><span class="line">例如：</span><br><span class="line">os.system(&quot;\&quot;C:\\Program Files (x86)\\<span class="number">360</span>\\<span class="number">360</span>zip\\<span class="number">360</span>zip.exe\&quot; -ar code.txt C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\压缩文件\\P5_Q&quot;+str(test_order)+&quot;.zip&quot;)</span><br></pre></td></tr></table></figure><br><strong>TIPS: </strong>- ar前面为360压缩安装目录，后面为打包好的压缩包存放位置。</p><h1 id="数据生成器迭代思路"><a href="#数据生成器迭代思路" class="headerlink" title="数据生成器迭代思路"></a>数据生成器迭代思路</h1><h2 id="P5指令集："><a href="#P5指令集：" class="headerlink" title="P5指令集："></a>P5指令集：</h2><p><strong>{add,sub,ori,lw,sw,beq,lui,jal,jr,nop}</strong></p><h2 id="迭代思路："><a href="#迭代思路：" class="headerlink" title="迭代思路："></a>迭代思路：</h2><p><strong>• 整体构造思路</strong></p><font color="purple">（1）需求制造规则，规则产生需求，不断循环迭代。在原有的数据生成上不断添加规则，增强随机性，直至取得一个良好的效果，说人话就是，一旦针对某一项需求设定了规则，就可能导致随机性或正确性的下降，而为了弥补这个随机性的下降，提高随机性，就产生了新的需求，就必然导致新规则的加入以提高随机性。或者是为了保证正确性，就需要添加新的规则，来修补漏洞。而修补漏洞也可能导致随机性的下降，有需要产生新的规则提高随机性。笔者的数据生成就是在这样的循环开发中不断走向圆满的。</font> </br><font color="blue">（2）如果为了保持正确性，有需要固定生成的一些随机指令，举一个例子，笔者往往选择如下方式尽可能地提高随机性：</font> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令类（cal_i,cal_r....)</span><br><span class="line">（可能随机<span class="number">0</span><span class="number">-2</span>条无关指令）  #无关指令：寄存器不相关</span><br><span class="line">jr（冲突指令)</span><br></pre></td></tr></table></figure><p>这样由于中间无关指令可能产生，可能不产生，实现了不同流水级转发的效果，且采用指令类解决冲突，提高了不同指令对同一指令的转发冲突解决效果。&lt;/br&gt;</p><p><strong>• 迎合流水线设计，缩减寄存器范围，提高转发和冲突的出现频率，增强测试强度。在这里我们将寄存器范围缩减到0-5。</strong></p><font color="red">注意：数据的生成中往往会因为0号寄存器的存在导致一些不可预料的错误，这些都需要我们特别增加生成规则，或许有人会考虑将寄存器范围缩减到1-6，但这样会面临着一些关于0寄存器读出，转发，写入的问题没法检测出来，降低了生成强度。</font>  <p><strong>• 加入负数测试，现在lw,sw都会随机生成负数立即数，用来检验EXT模块的正确性。</strong></p><font color="red">但，这样的加入仍然是有代价的，我们仍然需要添加规则，使得offset+寄存器的值>=0，否则将出错，笔者这里采用了一旦要这样做，就提前指定一个寄存器，为其赋大于该负数的值，然后再执行lw,sw</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    rs++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> imm1 = I;</span><br><span class="line"><span class="type">int</span> imm2 = I;</span><br><span class="line"><span class="keyword">if</span> (imm1 &lt; imm2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = imm1;</span><br><span class="line">    imm1 = imm2;</span><br><span class="line">    imm2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line"><span class="built_in">ori</span>(rs, rs, imm1, <span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> imm3 = <span class="number">0</span> - imm2;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rt, imm3, rs);</span><br><span class="line">grf[rt] = dm[(imm3 + imm1) / <span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>在这一段代码中，同时有两个规则在起作用，和我上文提到的两条都有关系，比如对rs=0的处理，如果rs是0，不对其进行处理，那么对rs赋值也是白赋值，rs的值恒为0，导致offset+[rs]小于0的问题的出现。Mars将会报错。<br>再比如对负数的处理，笔者随机生成两个数，进行比较，然后将小的那一个取反，大的那一个赋值给寄存器，保证了lw和sw寻址大于0.  </p><p><strong>• 保证延迟槽必无beq,j等跳转指令！维护理论正确性</strong></p><font color="red">延迟槽中是不能有跳转指令的，否则将是一个UB行为，而且大概率来讲，大家写的CPU将会直接死循环，而Mars则会正确运行。对于这条的处理相对比较简单，只要在随机延迟槽指令时，判断是否是跳转，如果是则再在指令池当中抽取一条即可！</font><p><strong>• 保证lw,sw在经过负数和寄存器值相加后字对齐，不会报错！</strong></p><font color="red">由于lw，sw是按字读取，所以地址加和后必须是4的倍数，否则Mars将报错，因此我们需要改变随机数的生成规则，这里笔者取巧了一下，将随机数的生成全部生成为4的倍数，且寄存器永远为$0，保证了字对齐，至于前面所提到的负数的情况，由于寄存器的值也是随机数生成的，所以加起来仍然是4的倍数，仍然字对齐。</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> I ((rand() + rand()) % 40) * 4</span></span><br></pre></td></tr></table></figure><p><strong>• 移除无用的nop</strong></p><font color="red">笔者认为，nop在流水线中是极其无用的指令，加入Nop将减少转发冲突的产生，因此笔者在生成指令时拒绝了Nop的生成</font><font color="green">至于nop的功能正确性，嘛，这不还有计组平台的弱测帮你测试这个功能嘛~</font><p><strong>• 对于jal转发暂停的特殊解决</strong></p><font color="red">在P3,P4我们提到，为了保证程序运行的整体正确性，对于jal和beq的生成我们都是有规则的，且对于jal近乎是以固定于每一代码段的末尾的方式生成的，而这种非随机化的规则必然带来代价——转发冲突覆盖的不全面，首当其冲就是jal和各种指令的转发阻塞覆盖的缺失，且由于$31寄存器承担着正确运行的职能，我们还不能随意更改，必须在真正执行Jal前改回来，因此对于jal来说，我们依旧需要提供大量的规则，增强随机性，覆盖其转发阻塞。</font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sw_jal</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> imm = <span class="number">-12288</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lw_jal</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> imm = <span class="number">-12288</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rt, imm, rs);</span><br><span class="line">&#125;</span><br><span class="line">--------------------------------------------------------</span><br><span class="line"><span class="keyword">if</span> (Reg % <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;jal Test_jal%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">Choose</span>(Stall_Jal, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;beq $0,$0,Test_beq%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">Choose</span>(Stall_Jal, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test_jal%d: jr $ra\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Test_beq%d:\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">Choose</span>(Normal, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;jal Test%d\n&quot;</span>, i);</span><br><span class="line">    <span class="built_in">Choose</span>(Delayinstr, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">        <span class="built_in">ori</span>(<span class="number">31</span>, rt, I, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">        <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">        <span class="built_in">lw_jal</span>(<span class="number">31</span>, rt);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">        <span class="built_in">sw_jal</span>(<span class="number">31</span>, rt);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">        <span class="type">int</span> g = Reg % <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span> (g==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">            <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">            <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  </span></span><br><span class="line">            <span class="built_in">add</span>(rd, <span class="number">0</span>, <span class="number">31</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(g==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">            <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">            <span class="built_in">sub</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  $31=0</span></span><br><span class="line">            <span class="built_in">ori</span>(rd, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(g==<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> immi = I;</span><br><span class="line">            <span class="built_in">sub</span>(rt, rt, rt);</span><br><span class="line">            <span class="built_in">sw_diy</span>(rt, <span class="number">31</span>, immi);</span><br><span class="line">            <span class="built_in">sub</span>(<span class="number">31</span>,<span class="number">31</span>,<span class="number">31</span>);</span><br><span class="line">            <span class="built_in">lw_diy</span>(rt, <span class="number">31</span>, immi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">sub</span>(rs, rs, rs);</span><br><span class="line">            <span class="built_in">add</span>(rs, <span class="number">31</span>, rd);</span><br><span class="line">            <span class="built_in">add</span>(<span class="number">31</span>, <span class="number">31</span>, <span class="number">31</span>);</span><br><span class="line">            <span class="built_in">sub</span>(rd, <span class="number">31</span>, <span class="number">31</span>); <span class="comment">// rd $31 rs=0  </span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sw_diy</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> rt, <span class="type">int</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sw $%d,%d($%d)\n&quot;</span>, rt, imm, base);</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lw_diy</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> rt, <span class="type">int</span> imm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lw $%d,%d($%d)\n&quot;</span>, rt, imm, base);</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------------</span><br></pre></td></tr></table></figure><p>其余的特殊转发都很类似，只需不断地添加规则增强随机性，不断地修正新规则所带来的正确性的问题，最后实现覆盖。</p><p><strong>• 其余特殊解决</strong></p><font color="blue">由于时间过于久远，笔者也记不住自己究竟写了多少条规则限制数据生成，更详细的规则还请大家移步文章最后我的数据生成代码查看，谢谢！</font><p><strong>大家可能觉得这样会很复杂，但实话说，随机生成就是有着这样的缺陷，其指令的正确性只能通过不断地添加规则来实现，但不得不承认，随机生成法在上学这种没有很多空余时间的期间，是投入与产出性价比最高的测试方式。</strong></p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;grade&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;forward&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;average&quot;</span>: <span class="number">93.8735632183908</span>,</span><br><span class="line">    <span class="string">&quot;stall&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;average&quot;</span>: <span class="number">100.0</span>,</span><br></pre></td></tr></table></figure><h1 id="Python自动化测试框架代码"><a href="#Python自动化测试框架代码" class="headerlink" title="Python自动化测试框架代码"></a>Python自动化测试框架代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> filestools</span><br><span class="line"><span class="keyword">from</span> filediff.diff <span class="keyword">import</span> file_diff_compare</span><br><span class="line">p_road = <span class="string">&quot;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\FlowCpu&quot;</span></span><br><span class="line">run_time = <span class="string">&quot;100us&quot;</span></span><br><span class="line">xilinx_path = <span class="string">&quot;G:\\ISE\\14.7\\ISE_DS\\ISE&quot;</span></span><br><span class="line">dir_name = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\mars文件\\&#x27;</span></span><br><span class="line">dir_name_3 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\机器码文件\\&#x27;</span></span><br><span class="line">dir_name_1 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\比较文件\\&#x27;</span></span><br><span class="line">dir_name_2 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\测试记录\\&#x27;</span></span><br><span class="line">error = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成指令中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    command = <span class="string">&quot;C语言.exe&quot;</span></span><br><span class="line">    os.system(command)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;test.asm&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.asm&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mar</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成机器码中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars_perfect.jar mc CompactDataAtZero a dump .text HexText code.txt nc test.asm&quot;</span>)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;code.txt&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name_3 + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.txt&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line">    <span class="comment"># print(&quot;生成标准答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc db test.asm &gt; mar.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟槽 os.system(&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc db test.asm &gt; mar.txt&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ise</span>():</span><br><span class="line">    <span class="comment"># print(&quot;运行ise中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(p_road):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">                file_list.append(file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">            prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + p_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">        tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">    prj.close()</span><br><span class="line">    tcl.close()</span><br><span class="line">    os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path</span><br><span class="line">    os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + p_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + p_road + <span class="string">&quot;\\mips.tcl&gt; raw_out.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>():</span><br><span class="line">    <span class="comment"># print(&quot;转换ise答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">        mymem = mymem + myfriendmem[i];</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(mymem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_file</span>(<span class="params">name, target_road</span>):</span><br><span class="line">    f_1 = <span class="built_in">open</span>(name, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(target_road + <span class="string">&quot;\\&quot;</span> + name, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_cmp</span>(<span class="params">test_order</span>):</span><br><span class="line">    co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    co.write(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mar.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> out_1:</span><br><span class="line">        out_std = out_1.readlines()</span><br><span class="line">        out_std.remove(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> out_2:</span><br><span class="line">        out_test = out_2.readlines()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.\\log.txt&quot;</span>.<span class="built_in">format</span>(test_order), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(out_std) &gt; <span class="built_in">len</span>(out_test):</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out_std)):</span><br><span class="line">                <span class="keyword">if</span> out_std[i] != out_test[i]:</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Wrong Answer!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Wrong Answer!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Accepted!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Accepted!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    co.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> f.readlines()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: 没有找到文件:%s！&quot;</span> % filename)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_file</span>(<span class="params">file1, file2, out_file</span>):</span><br><span class="line">    file1_content = read_file(file1)</span><br><span class="line">    file2_content = read_file(file2)</span><br><span class="line">    d = difflib.HtmlDiff()</span><br><span class="line">    result = d.make_file(file1_content, file2_content)</span><br><span class="line">    fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    fb.write(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zip</span>(<span class="params">test_order</span>):</span><br><span class="line">    os.system(<span class="string">&quot;\&quot;C:\\Program Files (x86)\\360\\360zip\\360zip.exe\&quot; -ar code.txt C:\\Users\\Unicorn\\Desktop\\P5\\P5exp\\P5全自动测试\\压缩文件\\P5_Q&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;.zip&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入测试次数:&quot;</span>)</span><br><span class="line">test_times =<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">co.write(<span class="string">&quot;测试次数:&quot;</span>+<span class="built_in">str</span>(test_times)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">co.close()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">    generate(i+<span class="number">1</span>)</span><br><span class="line">    run_mar(i+<span class="number">1</span>)</span><br><span class="line">    run_ise()</span><br><span class="line">    process()</span><br><span class="line">    <span class="built_in">zip</span>(i+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># print(&quot;比较答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    compare_file(<span class="string">r&#x27;verilog.txt&#x27;</span>, <span class="string">r&#x27;mar.txt&#x27;</span>, <span class="string">&#x27;result&#x27;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">    file_cmp(i+<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P5">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P5</a></p><p><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P5课上强测！</font></strong></p><p><strong><font size = 5>P5数据生成器代码行数：445行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易流水线CPU设计文档（Verilog）</title>
      <link href="/posts/3119/"/>
      <url>/posts/3119/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Verilog 简易流水线CPU设计文档</center></font></strong></p><h1 id="一、CPU设计方案综述"><a href="#一、CPU设计方案综述" class="headerlink" title="一、CPU设计方案综述"></a>一、CPU设计方案综述</h1><h2 id="（一）总体设计综述"><a href="#（一）总体设计综述" class="headerlink" title="（一）总体设计综述"></a>（一）总体设计综述</h2><p>使用Verilog开发一个流水线CPU,总体概述如下：<br>1.此流水线CPU为32位CPU<br>2.此CPU为流水线设计<br>3.此CPU支持的指令集为:{add,sub,ori,lw,sw,beq,lui,jal,jr,nop}<br>4.nop的机器码为0x0000000<br>5.add，sub不支持溢出</p><h2 id="（二）关键模块定义"><a href="#（二）关键模块定义" class="headerlink" title="（二）关键模块定义"></a>（二）关键模块定义</h2><h3 id="F-IFU"><a href="#F-IFU" class="headerlink" title="F_IFU"></a>F_IFU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前指令</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">取指令</td><td style="text-align:center">取出当前PC所对应的指令</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">更改PC值</td><td style="text-align:center">利用NPC更改PC值</td></tr></tbody></table></div><h3 id="D-GRF"><a href="#D-GRF" class="headerlink" title="D_GRF"></a>D_GRF</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">A3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其作为RD的写入地址</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位写入数据</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A2指定寄存器的32位数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号，清零32个寄存器中的数据</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">同步复位</td><td style="text-align:center">时钟上升沿到来时，若RESET信号有效，则将32个寄存器中的数据全部清除</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A1与A2所存地址对应的寄存器的数据读出到RD1和RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD写入到A3所存地址对应的寄存器中</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">转发数据</td><td style="text-align:center">当A3\==A2或A3\==A1且WE有效，A3!=0时，将WD中的数据作为RD1或RD2的输出</td></tr></tbody></table></div><h3 id="ID-ID-REG"><a href="#ID-ID-REG" class="headerlink" title="ID_ID_REG"></a>ID_ID_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">IF_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段机器码</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">IF_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">ID阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">ID阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">O</td><td style="text-align:center">扩展类型信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">O</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RegWrite</td><td style="text-align:center">O</td><td style="text-align:center">寄存器写使能信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MemWrite</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">MemToReg[2:0]</td><td style="text-align:center">O</td><td style="text-align:center">Reg写入数据类型信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">RegDest[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">A3寄存器选择信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ALUop[3:0]</td><td style="text-align:center">O</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">O</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">O</td><td style="text-align:center">Jr信号</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">RegSrc</td><td style="text-align:center">O</td><td style="text-align:center">ALU数据来源选择信号</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">imm16[15:0]</td><td style="text-align:center">O</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">imm26[25:0]</td><td style="text-align:center">O</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">rs[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rs寄存器编号</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">rt[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rt寄存器编号</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">rd[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">rd寄存器编号</td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">load</td><td style="text-align:center">O</td><td style="text-align:center">是否为lw指令</td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">store</td><td style="text-align:center">O</td><td style="text-align:center">是否为sw指令</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">cal_r</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_r类指令</td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">cal_i</td><td style="text-align:center">O</td><td style="text-align:center">是否为cal_i类指令</td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">jal</td><td style="text-align:center">O</td><td style="text-align:center">是否为jal指令</td></tr></tbody></table></div><p>(2)真值表</p><div class="table-container"><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">add</th><th style="text-align:center">sub</th><th style="text-align:center">ori</th><th style="text-align:center">lw</th><th style="text-align:center">sw</th><th style="text-align:center">lui</th><th style="text-align:center">beq</th><th style="text-align:center">Jal</th><th style="text-align:center">Jr</th></tr></thead><tbody><tr><td style="text-align:center">OP</td><td style="text-align:center">000000</td><td style="text-align:center">000000</td><td style="text-align:center">001101</td><td style="text-align:center">100011</td><td style="text-align:center">101011</td><td style="text-align:center">001111</td><td style="text-align:center">000100</td><td style="text-align:center">000011</td><td style="text-align:center">000000</td></tr><tr><td style="text-align:center">FC</td><td style="text-align:center">100000</td><td style="text-align:center">100010</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">001000</td></tr><tr><td style="text-align:center">ALUop</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0011</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0100</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">Jump</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">RegWrite</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemWrite</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemToReg</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegDest</td><td style="text-align:center">01</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegSrc</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Branch</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jreg</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h3 id="D-CMP"><a href="#D-CMP" class="headerlink" title="D_CMP"></a>D_CMP</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">B[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数B</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Equal</td><td style="text-align:center">O</td><td style="text-align:center">A==B？1：0</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">比较</td><td style="text-align:center">比较操作数A与B是否相等，相等则Equal有效</td></tr></tbody></table></div><h3 id="D-NPC"><a href="#D-NPC" class="headerlink" title="D_NPC"></a>D_NPC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">F_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">IF阶段的PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段的PC值</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Beq_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Beq指令</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jal_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jal指令</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Jr_sign</td><td style="text-align:center">I</td><td style="text-align:center">是否为Jr指令</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">Jal_imm26[25:0]</td><td style="text-align:center">I</td><td style="text-align:center">26位立即数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">D_GRF_Jr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">Jr目标寄存器数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">Beq_imm16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">Equal</td><td style="text-align:center">I</td><td style="text-align:center">D_CMP两操作数是否相等</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">PC的下一值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">计算下一PC的值</td><td style="text-align:center">根据指令和当前PC值计算下一PC值</td></tr></tbody></table></div><h3 id="D-EXT"><a href="#D-EXT" class="headerlink" title="D_EXT"></a>D_EXT</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">经过扩展后的32位立即数</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">I</td><td style="text-align:center">选择扩展类型信号  0：符号扩展 1：无符号扩展</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">符号扩展</td><td style="text-align:center">将16位立即数符号扩展为32位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">无符号扩展</td><td style="text-align:center">将16位立即数无符号扩展为32位立即数</td></tr></tbody></table></div><h3 id="ID-EX-REG"><a href="#ID-EX-REG" class="headerlink" title="ID_EX_REG"></a>ID_EX_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">ID_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">D_RD1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">D_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">D_imm32[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段32位立即数</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">ID_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">EX_RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">EX_imm32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段32位立即数</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">EX阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="E-ALU"><a href="#E-ALU" class="headerlink" title="E_ALU"></a>E_ALU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ALUControl[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">运算结果</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">判断两个操作数是否相等</td><td style="text-align:center">相等则Bigger输出1否则为0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">加运算</td><td style="text-align:center">res=SrcA+SrcB</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">减运算</td><td style="text-align:center">res=SrcA-SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">与运算</td><td style="text-align:center">res=SrcA$SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">或运算</td><td style="text-align:center">res=SrcB</td><td>SrcB</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">加载高位运算</td><td style="text-align:center">res={SrcB[15:0],16’h0}</td></tr></tbody></table></div><h3 id="EX-MEM-REG"><a href="#EX-MEM-REG" class="headerlink" title="EX_MEM_REG"></a>EX_MEM_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">EX_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">EX_RD2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段有效数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">MEM_RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段有效数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">MEM阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="M-DM"><a href="#M-DM" class="headerlink" title="M_DM"></a>M_DM</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">32位数据输出</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位数据输入</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD中的数据写入到A所存地址所对应的位置</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A所存地址对应位置的数据读出到RD</td></tr></tbody></table></div><h3 id="MEM-WB-REG"><a href="#MEM-WB-REG" class="headerlink" title="MEM_WB_REG"></a>MEM_WB_REG</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">MEM_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">MEM_ALU_Result[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段ALU结果数据</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">MEM_DM_RD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段DM读出数据</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">MEM_PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">clk</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">reset</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">WB_Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WB_ALU_Result[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段ALU结果数据</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">WB_DM_RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段DM读出数据</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">WB_PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段PC值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">记忆功能</td><td style="text-align:center">WB阶段存储执行命令所需要的所有内容</td></tr></tbody></table></div><h3 id="Stall"><a href="#Stall" class="headerlink" title="Stall"></a>Stall</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">D_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">ID阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Stall</td><td style="text-align:center">O</td><td style="text-align:center">阻塞信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">阻塞功能</td><td style="text-align:center">判断当前流水线是否需要在ID阶段阻塞</td></tr></tbody></table></div><p>(3)判断方法——AT法</p><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">rsTuse</th><th style="text-align:center">rtTuse</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">0</td><td style="text-align:center">-</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">指令</th><th style="text-align:center">E_Tnew</th><th style="text-align:center">M_Tnew</th></tr></thead><tbody><tr><td style="text-align:center">add</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">sub</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">ori</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">lw</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">sw</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">beq</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">lui</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jal</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">jr</td><td style="text-align:center">-</td><td style="text-align:center">-</td></tr></tbody></table></div><h3 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">E_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">EX阶段机器码</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">M_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">MEM阶段机器码</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">W_Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">WB阶段机器码</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">EX_Forward</td><td style="text-align:center">O</td><td style="text-align:center">EX阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">MEM_Forward</td><td style="text-align:center">O</td><td style="text-align:center">MEM阶段数据是否可以转发信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">WB_Forward</td><td style="text-align:center">O</td><td style="text-align:center">WB阶段数据是否可以转发信号</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">转发信号</td><td style="text-align:center">判断每个阶段是否可以为前面转发数据</td></tr></tbody></table></div><h1 id="转发暂停控制"><a href="#转发暂停控制" class="headerlink" title="转发暂停控制"></a>转发暂停控制</h1><h2 id="暂停："><a href="#暂停：" class="headerlink" title="暂停："></a>暂停：</h2><pre><code>wire Stall_rs_E = (E_RegDest == D_rs) &amp;&amp;(E_RegDest) &amp;&amp; (T_use_rs &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_rt_E = (E_RegDest == D_rt) &amp;&amp; (E_RegDest) &amp;&amp; (T_use_rt &lt; T_new_E) &amp;&amp; E_RegWrite;wire Stall_E = Stall_rs_E || Stall_rt_E;wire Stall_rs_M = (M_RegDest == D_rs) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rs &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_rt_M = (M_RegDest == D_rt) &amp;&amp; (M_RegDest) &amp;&amp; (T_use_rt &lt; T_new_M) &amp;&amp; M_RegWrite;wire Stall_M = Stall_rs_M || Stall_rt_M;assign Stall = Stall_M || Stall_E;      </code></pre><h2 id="转发："><a href="#转发：" class="headerlink" title="转发："></a>转发：</h2><pre><code>wire [31:0] D_Forward_rs = (D_rs == 0)? 0 :            ((E_RegDest == D_rs) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :        ((M_RegDest == D_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD1;wire [31:0] D_Forward_rt = (D_rt == 0)? 0 :            ((E_RegDest == D_rt) &amp;&amp; EX_Forward &amp;&amp; E_RegWrite) ? E_MemToReg :            ((M_RegDest == D_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg : D_RD2;wire [31:0] E_Forward_rs =   (E_rs == 0) ? 0 :        ((M_RegDest == E_rs) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rs) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD1;wire [31:0] E_Forward_rt =   (E_rt == 0) ? 0 :        ((M_RegDest == E_rt) &amp;&amp; MEM_Forward &amp;&amp; M_RegWrite) ? M_MemToReg :        ((W_RegDest == E_rt) &amp;&amp; WB_Forward &amp;&amp; W_RegWrite) ? W_MemToReg : EX_RD2;</code></pre><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>为<strong>自动化测试</strong>：<br>共随机生成1000组数据<br><img src="微信截图_20221106010804.png" alt="数据示意1"><br>并生成1000组比对文件<br><img src="微信截图_20221106010955.png" alt="数据示意2"><br>和一个总体结果文件<br><img src="微信截图_20221106011047.png" alt="数据示意3"></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="（1）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。"><a href="#（1）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。" class="headerlink" title="（1）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。"></a>（1）我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。</h3><p>答：分支判断确实是提前了，但其他指令并没有提前，这或许会导致原本只需要进行转发的指令因为这一提前而不能及时生成导致需要阻塞，例如：  </p><pre><code>add $t1,$t2,$t3beq $t1,$t2,labellabel:</code></pre><p>在这个例子中，Beq的提前判断会导致原本转发可以解决的$t1的值的更新需要阻塞一个周期。<br>因为Beq在ID阶段CMP中判断时，add指令$t1的值还没有存入流水线寄存器，不能转发，需要阻塞一周期。<br>若Beq在EX阶段ALU中判断，则此时EX/MEM流水线寄存器中已经存有了$t1正确的值，可以转发，不需要阻塞。</p><h3 id="（2）因为延迟槽的存在，对于-jal-等需要将指令地址写入寄存器的指令，要写回-PC-8，请思考为什么这样设计？"><a href="#（2）因为延迟槽的存在，对于-jal-等需要将指令地址写入寄存器的指令，要写回-PC-8，请思考为什么这样设计？" class="headerlink" title="（2）因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？"></a>（2）因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？</h3><p>答：延迟槽的存在，会让jal跳转时也会执行其下一条指令，也正因为这条指令已经被执行过了，为了维护程序的正确性，当利用jr或其他指令返回时，我们需要跳到Jal的下两条指令，即PC+8，也因此要将它存入$31寄存器中，而非PC+4</p><h3 id="（3）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如-DM-、-ALU-），请思考为什么？"><a href="#（3）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如-DM-、-ALU-），请思考为什么？" class="headerlink" title="（3）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？"></a>（3）我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？</h3><p>答：首先我个人认为从功能部件进行转发也是合理的，即“Brutal-Forward”，但这样转发显然没有流水线转发直观，会让转发的控制变得更加复杂。</p><h3 id="（4）我们为什么要使用-GPR-内部转发？该如何实现？"><a href="#（4）我们为什么要使用-GPR-内部转发？该如何实现？" class="headerlink" title="（4）我们为什么要使用 GPR 内部转发？该如何实现？"></a>（4）我们为什么要使用 GPR 内部转发？该如何实现？</h3><p>答：GPR内部转发可以实现WB-&gt;ID的转发，举个例子：     </p><pre><code>WB:add $t1,$t2,$t3ID:sub $t1,$t2,$t3</code></pre><p>此时显然ID中的SUB需要使用的是WB中$t1的值，因此需要转发，利用该内部转发便可实现这样的功能，提高流水线运行效率。<br><strong>实现方法</strong>:<br><img src="微信截图_20221106013054.png" alt="实现方法"><br>如图：只需在RD1和RD2输出加一个三目运算符即可<br>！注意：需要考虑A3是否为0（对$0写入实际写入为0，而并非WD）<br>！注意：需要考虑WE是否有效（只有对GRF写入的数据才应该被转发）<br>！注意：需要考虑A1或A2是否等于A3（只有相同寄存器的数据才需要被转发）</p><h3 id="（5）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？"><a href="#（5）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？" class="headerlink" title="（5）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？"></a>（5）我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？</h3><p>答：<br><strong>需求者</strong>：CMP的两个操作数；ALU的两个操作数；DM的WD端口<br><strong>供给者</strong>：ID_EX流水线寄存器，EX_MEM流水线寄存器，MEM_WB流水线寄存器<br><strong>通路</strong>：<br>ID_EX-&gt;CMP<br>EX_MEM-&gt;CMP<br>MEM_WB-&gt;CMP<br>EX_MEM-&gt;ALU<br>MEM_WB-&gt;AKU<br>MEM_WB-&gt;DM</p><h3 id="（6）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。"><a href="#（6）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。" class="headerlink" title="（6）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。"></a>（6）在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。</h3><p>答：<br>跳转：可能需要在Control加入新的控制信号识别该指令,并在NPC中加入完成该指令的方法，并添加if分支选择其作为NPC，并考虑跳转和阻塞问题。<br>计算：可能需要在Control加入新的ALUop信号计算该指令，并在ALU中加入完成该指令的方法，并考虑跳转和阻塞问题。<br>访存：可能需要在Control加入新的控制信号识别该指令，并在DM中完成该访存的方法，并考虑跳转和阻塞问题。</p><h3 id="（7）简要描述你的译码器架构，并思考该架构的优势以及不足。"><a href="#（7）简要描述你的译码器架构，并思考该架构的优势以及不足。" class="headerlink" title="（7）简要描述你的译码器架构，并思考该架构的优势以及不足。"></a>（7）简要描述你的译码器架构，并思考该架构的优势以及不足。</h3><p>答：<br>我选用的是分布式译码器，该架构的<strong>优势</strong>在于不需要流水控制信号，只需要在不同的流水线阶段生成不同的控制信号即可，实现起来无论是思路还是代码量上都远远少于集中式译码器，且不用考虑Tnew随周期数减少的问题。<br><strong>不足</strong>在于多次实例化Control模块，每一次实例都闲置了大量的端口，造成了资源的浪费。且实际应用中增加了数据通路的长度，降低了效率。</p><h3 id="（8）请详细描述你的测试方案及测试数据构造策略。"><a href="#（8）请详细描述你的测试方案及测试数据构造策略。" class="headerlink" title="（8）请详细描述你的测试方案及测试数据构造策略。"></a>（8）请详细描述你的测试方案及测试数据构造策略。</h3><p>答：测试方案：<br>（1）第一步编写生成指令代码，自动生成为test.asm文件<br>（2）第二步利用python os库运行mars执行“test.asm”使其生成“command.txt”（里面为机器码）<strong>和</strong>标准输出（魔改mars)“mar.txt”<br>（3）第三步自动生成ise的.prj和.tcl文件<br>（4）第四步利用python os库运行ise使其生成“raw_out.txt”<br>（5）第五步将raw_out的头部无用内容处理掉，生成”verilog.txt”文件<br>（5）第五步利用python difflib或进行文本比较，生成“result.html”并输出”Accepted!”或“Wrong Answer!”</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单周期CPU全自动测试思路（Verilog）</title>
      <link href="/posts/34987/"/>
      <url>/posts/34987/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P4的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p><p style="color: #FF00FF;">在笔者看来，由于P5,P6,P7需要大量的数据作为支持，且均为Verilog语言，所以在P4学好自动化测试是十分有必要的，它可以免除你课上担心课下CPU有问题的后顾之忧，大大增加你PASS的几率。</p></p><p><p style="color: #00FF00;">而且，从P4开始，我们的自动化测试对拍对象不是小伙伴，完全可以是Mars，对我们的测试难度降低了很多，笔者在这里十分建议大家学一学自动化测试。</p><br>通过阅读本文，你可以了解到如何<del>蒟蒻</del>合理生成不会陷入死循环不会报错的指令，并了解到对Verilog进行自动化测试的相关方法。</p><h1 id="工具选择"><a href="#工具选择" class="headerlink" title="工具选择"></a>工具选择</h1><p>作者对于Verilog的学习全程采用ISE，<font color="red">（学会ISE是能做P8的基础）</font>所以我们这里介绍ISE的命令行操作。</p><h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><h2 id="MARS命令行"><a href="#MARS命令行" class="headerlink" title="MARS命令行"></a>MARS命令行</h2><h3 id="官方教程"><a href="#官方教程" class="headerlink" title="官方教程"></a>官方教程</h3><p><img src="MARS官方教程.png" alt="MARS官方教程"><br>对其他命令感兴趣的小伙伴可以去这里看看~ </p><h3 id="速通版本"><a href="#速通版本" class="headerlink" title="速通版本"></a>速通版本</h3><h4 id="工具准备"><a href="#工具准备" class="headerlink" title="工具准备"></a>工具准备</h4><p>来到P4,原有的MARS已经不能满足我们的要求，因此我们需要一个<font color="red">可以显示每一条指令对GRF和DM读写信息的MARS</font>，笔者在此为大家准备了一个:<a href="https://pan.baidu.com/s/1UCrD0v5SnoU5i_ptZ4B__A?pwd=jkvq">Mars_perfect</a>,提取码：jkvq,需要的uu可以自取。</p><h4 id="生成机器码"><a href="#生成机器码" class="headerlink" title="生成机器码"></a>生成机器码</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars_perfect.jar mc CompactDataAtZero a dump .text HexText code.txt nc test.asm</span><br></pre></td></tr></table></figure> <p>该命令行的意思是，<strong>运行Mars_perfect.jar将test.asm文件中.text部分指令转换为机器码输出到code.txt中（中间是参数，具体意思见官方教程）</strong><br>产生机器码，是为了提供给ISE的CPU使用。</p><h4 id="运行MARS生成标答"><a href="#运行MARS生成标答" class="headerlink" title="运行MARS生成标答"></a>运行MARS生成标答</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars_perfect.jar mc CompactDataAtZero nc test.asm &gt; mar.txt</span><br></pre></td></tr></table></figure>  <p>该命令行的意思是，<strong>运行Mars_perfect.jar将test.asm中每一条指令对GRF和DM的修改输出到mar.txt中</strong><br>便于和ISE产生的CPU信息对拍。</p><h4 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS"></a>TIPS</h4><p>以上运行时均需保证Cmd运行在Mars_perfect.jar和test.asm的根目录下</p><h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><p><img src="Mar输出文件.png" alt="MARS输出文件"></p><h2 id="ISE命令行"><a href="#ISE命令行" class="headerlink" title="ISE命令行"></a>ISE命令行</h2><h3 id="配置系统环境"><a href="#配置系统环境" class="headerlink" title="配置系统环境"></a>配置系统环境</h3><p>要顺利利用命令行运行ISE，我们需要首先配置系统环境,将ISE主题文件路径配置到系统变量中。<br>1、桌面—&gt;右击“我的电脑”—&gt;“属性”—&gt;切换至“高级系统设置”选项卡<br>2、进入环境变量对话框后，点击下面的“系统变量”的“新建”，添加下面环境变量：<br>变量名： XILINX<br>变量值：    安装Xilinx ISE的路径，如我的是：G:\\ISE\\14.7\\ISE_DS\\ISE</p><font size = 3><font color="green">当然，如果使用Python实现自动化，则无需配置，具体见后</font></font> <h3 id="准备生成可执行CPU文件"><a href="#准备生成可执行CPU文件" class="headerlink" title="准备生成可执行CPU文件"></a>准备生成可执行CPU文件</h3><p>要生成可供自动化测试执行的CPU文件，我们首先需要生成和顶层模块同名的.prj和.tcl文件:  </p><font color="purple">.prj是告诉命令行要编译哪些.v文件: </font><p><img src="prj文件内容.png" alt="prj文件内容">     </p><font color="green">.tcl是告诉命令行要让CPU运行多长时间。</font>    <p><img src="tcl文件内容.png" alt="tcl文件内容"><br>为了保证每次我们更新CPU后这些文件可以被及时更新，我们可以采用Python每次<strong>自动化生成</strong>.prj和.tcl文件：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file_list = []</span><br><span class="line"><span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(p_road):</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">        <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">            file_list.append(file)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">        prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + p_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">    tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">prj.close()</span><br><span class="line">tcl.close()</span><br></pre></td></tr></table></figure><br>这样，就算我们新增加了模块，每次测试时也会自动补上，而且，我们只需要改变Python种tun_time的值，就可以方便的改变CPU运行时间</p><h3 id="生成可执行CPU文件"><a href="#生成可执行CPU文件" class="headerlink" title="生成可执行CPU文件"></a>生成可执行CPU文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ISE本体路径 + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + CPU路径 + <span class="string">&quot;\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt&quot;</span></span><br><span class="line">举例： ISE本体路径：G:\\ISE\\<span class="number">14.7</span>\\ISE_DS\\ISE</span><br><span class="line">举例： CPU路径：C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\SingleCPU</span><br></pre></td></tr></table></figure>      <p>该命令行的意思是，<strong>利用ISE将CPU生成可执行文件，文件名为mips.exe。</strong>    </p><h3 id="运行可执行CPU文件"><a href="#运行可执行CPU文件" class="headerlink" title="运行可执行CPU文件"></a>运行可执行CPU文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mips.exe -nolog -tclbatch <span class="string">&quot; + CPU路径 + &quot;</span>\\mips.tcl&gt; raw_out.txt</span><br></pre></td></tr></table></figure> <p>该命令行的意思是，<strong>利用生成好的mips.exe结合mips.tcl里的运行时长进行运行，并将结果重定向输出到同目录下的raw_out.txt中</strong> </p><h3 id="结果展示-1"><a href="#结果展示-1" class="headerlink" title="结果展示"></a>结果展示</h3><p>至此，我们获得了一个这样的输出文件：<br><img src="输出文件.png" alt="输出文件"></p><h1 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h1><h2 id="优化结果"><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h2><p>对比以上两条输出结果，我们发现，ISE的输出会有一些烦人的前缀，导致文件比较失败。所以我们需要对其进行优化，利用Python处理文件将其前缀删去：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>: <span class="comment">#保留每个输出中@及后面的内容，实现输出提纯</span></span><br><span class="line">    j = j + <span class="number">1</span></span><br><span class="line">mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">    mymem = mymem + myfriendmem[i]</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file: <span class="comment">#将提纯后的结果输出到verilog.txt中</span></span><br><span class="line">    file.write(mymem)</span><br></pre></td></tr></table></figure><br>优化后，我们得到了和MARS标准输出一样形式的答案，便可以正常使用文件比较。</p><h2 id="无人值守测试"><a href="#无人值守测试" class="headerlink" title="无人值守测试"></a>无人值守测试</h2><p>在P3中我们实现的只是一个简单的自动化，点击一次运行，执行一次，比较一次，在P4我们做出革新，点击一次运行，输入执行次数，便可以一直执行，每一次的比较结果追加到result.txt中，只有“Accept”和“Wrong answer”，程序运行结束后可在该文件中查看哪次比较为“Wrong answer”,进而去进一步查看详细的比较文件，看看是第几个指令产生了不同。<br>以上的实现通过两个部分完成：</p><h3 id="diff模块获取详细比较文件"><a href="#diff模块获取详细比较文件" class="headerlink" title="diff模块获取详细比较文件"></a>diff模块获取详细比较文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compare_file(<span class="string">r&#x27;verilog.txt&#x27;</span>, <span class="string">r&#x27;mar.txt&#x27;</span>, <span class="string">&#x27;result&#x27;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_file</span>(<span class="params">file1, file2, out_file</span>):</span><br><span class="line">    file1_content = read_file(file1)</span><br><span class="line">    file2_content = read_file(file2)</span><br><span class="line">    d = difflib.HtmlDiff()</span><br><span class="line">    result = d.make_file(file1_content, file2_content)</span><br><span class="line">    fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    fb.write(result)</span><br></pre></td></tr></table></figure> <p><img src="详细比较.png" alt="详细比较">   </p><h3 id="手动编写比较方法，确定粗略比较信息"><a href="#手动编写比较方法，确定粗略比较信息" class="headerlink" title="手动编写比较方法，确定粗略比较信息"></a>手动编写比较方法，确定粗略比较信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">co.write(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mar.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> out_1:</span><br><span class="line">    out_std = out_1.readlines()</span><br><span class="line">    out_std.remove(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> out_2:</span><br><span class="line">    out_test = out_2.readlines()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.\\log.txt&quot;</span>.<span class="built_in">format</span>(test_order), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(out_std) &gt; <span class="built_in">len</span>(out_test):</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out_std)):</span><br><span class="line">            <span class="keyword">if</span> out_std[i] != out_test[i]:</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> flag:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Wrong Answer!&quot;</span>)</span><br><span class="line">        co.write(<span class="string">&quot;Wrong Answer!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Accepted!&quot;</span>)</span><br><span class="line">        co.write(<span class="string">&quot;Accepted!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">co.close()</span><br></pre></td></tr></table></figure> <p><img src="粗略比较.png" alt="粗略比较">   </p><h3 id="储存每次详细比较文件和ASM文件"><a href="#储存每次详细比较文件和ASM文件" class="headerlink" title="储存每次详细比较文件和ASM文件"></a>储存每次详细比较文件和ASM文件</h3><p>目的是便于出现错误答案时进行查找，复现问题：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dir_name_1 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\比较文件\\&#x27;</span></span><br><span class="line">fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">fb.write(result)</span><br><span class="line">dir_name = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\mars文件\\&#x27;</span></span><br><span class="line">f_2 = <span class="built_in">open</span>(dir_name + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.asm&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">f_2.writelines(list_temp)</span><br></pre></td></tr></table></figure> </p><h2 id="其余细节"><a href="#其余细节" class="headerlink" title="其余细节"></a>其余细节</h2><p><strong>python提供了os模块代替手动执行命令行，示例如下：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path <span class="comment">#自动配置系统变量（因此无需主动配置环境变量）</span></span><br><span class="line">os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + p_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt&quot;</span>)</span><br><span class="line">os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + p_road + <span class="string">&quot;\\mips.tcl&gt; raw_out.txt&quot;</span>)</span><br></pre></td></tr></table></figure> </p><h1 id="数据生成思路"><a href="#数据生成思路" class="headerlink" title="数据生成思路"></a>数据生成思路</h1><p>由于和P3的指令集相同，所以这里无需新的数据生成，利用P3即可。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><font color="red">至此，我们完成了Verilog的测试构建，该Python文件将支持我们P4-P7的测试，之后根据不同的Project在P4的测试上进行小修小补即可，所以，恭喜正式步入自动化测试的大门！</font><p><strong><font color="purple">这是一条很艰辛的道路，后续的数据构造将花费大量时间，但我也保证，这是计组成神之路！</font></strong>   </p><h1 id="Python自动化测试框架代码"><a href="#Python自动化测试框架代码" class="headerlink" title="Python自动化测试框架代码"></a>Python自动化测试框架代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> difflib</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> filestools</span><br><span class="line"><span class="keyword">from</span> filediff.diff <span class="keyword">import</span> file_diff_compare</span><br><span class="line">p_road = <span class="string">&quot;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\SingleCPU&quot;</span></span><br><span class="line">run_time = <span class="string">&quot;50us&quot;</span></span><br><span class="line">xilinx_path = <span class="string">&quot;G:\\ISE\\14.7\\ISE_DS\\ISE&quot;</span></span><br><span class="line">dir_name = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\mars文件\\&#x27;</span></span><br><span class="line">dir_name_1 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\比较文件\\&#x27;</span></span><br><span class="line">dir_name_2 = <span class="string">&#x27;C:\\Users\\Unicorn\\Desktop\\P4\\P4exp\\P4全自动测试\\测试记录\\&#x27;</span></span><br><span class="line">error = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">test_order</span>):</span><br><span class="line">    <span class="comment"># print(&quot;生成指令中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    command = <span class="string">&quot;C语言.exe&quot;</span></span><br><span class="line">    os.system(command)</span><br><span class="line">    f_1 = <span class="built_in">open</span>(<span class="string">&#x27;test.asm&#x27;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(dir_name + <span class="string">&#x27;test&#x27;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&#x27;.asm&#x27;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_mar</span>():</span><br><span class="line">    <span class="comment"># print(&quot;生成机器码中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars_perfect.jar mc CompactDataAtZero a dump .text HexText code.txt nc test.asm&quot;</span>)</span><br><span class="line">    <span class="comment"># print(&quot;生成标准答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    os.system(<span class="string">&quot;java -jar Mars_perfect.jar mc CompactDataAtZero nc test.asm &gt; mar.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_ise</span>():</span><br><span class="line">    <span class="comment"># print(&quot;运行ise中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    file_list = []</span><br><span class="line">    <span class="keyword">for</span> i, j, k <span class="keyword">in</span> os.walk(p_road):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> k:</span><br><span class="line">            <span class="keyword">if</span> file.endswith(<span class="string">&quot;.v&quot;</span>):</span><br><span class="line">                file_list.append(file)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\\mips.prj&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> prj:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list)):</span><br><span class="line">            prj.write(<span class="string">&quot;Verilog work \&quot;&quot;</span> + p_road + <span class="string">&quot;\\&quot;</span> + file_list[i] + <span class="string">&quot;\&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(p_road + <span class="string">&quot;\mips.tcl&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> tcl:</span><br><span class="line">        tcl.write(<span class="string">&quot;run &quot;</span> + run_time +<span class="string">&quot;;\nexit&quot;</span>)</span><br><span class="line">    prj.close()</span><br><span class="line">    tcl.close()</span><br><span class="line">    os.environ[<span class="string">&quot;XILINX&quot;</span>] = xilinx_path</span><br><span class="line">    os.system(xilinx_path + <span class="string">&quot;\\bin\\nt64\\fuse -nodebug -prj &quot;</span> + p_road + <span class="string">&quot;\\mips.prj -o mips.exe mips_tb &gt; compile_log.txt&quot;</span>)</span><br><span class="line">    os.system(<span class="string">&quot;mips.exe -nolog -tclbatch &quot;</span> + p_road + <span class="string">&quot;\\mips.tcl&gt; raw_out.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process</span>():</span><br><span class="line">    <span class="comment"># print(&quot;转换ise答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    myfriendmem = <span class="built_in">open</span>(<span class="string">&quot;raw_out.txt&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>).read()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> myfriendmem[j] != <span class="string">&#x27;@&#x27;</span>:</span><br><span class="line">        j = j + <span class="number">1</span></span><br><span class="line">    mymem = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(j, <span class="built_in">len</span>(myfriendmem)):</span><br><span class="line">        mymem = mymem + myfriendmem[i]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(mymem)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">copy_file</span>(<span class="params">name, target_road</span>):</span><br><span class="line">    f_1 = <span class="built_in">open</span>(name, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    list_temp = f_1.readlines()</span><br><span class="line">    f_2 = <span class="built_in">open</span>(target_road + <span class="string">&quot;\\&quot;</span> + name, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">    f_2.writelines(list_temp)</span><br><span class="line">    f_1.close()</span><br><span class="line">    f_2.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">file_cmp</span>(<span class="params">test_order</span>):</span><br><span class="line">    co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    co.write(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;第&quot;</span>+<span class="built_in">str</span>(test_order)+<span class="string">&quot;次比较结果:&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;mar.txt&quot;</span>, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> out_1:</span><br><span class="line">        out_std = out_1.readlines()</span><br><span class="line">        out_std.remove(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;verilog.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> out_2:</span><br><span class="line">        out_test = out_2.readlines()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.\\log.txt&quot;</span>.<span class="built_in">format</span>(test_order), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> log:</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(out_std) &gt; <span class="built_in">len</span>(out_test):</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out_std)):</span><br><span class="line">                <span class="keyword">if</span> out_std[i] != out_test[i]:</span><br><span class="line">                    flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Wrong Answer!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Wrong Answer!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Accepted!&quot;</span>)</span><br><span class="line">            co.write(<span class="string">&quot;Accepted!&quot;</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    co.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">return</span> f.readlines()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ERROR: 没有找到文件:%s或读取文件失败！&quot;</span> % filename)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare_file</span>(<span class="params">file1, file2, out_file</span>):</span><br><span class="line">    file1_content = read_file(file1)</span><br><span class="line">    file2_content = read_file(file2)</span><br><span class="line">    d = difflib.HtmlDiff()</span><br><span class="line">    result = d.make_file(file1_content, file2_content)</span><br><span class="line">    fb = <span class="built_in">open</span>(dir_name_1 + out_file, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    fb.write(result)</span><br><span class="line">    <span class="comment"># with open(dir_name + out_file, &#x27;w&#x27;) as f:</span></span><br><span class="line">    <span class="comment">#     f.writelines(result)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入测试次数:&quot;</span>)</span><br><span class="line">test_times =<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">co = <span class="built_in">open</span>(dir_name_2 + <span class="string">&#x27;result.txt&#x27;</span>, mode=<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">co.write(<span class="string">&quot;测试次数:&quot;</span>+<span class="built_in">str</span>(test_times)+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">co.close()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(test_times):</span><br><span class="line">    generate(i+<span class="number">1</span>)</span><br><span class="line">    run_mar()</span><br><span class="line">    run_ise()</span><br><span class="line">    process()</span><br><span class="line">    <span class="comment"># print(&quot;比较答案中&quot; + &#x27;\n&#x27;)</span></span><br><span class="line">    compare_file(<span class="string">r&#x27;verilog.txt&#x27;</span>, <span class="string">r&#x27;mar.txt&#x27;</span>, <span class="string">&#x27;result&#x27;</span>+<span class="built_in">str</span>(i+<span class="number">1</span>)+<span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">    file_cmp(i+<span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done!&quot;</span> + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure> <h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P4">https://github.com/ForeverYolo/2022-BUAA-CO/tree/main/P4</a></p><p><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P4课上强测！</font></strong></p><p><strong><font size = 5>P4数据生成器代码行数：304行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单周期CPU设计文档（Verilog）</title>
      <link href="/posts/33193/"/>
      <url>/posts/33193/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Verilog 单周期CPU设计文档</center></font></strong></p><h1 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h1><h2 id="（一）总体设计综述"><a href="#（一）总体设计综述" class="headerlink" title="（一）总体设计综述"></a>（一）总体设计综述</h2><h3 id="IFU"><a href="#IFU" class="headerlink" title="IFU"></a>IFU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">复位信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">当前指令</td></tr></tbody></table></div><p>（2）功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">取指令</td><td style="text-align:center">取出当前PC所对应的指令</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">更改PC值</td><td style="text-align:center">利用NPC更改PC值</td></tr></tbody></table></div><h3 id="GRF"><a href="#GRF" class="headerlink" title="GRF"></a>GRF</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">A2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">A3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">5位地址输入信号，指定32个寄存器中的一个，将其作为RD的写入地址</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位写入数据</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">RD1[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A1指定寄存器的32位数据</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RD2[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">A2指定寄存器的32位数据</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号，清零32个寄存器中的数据</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">同步复位</td><td style="text-align:center">时钟上升沿到来时，若RESET信号有效，则将32个寄存器中的数据全部清除</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A1与A2所存地址对应的寄存器的数据读出到RD1和RD2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD写入到A3所存地址对应的寄存器中</td></tr></tbody></table></div><h3 id="NPC"><a href="#NPC" class="headerlink" title="NPC"></a>NPC</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">NPCControl</td><td style="text-align:center">I</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Jump</td><td style="text-align:center">I</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Jreg</td><td style="text-align:center">I</td><td style="text-align:center">Jr 信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">J26imm[25:0]</td><td style="text-align:center">I</td><td style="text-align:center">跳转信号的26位立即数</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">B32imm[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">分支信号的扩展后的32位立即数</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">RegJump[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">Jr跳转地址</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">NPC[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">下一个PC值</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">PC4[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">PC+4的值</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">计算下一PC的值</td><td style="text-align:center">根据指令和当前PC值计算下一PC值</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">输出PC4</td><td style="text-align:center">为JR写入寄存器提供数据</td></tr></tbody></table></div><h3 id="EXT"><a href="#EXT" class="headerlink" title="EXT"></a>EXT</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">i16[15:0]</td><td style="text-align:center">I</td><td style="text-align:center">16位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">i32[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">经过扩展后的32位立即数</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">I</td><td style="text-align:center">选择扩展类型信号  0：符号扩展 1：无符号扩展</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">符号扩展</td><td style="text-align:center">将16位立即数符号扩展为32位立即数</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">无符号扩展</td><td style="text-align:center">将16位立即数无符号扩展为32位立即数</td></tr></tbody></table></div><h3 id="DM"><a href="#DM" class="headerlink" title="DM"></a>DM</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">A[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位地址输入</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">RD[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">32位数据输出</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">WD[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">32位数据输入</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">PC[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前PC值</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RESET</td><td style="text-align:center">I</td><td style="text-align:center">同步复位信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">CLK</td><td style="text-align:center">I</td><td style="text-align:center">时钟信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">WE</td><td style="text-align:center">I</td><td style="text-align:center">写使能信号</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">写入数据</td><td style="text-align:center">当WE有效且时钟上升沿到来时，将WD中的数据写入到A所存地址所对应的位置</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">读出数据</td><td style="text-align:center">将A所存地址对应位置的数据读出到RD</td></tr></tbody></table></div><h3 id="Control"><a href="#Control" class="headerlink" title="Control"></a>Control</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">Instr[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">当前指令</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">Bigger</td><td style="text-align:center">I</td><td style="text-align:center">ALU两个操作数是否相等信号</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ExtendSign</td><td style="text-align:center">O</td><td style="text-align:center">扩展类型信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Jump</td><td style="text-align:center">O</td><td style="text-align:center">跳转信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">RegWrite</td><td style="text-align:center">O</td><td style="text-align:center">寄存器写使能信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">MemWrite</td><td style="text-align:center">O</td><td style="text-align:center">DM写使能信号</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">MemToReg</td><td style="text-align:center">O</td><td style="text-align:center">Reg写入数据类型信号</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">RegDest</td><td style="text-align:center">O</td><td style="text-align:center">A3寄存器选择信号</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">ALUop</td><td style="text-align:center">O</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">Branch</td><td style="text-align:center">O</td><td style="text-align:center">分支信号</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">Jreg</td><td style="text-align:center">O</td><td style="text-align:center">Jr信号</td></tr></tbody></table></div><p>(2)真值表</p><div class="table-container"><table><thead><tr><th style="text-align:center">端口</th><th style="text-align:center">add</th><th style="text-align:center">sub</th><th style="text-align:center">ori</th><th style="text-align:center">lw</th><th style="text-align:center">sw</th><th style="text-align:center">lui</th><th style="text-align:center">beq</th><th style="text-align:center">Jal</th><th style="text-align:center">Jr</th></tr></thead><tbody><tr><td style="text-align:center">OP</td><td style="text-align:center">000000</td><td style="text-align:center">000000</td><td style="text-align:center">001101</td><td style="text-align:center">100011</td><td style="text-align:center">101011</td><td style="text-align:center">001111</td><td style="text-align:center">000100</td><td style="text-align:center">000011</td><td style="text-align:center">000000</td></tr><tr><td style="text-align:center">FC</td><td style="text-align:center">100000</td><td style="text-align:center">100010</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">x</td><td style="text-align:center">001000</td></tr><tr><td style="text-align:center">ALUop</td><td style="text-align:center">0000</td><td style="text-align:center">0001</td><td style="text-align:center">0011</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0100</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td><td style="text-align:center">0000</td></tr><tr><td style="text-align:center">Jump</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">RegWrite</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemWrite</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">MemToReg</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegDest</td><td style="text-align:center">01</td><td style="text-align:center">01</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">00</td><td style="text-align:center">10</td><td style="text-align:center">00</td></tr><tr><td style="text-align:center">RegSrc</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Branch</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">Jreg</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr></tbody></table></div><h3 id="ALU"><a href="#ALU" class="headerlink" title="ALU"></a>ALU</h3><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">SrcA[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SrcB[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">操作数2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ALUControl[3:0]</td><td style="text-align:center">I</td><td style="text-align:center">ALU功能选择信号</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">Bigger</td><td style="text-align:center">O</td><td style="text-align:center">两操作数是否相等信号</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">Res[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">运算结果</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">判断两个操作数是否相等</td><td style="text-align:center">相等则Bigger输出1否则为0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">加运算</td><td style="text-align:center">res=SrcA+SrcB</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">减运算</td><td style="text-align:center">res=SrcA-SrcB</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">与运算</td><td style="text-align:center">res=SrcA$SrcB</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">或运算</td><td style="text-align:center">res=SrcB</td><td>SrcB</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">加载高位运算</td><td style="text-align:center">res={SrcB[15:0],16’h0}</td></tr></tbody></table></div><h3 id="MUX"><a href="#MUX" class="headerlink" title="MUX"></a>MUX</h3><h4 id="Mux-4-5"><a href="#Mux-4-5" class="headerlink" title="Mux_4_5"></a>Mux_4_5</h4><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">data0[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">data1[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">data2[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">data3[4:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">sel[1:0]</td><td style="text-align:center">I</td><td style="text-align:center">选择信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">out[4:0]</td><td style="text-align:center">O</td><td style="text-align:center">输出</td></tr></tbody></table></div><h4 id="Mux-4-32"><a href="#Mux-4-32" class="headerlink" title="Mux_4_32"></a>Mux_4_32</h4><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">data0[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">data1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">data2[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据2</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">data3[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据3</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">sel[1:0]</td><td style="text-align:center">I</td><td style="text-align:center">选择信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">out[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">输出</td></tr></tbody></table></div><h4 id="Mux-2-32"><a href="#Mux-2-32" class="headerlink" title="Mux_2_32"></a>Mux_2_32</h4><p>（1）端口说明</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">信号名</th><th style="text-align:center">方向</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">data0[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据0</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">data1[31:0]</td><td style="text-align:center">I</td><td style="text-align:center">数据1</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">sel</td><td style="text-align:center">I</td><td style="text-align:center">选择信号</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">out[31:0]</td><td style="text-align:center">O</td><td style="text-align:center">输出</td></tr></tbody></table></div><p>(2)功能定义</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">功能</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">选择数据</td><td style="text-align:center">根据选择信号进行选择数据并输出</td></tr></tbody></table></div><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><p>(1)测试代码  </p><pre><code>ori $a0,$0,1999  ori $a1,$a0,111 lui $a2,12345lui $a3,0xffffnopori $a3,$a3,0xffffadd $s0,$a0,$a1 add $s1,$a3,$a3add $s2,$a3,$s0beq $s2,$s3,eeesub $s0,$a0,$s2 sub $s1,$a3,$a3eee:sub $s2,$a3,$a0sub $s3,$s2,$s1ori $t0,$0,0x0000sw $a0,0($t0)nopsw $a1,4($t0)sw $s0,8($t0)sw $s1,12($t0)sw $s2,16($t0)sw $s5,20($t0)lw $t1,20($t0)lw $t7,0($t0)lw $t6,20($t0)sw $t6,24($t0)lw $t5,12($t0)jal endori $t0,$t0,1ori $t1,$t1,1ori $t2,$t2,2beq $t0,$t2,eeelui $t3,1111jal outend:add $t0,$t0,$t7jr $raout:add $t0,$t0,$t3ori $t2,$t0,0beq $t0,$t2,qqqlui $v0,10qqq:lui $v0,11</code></pre><p>（2)MARS中运行结果<br><img src="MAR运行结果1.png" alt="MAR运行结果1"><br><img src="MARS运行结果2.png" alt="MAR运行结果2"><br>(3)该CPU运行输出结果</p><pre><code>@00003000: $ 4 &lt;= 000007cf@00003004: $ 5 &lt;= 000007ef@00003008: $ 6 &lt;= 30390000@0000300c: $ 7 &lt;= ffff0000@00003014: $ 7 &lt;= ffffffff@00003018: $16 &lt;= 00000fbe@0000301c: $17 &lt;= fffffffe@00003020: $18 &lt;= 00000fbd@00003028: $16 &lt;= fffff812@0000302c: $17 &lt;= 00000000@00003030: $18 &lt;= fffff830@00003034: $19 &lt;= fffff830@00003038: $ 8 &lt;= 00000000@0000303c: *00000000 &lt;= 000007cf@00003044: *00000004 &lt;= 000007ef@00003048: *00000008 &lt;= fffff812@0000304c: *0000000c &lt;= 00000000@00003050: *00000010 &lt;= fffff830@00003054: *00000014 &lt;= 00000000@00003058: $ 9 &lt;= 00000000@0000305c: $15 &lt;= 000007cf@00003060: $14 &lt;= 00000000@00003064: *00000018 &lt;= 00000000@00003068: $13 &lt;= 00000000@0000306c: $31 &lt;= 00003070@00003088: $ 8 &lt;= 000007cf@00003070: $ 8 &lt;= 000007cf@00003074: $ 9 &lt;= 00000001@00003078: $10 &lt;= 00000002@00003080: $11 &lt;= 04570000@00003084: $31 &lt;= 00003088@00003090: $ 8 &lt;= 045707cf@00003094: $10 &lt;= 045707cf@000030a0: $ 2 &lt;= 000b0000</code></pre><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="（1）阅读下面给出的-DM-的输入示例中（示例-DM-容量为-4KB，即-32bit-×-1024字），根据你的理解回答，这个-addr-信号又是从哪里来的？地址信号-addr-位数为什么是-11-2-而不是-9-0-？"><a href="#（1）阅读下面给出的-DM-的输入示例中（示例-DM-容量为-4KB，即-32bit-×-1024字），根据你的理解回答，这个-addr-信号又是从哪里来的？地址信号-addr-位数为什么是-11-2-而不是-9-0-？" class="headerlink" title="（1）阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？"></a>（1）阅读下面给出的 DM 的输入示例中（示例 DM 容量为 4KB，即 32bit × 1024字），根据你的理解回答，这个 addr 信号又是从哪里来的？地址信号 addr 位数为什么是 [11:2] 而不是 [9:0] ？</h3><p><img src="66.png" alt="66"><br>答：addr是从ALU的输出信号中经过位的截取而得到的，代表的是将要读取的DM的储存器的位置。<br>因为MIPS以字为单位，存储的时候也是以字为单位存储的（32位reg）,左移两位相当于除4，除4才可以得到我们需要的字，即我们需要的数据。  </p><h3 id="（2）思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。"><a href="#（2）思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。" class="headerlink" title="（2）思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。"></a>（2）思考上述两种控制器设计的译码方式，给出代码示例，并尝试对比各方式的优劣。</h3><p>答：<br><img src="控制信号对应指令.png" alt="1"><br><img src="指令对应控制信号.png" alt="2"><br>控制信号对应指令：哪种信号需要为哪些指令提供什么样的值一目了然<br>指令对于控制信号：哪种指令需要什么指令取什么值一目了然<br>这是两种看待控制信号和指令之间关系的角度。<br>前者代码较为简洁，后者代码则较为繁多。<br>前者不能很好的体现一条条指令的独立性，后者则可以很好体现一条条指令的独立性。  </p><h3 id="（3）在相应的部件中，复位信号的设计都是同步复位，这与-P3-中的设计要求不同。请对比同步复位与异步复位这两种方式的-reset-信号与-clk-信号优先级的关系。"><a href="#（3）在相应的部件中，复位信号的设计都是同步复位，这与-P3-中的设计要求不同。请对比同步复位与异步复位这两种方式的-reset-信号与-clk-信号优先级的关系。" class="headerlink" title="（3）在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。"></a>（3）在相应的部件中，复位信号的设计都是同步复位，这与 P3 中的设计要求不同。请对比同步复位与异步复位这两种方式的 reset 信号与 clk 信号优先级的关系。</h3><p>答：我们可以通过Verilog中实现它们的方式进行对比：<br><img src="复位.png" alt="123"><br>前者为异步复位，后者为同步复位。  </p><ul><li>可以看出来异步复位中clk和reset都为敏感信号，两者中任意一者发生变化都会导致always块的运行，clk和reset无相关关系，所以优先级相同。  </li><li>同步复位中只有clk为敏感信号，只有满足clk上升沿时，always块才会运行，这时才会考虑reset的值是否有效，所以clk和reset存在类似于主从关系的关系，优先级clk&gt;reset。</li></ul><h3 id="（4）C-语言是一种弱类型程序设计语言。C-语言中不对计算结果溢出进行处理，这意味着-C-语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持-C-语言，MIPS-指令的所有计算指令均可以忽略溢出。-请说明为什么在忽略溢出的前提下，addi-与-addiu-是等价的，add-与-addu-是等价的。提示：阅读《MIPS32®-Architecture-For-Programmers-Volume-II-The-MIPS32®-Instruction-Set》中相关指令的-Operation-部分。"><a href="#（4）C-语言是一种弱类型程序设计语言。C-语言中不对计算结果溢出进行处理，这意味着-C-语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持-C-语言，MIPS-指令的所有计算指令均可以忽略溢出。-请说明为什么在忽略溢出的前提下，addi-与-addiu-是等价的，add-与-addu-是等价的。提示：阅读《MIPS32®-Architecture-For-Programmers-Volume-II-The-MIPS32®-Instruction-Set》中相关指令的-Operation-部分。" class="headerlink" title="（4）C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。"></a>（4）C 语言是一种弱类型程序设计语言。C 语言中不对计算结果溢出进行处理，这意味着 C 语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持 C 语言，MIPS 指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi 与 addiu 是等价的，add 与 addu 是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的 Operation 部分。</h3><p>答：addi与addiu行为区别上的差异在于：出现溢出时，addiu忽略溢出，将溢出位<strong>舍弃</strong>，addi则会<strong>抛出错误</strong>SignalException(IntegerOverflow)，其余表现形式与addiu<strong>相同</strong>，故忽略溢出，则错误不抛出，此时两者便等价了。<br><strong><em>add与addu上述相同。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单周期CPU全自动测试思路（Logisim）</title>
      <link href="/posts/6588/"/>
      <url>/posts/6588/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对计组P3的自动化测试学习</font></strong>  </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>通过阅读本文，你可以了解到如何<del>蒟蒻</del>合理生成不会陷入死循环不会报错的指令，并了解到对logisim进行自动化测试的相关方法。</p><h1 id="全自动测试的开端：设施准备"><a href="#全自动测试的开端：设施准备" class="headerlink" title="全自动测试的开端：设施准备"></a>全自动测试的开端：设施准备</h1><p>要完成logisim的自动测试，需要使用到Logisim的命令行操作对输出进行重定向，所以我们需要.jar版的logisim来实现，该文件上网找找就有，我也已经上传至<a href="https://pan.baidu.com/s/1-ZFbWIHCk7tVUt5MWq8gWA?pwd=ozsw">百度网盘</a>，提取码：ozsw，需要的uu可以自取。</p><h1 id="命令行学习"><a href="#命令行学习" class="headerlink" title="命令行学习"></a>命令行学习</h1><p>logisim的命令行官方文档是有介绍的，感兴趣的可以去看看：<br><img src="https://s1.ax1x.com/2022/12/29/pSp8rin.png" alt="Logisim官方介绍"><br>这里我直接贴出有用的命令行，并对其做出解释，方便速通。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar logisim-generic-<span class="number">2</span>.<span class="number">7</span>.<span class="number">1</span>.jar CPU名称.circ -tty table &gt; 输出.txt</span><br></pre></td></tr></table></figure><br>这句话的意思是运行该.circ文件并将<strong>顶层模块的输出</strong>全部进行<strong>输出</strong>，注意是<strong>顶层模块</strong>，<strong>子模块</strong>不会输出任何结果！<br>意味着若你想得到你需要的数据，你就需要在主模块将其作为输出进行输出。<br>对于一个xxxx.asm程序，我们需要通过命令行运行mars使其输出机器码文件：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar Mars4_5.jar xxxx.asm nc mc CompactTextAtZero a dump .text HexText 机器码.txt</span><br></pre></td></tr></table></figure> </p><h1 id="对于cpu的额外设置"><a href="#对于cpu的额外设置" class="headerlink" title="对于cpu的额外设置"></a>对于cpu的额外设置</h1><p>有了上述指令，程序就可以运行了，并且我们可以在程序的同一目录下得到输出文件，但此时会出现新的问题，该cpu会一直运转，不会停止，这时候就需要对其提供halt指令（源自官方文档），当halt信号为1时，结束程序，可以如下实现：<br>为在顶层模块采用计数器设置计数最大值（你需要运行的周期），设置计数器为达到最大值保持，这时候进位输出端便会输出1，将其作为halt信号即可结束程序<br><img src="https://s1.ax1x.com/2022/12/29/pSp8yR0.png" alt="P3图片1"></p><font color="purple">官方介绍：</font><p><img src="https://s1.ax1x.com/2022/12/29/pSp82sU.png" alt="P3图片2"><br>好像这就是评测机的评测机制的一部分（思考）</p><font color="red">不用担心这里的halt信号也会作为输出不断输出，logisim会忽略halt信号的输出。</font><h1 id="机器码读入ROM"><a href="#机器码读入ROM" class="headerlink" title="机器码读入ROM"></a>机器码读入ROM</h1><p>Logisim官方文档也提供了读入的方法，但其实不是很直观，观察.circ文件中rom的表示方式，我们可以使用正则表达式对其匹配并强制替换：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr/data: <span class="number">10</span> <span class="number">32</span>([\s\S]*?)&lt;/a&gt;  <span class="comment">#正则表达式</span></span><br></pre></td></tr></table></figure><br>注意<font color="green">非贪婪匹配</font>，贪婪匹配会导致该正则表达式匹配到多余的内容，替换后使得文件损坏。<br><img src="https://s1.ax1x.com/2022/12/29/pSp8IiR.png" alt="P3图片3"></p><center>替换前</center>     <p><img src="https://s1.ax1x.com/2022/12/29/pSp8gMT.png" alt="P3图片4"></p><center>替换后</center><h1 id="python实现思路"><a href="#python实现思路" class="headerlink" title="python实现思路"></a>python实现思路</h1><p><strong>python提供了os模块代替手动执行命令行，示例如下：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.system(<span class="string">&quot;java -jar Mars4_5.jar test.asm nc mc CompactTextAtZero a dump .text HexText command.txt&quot;</span>)</span><br></pre></td></tr></table></figure><br><strong>python提供了re模块用于正则表达式匹配替换，示例如下：</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mymem = re.sub(<span class="string">r&#x27;addr/data: 10 32([\s\S]*?)&lt;/a&gt;&#x27;</span>, <span class="string">&quot;addr/data: 10 32\n&quot;</span> + content + <span class="string">&quot;&lt;/a&gt;&quot;</span>, mymem)</span><br></pre></td></tr></table></figure><br>执行完毕后得到的结果文件可以与同学对拍。<br><strong>而python也提供了filediff.diff模块用于文本差异比对，生成html文件，若有区别，则会标红，这里是由于文本一致所以无色。</strong><br><img src="https://s1.ax1x.com/2022/12/29/pSp84o9.png" alt="P3图片7"><br>（左右各为两个CPU输出结果） 有了这些我们就可以写出.py程序直接得到最终的比较结果 </p><h1 id="自动化数据生成思路"><a href="#自动化数据生成思路" class="headerlink" title="自动化数据生成思路"></a>自动化数据生成思路</h1><p><font color="purple">测试讲完了，但测试数据怎么来？这就需要我们自动化生成测试数据。 </font><br>可以选择c,c++,java,python生成，因为它们都支持命令行的重定向操作，最终用python指挥它们干活即可。     </p><h2 id="具体思路："><a href="#具体思路：" class="headerlink" title="具体思路："></a>具体思路：</h2><p>•开局先使用ori或lui给31个寄存器用随机数乱赋初值，确保后面的指令运行时不会拿0加来加去，导致没有测试意义。<br>•构造一个字符串数组，存指令名称，用随机数生成的数字确定本次随机的指令，然后分别实现各个指令的生成，对于寄存器和立即数选择随机生成。<br>•对于一般指令这样做完全够用，但beq和jal和jr则需要仔细考虑，不然会导致程序死循环或寻址到不合适的地方而报错。</p><p><font color="green">在此提供我的一些思路：</font><br>•以段生成代码，将jal固定出现在入口末尾，jr固定出现在出口末尾，确保jal和jr的跳转不会导致死循环<br>•对于beq的生成，其实有一个最简单粗暴的方式是beq往后跳转，这样不满足条件，指令也会往下执行，满足，也会往下执行，不会出现问题。当然如果一定要实现往前跳转，可以固定一段代码段，将其作为计数模块，当其执行超过一定次数时直接跳出此段代码。         </p><p><img src="https://s1.ax1x.com/2022/12/29/pSp8RLF.png" alt="P3图片8"><br><img src="https://s1.ax1x.com/2022/12/29/pSp8hdJ.png" alt="P3图片9"><br><img src="https://s1.ax1x.com/2022/12/29/pSp8fZ4.png" alt="P3图片10"><br>这部分做好后同样利用Python即可将其与上述测试程序链接自动生成代码自己对拍出结果，实现<strong>自动化测试</strong>。</p><h1 id="Python代码放送"><a href="#Python代码放送" class="headerlink" title="Python代码放送"></a>Python代码放送</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import difflib</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line">import filestools</span><br><span class="line">from filediff.diff import file_diff_compare</span><br><span class="line"># <span class="number">0</span>.自动化生成数据</span><br><span class="line"><span class="built_in">print</span>(&quot;生成指令中&quot;+&#x27;\n&#x27;)</span><br><span class="line">command = &quot;C语言.exe&quot;</span><br><span class="line">os.system(command)</span><br><span class="line"></span><br><span class="line"># <span class="number">1</span>.先运行Mars生成机器码</span><br><span class="line"><span class="built_in">print</span>(&quot;生成机器码中&quot;+&#x27;\n&#x27;)</span><br><span class="line">os.system(&quot;java -jar Mars4_5.jar test.asm nc mc CompactTextAtZero a dump .text HexText command.txt&quot;)</span><br><span class="line"></span><br><span class="line"># <span class="number">2</span>.运行写好的circ文件将里面的ROM值更改为上述输出的机器码</span><br><span class="line"><span class="built_in">print</span>(&quot;添加指令至单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">content = open(&quot;command.txt&quot;).read()</span><br><span class="line">mymem = open(&quot;单周期cpu.circ&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;).read()</span><br><span class="line">mymem = re.sub(r&#x27;addr/data: <span class="number">10</span> <span class="number">32</span>([\s\S]*?)&lt;/a&gt;&#x27;, &quot;addr/data: <span class="number">10</span> <span class="number">32</span>\n&quot; + content + &quot;&lt;/a&gt;&quot;, mymem)</span><br><span class="line">with open(&quot;单周期cpu镜像.circ&quot;, &quot;w&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;) as file:</span><br><span class="line">    file.write(mymem)</span><br><span class="line"><span class="built_in">print</span>(&quot;添加指令至另一个单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">myfriendmem = open(&quot;另一个单周期cpu.circ&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;).read()</span><br><span class="line">myfriendmem = re.sub(r&#x27;addr/data: <span class="number">10</span> <span class="number">32</span>([\s\S]*?)&lt;/a&gt;&#x27;, &quot;addr/data: <span class="number">10</span> <span class="number">32</span>\n&quot; + content + &quot;&lt;/a&gt;&quot;, myfriendmem)</span><br><span class="line">with open(&quot;另一个单周期cpu镜像.circ&quot;, &quot;w&quot;, encoding=&quot;utf-<span class="number">8</span>&quot;) as file:</span><br><span class="line">    file.write(myfriendmem)</span><br><span class="line"></span><br><span class="line"># <span class="number">3</span>.运行logisim输出结果</span><br><span class="line"><span class="built_in">print</span>(&quot;运行单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">command = &quot;java -jar logisim-generic-<span class="number">2</span>.<span class="number">7</span>.<span class="number">1</span>.jar 单周期cpu镜像.circ -tty table &gt; 单周期cpu结果.txt&quot;</span><br><span class="line">os.system(command)</span><br><span class="line"><span class="built_in">print</span>(&quot;运行另一个单周期cpu中&quot;+&#x27;\n&#x27;)</span><br><span class="line">command = &quot;java -jar logisim-generic-<span class="number">2</span>.<span class="number">7</span>.<span class="number">1</span>.jar 另一个单周期cpu镜像.circ -tty table &gt; 另一个单周期cpu结果.txt&quot;</span><br><span class="line">os.system(command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="number">4</span>.找人对拍</span><br><span class="line"><span class="built_in">print</span>(&quot;正在比较结果，时间可能较长，请耐心等待&quot;+&#x27;\n&#x27;)</span><br><span class="line">def read_file(filename):</span><br><span class="line"><span class="function">    try:</span></span><br><span class="line"><span class="function">        <span class="title">with</span> <span class="title">open</span>(<span class="title">filename</span>, &#x27;<span class="title">r</span>&#x27;) <span class="title">as</span> <span class="title">f</span>:</span></span><br><span class="line"><span class="function">            <span class="title">return</span> <span class="title">f.readlines</span>()</span></span><br><span class="line"><span class="function">    <span class="title">except</span> <span class="title">IOError</span>:</span></span><br><span class="line"><span class="function">        <span class="title">print</span>(&quot;<span class="title">ERROR</span>: 没有找到文件:%<span class="title">s</span>或读取文件失败！&quot; % <span class="title">filename</span>)</span></span><br><span class="line"><span class="function">        <span class="title">sys.exit</span>(1)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">def</span> <span class="title">compare_file</span>(<span class="title">file1</span>, <span class="title">file2</span>, <span class="title">out_file</span>):</span></span><br><span class="line"><span class="function">    <span class="title">file1_content</span> = <span class="title">read_file</span>(<span class="title">file1</span>)</span></span><br><span class="line"><span class="function">    <span class="title">file2_content</span> = <span class="title">read_file</span>(<span class="title">file2</span>)</span></span><br><span class="line"><span class="function">    <span class="title">d</span> = <span class="title">difflib.HtmlDiff</span>()</span></span><br><span class="line"><span class="function">    <span class="title">result</span> = <span class="title">d.make_file</span>(<span class="title">file1_content</span>, <span class="title">file2_content</span>)</span></span><br><span class="line"><span class="function">    <span class="title">with</span> <span class="title">open</span>(<span class="title">out_file</span>, &#x27;<span class="title">w</span>&#x27;) <span class="title">as</span> <span class="title">f</span>:</span></span><br><span class="line"><span class="function">        <span class="title">f.writelines</span>(<span class="title">result</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">compare_file</span>(<span class="title">r</span>&#x27;单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&#x27;, <span class="title">r</span>&#x27;另一个单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&#x27;, <span class="title">r</span>&#x27;<span class="title">result.html</span>&#x27;)</span></span><br><span class="line"><span class="function"><span class="title">file_diff_compare</span>(&quot;单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&quot;,&quot;另一个单周期<span class="title">cpu</span>结果.<span class="title">txt</span>&quot;)</span></span><br><span class="line"><span class="function"><span class="title">print</span>(&quot;比较结束，测试完毕，请查看结果&quot;+&#x27;\<span class="title">n</span>&#x27;)</span></span><br><span class="line"><span class="function">#5.到文件中查看结果</span></span><br></pre></td></tr></table></figure>  <h1 id="数据生成器"><a href="#数据生成器" class="headerlink" title="数据生成器"></a>数据生成器</h1><p>太长了所以放链接：<a href="https://github.com/ForeverYolo/2022-BUAA-CO/blob/main/P3">https://github.com/ForeverYolo/2022-BUAA-CO/blob/main/P3</a>  </p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>这篇文章是写于作者学习P3之时，回过头来还是觉得当时的自己略显稚嫩，所以笔者在这里起一个抛砖引玉的作用，希望对大家测试logisim有所启发！</p><p><strong><font size = 5>如果使用了本数据生成器，笔者亲测可以通过2022年P3课上强测！</font></strong></p><p><strong><font size = 5>P3数据生成器代码行数：304行</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单周期CPU设计文档（Logisim）</title>
      <link href="/posts/4286/"/>
      <url>/posts/4286/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5><center>Logisim 单周期CPU设计文档</center></font></strong></p><h1 id="CPU设计方案综述"><a href="#CPU设计方案综述" class="headerlink" title="CPU设计方案综述"></a>CPU设计方案综述</h1><p>（一）总体设计概述</p><p>使用Logisim设计开发一个初步的单周期CPU，总体概述如下：</p><ol><li>此CPU为32位CPU</li><li>此CPU为单周期</li><li>此CPU支持的指令集为：{add, sub, addu, subu, ori, lw, sw, beq, lui, nop, j}</li><li>nop的机器码为0x00000000</li><li>addu,subu不支持溢出</li></ol><p>（二）关键模块定义</p><p><strong>1．IFU</strong></p><p>(1) 端口说明</p><p>表 1-IFU端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLK</td><td>I</td><td>时钟信号</td></tr><tr><td>2</td><td>RESET</td><td>I</td><td>异步复位信号，将PC值置为0x00000000 0：无效 1：复位</td></tr><tr><td>3</td><td>PCN[31:0]</td><td>I</td><td>PC的下一个值</td></tr><tr><td>4</td><td>Instr[31:0]</td><td>O</td><td>输出IM中将要执行的指令</td></tr><tr><td>5</td><td>PC[31:0]</td><td>O</td><td>输出当前PC值</td></tr></tbody></table></div><p>(2) 功能定义</p><p>表 2-IFU功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>复位</td><td>当RESET有效时，将PC值置为0x00000000</td></tr><tr><td>2</td><td>更新PC值</td><td>PC\&lt;=NPC</td></tr><tr><td>3</td><td>输出指令</td><td>根据PC的值，取出IM中的指令</td></tr></tbody></table></div><p><strong>2．GRF</strong></p><p>(1) 端口说明</p><p>表 3-GRF端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLK</td><td>I</td><td>时钟信号</td></tr><tr><td>2</td><td>WE</td><td>I</td><td>写使能信号 0：不能向GRF写入数据 1：可向GRF写入数据</td></tr><tr><td>3</td><td>RESET</td><td>I</td><td>异步复位信号 1：将所有寄存器清零 0：无效</td></tr><tr><td>4</td><td>A1[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD1</td></tr><tr><td>5</td><td>A2[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将其中存储的数据读出到RD2</td></tr><tr><td>6</td><td>A3[4:0]</td><td>I</td><td>5位地址输入信号，指定32个寄存器中的一个，将WD的数据读入到该寄存器</td></tr><tr><td>7</td><td>WD[31:0]</td><td>I</td><td>32位写入到A3所指向寄存器的数据</td></tr><tr><td>8</td><td>RD1[31:0]</td><td>O</td><td>输出A1指定的寄存器的32位数据</td></tr><tr><td>9</td><td>RD1[31:0]</td><td>O</td><td>输出A2指定的寄存器的32位数据</td></tr></tbody></table></div><p>（2）功能定义</p><p>表 4-GRF功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>异步复位</td><td>当RESET的值有效时，将所有寄存器异步清零</td></tr><tr><td>2</td><td>写入数据</td><td>当WE为1且时钟上升沿来临时，将WD写入到A3对应的寄存器</td></tr><tr><td>3</td><td>读出数据</td><td>将A1和A2地址对应的寄存器的值分别通过RD1和RD2读出</td></tr></tbody></table></div><p><strong>3.DM</strong></p><p>（1）端口说明</p><p>表 5-DM端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>CLK</td><td>I</td><td>时钟信号</td></tr><tr><td>2</td><td>WE</td><td>I</td><td>写使能信号 0：不能向DM写入数据 1：可向DM写入数据</td></tr><tr><td>3</td><td>RESET</td><td>I</td><td>异步复位信号 0：无效 1：将DM清零</td></tr><tr><td>4</td><td>A[4:0]</td><td>I</td><td>5位读取或写入地址信号</td></tr><tr><td>5</td><td>WD[31:0]</td><td>I</td><td>32位写入数据</td></tr><tr><td>6</td><td>RD[31:0]</td><td>O</td><td>32位读出数据</td></tr></tbody></table></div><p>（2）功能定义</p><p>表 6-DM功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>异步复位</td><td>当RESET的值有效时，将DM清零</td></tr><tr><td>2</td><td>写入数据</td><td>当WE为1且时钟上升沿来临时，将WD写入A对应的地址中</td></tr><tr><td>3</td><td>读出数据</td><td>RD时刻读出A对应地址的值</td></tr></tbody></table></div><p><strong>4.ALU</strong></p><p>（1）端口说明</p><p>表 7-ALU端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>SrcA[31:0]</td><td>I</td><td>操作数1</td></tr><tr><td>2</td><td>SrcB[31:0]</td><td>I</td><td>操作数2</td></tr><tr><td>3</td><td>ALUControl[2:0]</td><td>I</td><td>决定ALU操作： 000：无符号加 001：无符号减 010：与 011：或 100：将SrcB左移10位</td></tr><tr><td>4</td><td>Bigger</td><td>O</td><td>SrcA与ScrB是否相等 0：不相等 1：相等</td></tr><tr><td>5</td><td>Res[31:0]</td><td>O</td><td>输出结果</td></tr></tbody></table></div><p>（2）功能定义</p><p>表 8-ALU功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>无符号加</td><td>Res=SrcA+SrcB</td></tr><tr><td>2</td><td>无符号减</td><td>Res=SrcA-SrcB</td></tr><tr><td>3</td><td>与</td><td>Res=SrcA&amp;SrcB</td></tr><tr><td>4</td><td>或</td><td>Res=SrcA\</td><td>SrcB</td></tr><tr><td>5</td><td>将SrcB左移10位</td><td>Res=SrcB\&lt;\&lt;10</td></tr></tbody></table></div><p><strong>5.NPC</strong></p><p>（1）端口说明</p><p>表 9-NPC端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>PC[31:0]</td><td>I</td><td>当前PC值</td></tr><tr><td>2</td><td>Jump</td><td>I</td><td>Jump选择信号 0：无效 1：指令是J</td></tr><tr><td>3</td><td>SignImm[31:0]</td><td>I</td><td>扩展后的32位信号</td></tr><tr><td>4</td><td>EPC[27:0]</td><td>I</td><td>扩展后的28位信号</td></tr><tr><td>5l</td><td>NPCControl</td><td>I</td><td>NPCControl选择信号 0：无效 1：指令是beq</td></tr><tr><td>6</td><td>PCN[31:0]</td><td>O</td><td>下一PC值</td></tr></tbody></table></div><p>（2）功能定义</p><p>表 10-NPC功能定义</p><div class="table-container"><table><thead><tr><th>序号</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>选择是否为J指令</td><td>0：无效 1：是J指令</td></tr><tr><td>2</td><td>选择是否为Beq指令</td><td>0：无效 1：为Beq指令</td></tr><tr><td>3</td><td>输出下一PC值</td><td>PCN为下一PC值</td></tr></tbody></table></div><p><strong>6.Control</strong></p><p>(1) 端口说明</p><p>表 11-Control端口说明</p><div class="table-container"><table><thead><tr><th>序号</th><th>信号名称</th><th>方向</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>Op[5:0]</td><td>I</td><td>Instr[31:26] 6位控制信号</td></tr><tr><td>2</td><td>FC[5:0]</td><td>I</td><td>Instr[0:5] 6位控制信号</td></tr><tr><td>3</td><td>ALUop[2:0]</td><td>O</td><td>ALU的控制信号</td></tr><tr><td>4</td><td>Jump</td><td>O</td><td>是否为J指令 0：不是 1：是</td></tr><tr><td>5</td><td>RegWrite</td><td>O</td><td>GRF的写入信号 0：禁止写入 1：允许写入</td></tr><tr><td>6</td><td>MemWrite</td><td>O</td><td>DM的写入信号 0：禁止写入 1：允许写入</td></tr><tr><td>7</td><td>MemToReg</td><td>O</td><td>选择写入REG的数据 0：ALU 1：DM</td></tr><tr><td>8</td><td>RegDest</td><td>O</td><td>选择A3的地址 0：Instr[20:16] 1：Instr[15:11]</td></tr><tr><td>9</td><td>RegSrc</td><td>O</td><td>选择SrcB数据来源 0：GRF 1：立即数</td></tr><tr><td>10</td><td>Branch</td><td>O</td><td>是否为Beq指令 0：不是 1：是</td></tr></tbody></table></div><p>（2）真值表</p><p>表 12-Control真值表</p><div class="table-container"><table><thead><tr><th>端口</th><th>addu</th><th>subu</th><th>ori</th><th>lw</th><th>sw</th><th>lui</th><th>beq</th><th>J</th></tr></thead><tbody><tr><td>Op</td><td>000000</td><td>000000</td><td>001101</td><td>100011</td><td>101011</td><td>001111</td><td>000100</td><td>000010</td></tr><tr><td>FC</td><td>100001</td><td>100011</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALUop</td><td>000</td><td>001</td><td>011</td><td>000</td><td>000</td><td>100</td><td>000</td><td>000</td></tr><tr><td>Jump</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>RegWrite</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>MemWrite</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>MemToReg</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>RegDest</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>RegSrc</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td></tr><tr><td>Branch</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td></tr></tbody></table></div><p>表 12-Control真值表（续）</p><div class="table-container"><table><thead><tr><th>端口</th><th>add</th><th>sub</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Op</td><td>000000</td><td>000000</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>FC</td><td>100000</td><td>100010</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>ALUop</td><td>000</td><td>001</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Jump</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegWrite</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MemWrite</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>MemToReg</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegDest</td><td>1</td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>RegSrc</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>Branch</td><td>0</td><td>0</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><h1 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h1><p>（1）测试代码</p><pre><code>ori $t1 , $t2 , 100addu(add) $t2 , $t1 , $t1subu(sub) $t3 , $t2 , $t1sw $t3 , 0($0)lw $t4 , 0($0)nopLabel:beq $t3 , $t2 , Label_Endaddu $t3 , $t3 , $t1j LabelLabel_End:</code></pre><p>（2）MARS中运行结果<br><img src="微信截图_20221017235123.png" alt=""><br><img src="微信截图_20221017235116.png" alt=""><br>（3）该CPU运行结果<br><img src="微信截图_20221018000817.png" alt=""><br><img src="微信截图_20221018000748.png" alt=""><br><img src="微信截图_20221018000803.png" alt=""></p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h3 id="（一）上面我们介绍了通过-FSM-理解单周期-CPU-的基本方法。请大家指出单周期-CPU-所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。"><a href="#（一）上面我们介绍了通过-FSM-理解单周期-CPU-的基本方法。请大家指出单周期-CPU-所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。" class="headerlink" title="（一）上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。"></a>（一）上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</h3><p>答：状态存储：DM,GRF</p><p>状态转移：IFU,NPC,EXT,ALU,Control</p><h3 id="（二）现在我们的模块中IM使用ROM，-DM使用RAM，-GRF使用Register，这种做法合理吗？-请给出分析，若有改进意见也请一并给出。"><a href="#（二）现在我们的模块中IM使用ROM，-DM使用RAM，-GRF使用Register，这种做法合理吗？-请给出分析，若有改进意见也请一并给出。" class="headerlink" title="（二）现在我们的模块中IM使用ROM， DM使用RAM， GRF使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。"></a>（二）现在我们的模块中IM使用ROM， DM使用RAM， GRF使用Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</h3><p>答：合理</p><p>IM是指令单元，指令在程序执行过程中不会再更改，也不应该被更改，也就是应只读，ROM就是只具有读取功能的存储器，满足要求</p><p>DM是存储单元，在程序的执行过程中需要不断地向DM中存入，读出数据，所以具有读入与读出的RAM满足要求</p><p>之所以DM不选择寄存器的原因是寄存器相比RAM是昂贵的，且DM需要存储大量数据，采用寄存器会导致成本成倍增长，得不偿失。</p><p>GRF为寄存器堆，自然选择32个寄存器去实现32个寄存器，符合要求与逻辑</p><p>没有改进意见</p><h3 id="（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。"><a href="#（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。" class="headerlink" title="（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。"></a>（三）在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</h3><p>答：是，设计了NPC模块，介绍：NPC模块是用于计算PC的下一值的集成式计算中心，它包容了Beq j等跳转指令的计算，使得对于PC下一值的处理整体而思路清晰。设计思路：首先NPC作为计算PC下一值的模块最基本的功能就是PC\&lt;=PC+4，这个是首要实现的功能，接着就是想办法实现BEQ,J等跳转指令的功能，结合BEQ和J等指令的机器码，将其有用的部分输入进NPC当中进行计算就可得到当前指令若为BEQ和J，它们的值分别为多少，但这里就涉及到了选择的问题，NPC如何知道提供给PC的下一值是PC+4,还是BEQ的跳转，还是J的跳转？因而就需引入多路选择器，并辅以控制选择信号（Conrtol部分生成）来选择PC的下一值，由于有3个选择，我这里采用了2个多路选择器，先二选一，再加入另一个再二选一，具体如图：<br><img src="1234.png" alt=""></p><h3 id="（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由"><a href="#（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由" class="headerlink" title="（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由"></a>（四）事实上，实现nop空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由</h3><p>答：nop为空指令，不会进行任何操作，仅仅占用一个指令而使得PC\&lt;=PC+4，所以不管加不加都不会影响它的效果</p><h3 id="（五）上文提到，MARS-不能导出-PC-与-DM-起始地址均为-0-的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。"><a href="#（五）上文提到，MARS-不能导出-PC-与-DM-起始地址均为-0-的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。" class="headerlink" title="（五）上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。"></a>（五）上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以避免手工修改的麻烦。请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。</h3><p>答：其实经过研究发现，在我目前所添加的指令中，PC所影响的指令就是J指令，因为J指令是直接跳转到地址，BEQ算的是偏移量，但为了修改方便，我还是针对PC进行了修改，而不是对J指令那一路进行修改，起始时首先PC应该复位为0x3000而且保证该周期正常取指，所以选择了多路选择器，在第一周期屏蔽PC的影响，直接取0位置处的地址（利用PC起始为0与0相等），在第二周期PC被成功赋值后再由PC决定取指，之后就简单了，每次PC的值作用于ROM时都先减去0x3000即可。实现如图：</p><p><img src="123.png" alt=""></p><h3 id="（六）阅读-Pre-的-“MIPS-指令集及汇编语言”-一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。"><a href="#（六）阅读-Pre-的-“MIPS-指令集及汇编语言”-一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。" class="headerlink" title="（六）阅读 Pre 的 “MIPS 指令集及汇编语言” 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。"></a>（六）阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</h3><p>答：测试样例反汇编为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">lui $t0, 0x1</span><br><span class="line">ori $t0, $t0, 0x2f6a</span><br><span class="line">ori $a0, $0, 0x4</span><br><span class="line">ori $a1, $0, 0x1</span><br><span class="line">ori $a2, $0, 0x4</span><br><span class="line">ori $a3, $0, 0x20</span><br><span class="line">sw $a3, 0x0($0)</span><br><span class="line">lw $t2, 0x0($0)</span><br><span class="line">sw $t0, 0x0($a0)</span><br><span class="line">subu $t1, $t0, $t2</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">addu $a0, $a0, $a2</span><br><span class="line">addu $a1, $a1, $a1</span><br><span class="line">sw $a1, 0x0($a0)</span><br><span class="line">beq $a3, $a1, label_1</span><br></pre></td></tr></table></figure><br>首先肯定的是所有的要求实现的指令至少都出现了一次进行了测试（虽然要实现的是add和sub这里是addu和subu，但是由设计要求可知在这里add和addu等价，subu和sub等价），且除了Beq以外都测试了多次，提升了检测出Bug的概率，强度还是有的，但放到Logisim跑了一遍和观察汇编指令发现，全程并无负数出现，也就是只测试了正数，且正数不大，数据覆盖范围比较窄，同时发现检测的寄存器是固定的几个，寄存器检测范围比较窄，对于beq则没有检测原地跳，向后跳，只是检测了向前跳。跳转范围检测比较窄。</p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态机实验秒杀——模板化做题</title>
      <link href="/posts/14039/"/>
      <url>/posts/14039/</url>
      
        <content type="html"><![CDATA[<p><strong><font size=5>这是一篇适用于P0,P1状态机的做题思路分享</font></strong>     </p><h1 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h1><p>在度过Pre通过的快乐或是不通过的悲伤之后，很快我们会迎来真正的考验，从P0开始一直到P1，我们将要面对的一个主要问题就是状态机，而状态机一般在P0中占据两题的位置，P1中占据三题的位置，所以我们可以说，状态机这一关过不去，<font color="red">我们的实验将止步于P0。</font><br>但是，在笔者看来，状态机反而是最为简单，最为模板化的一类题，一旦掌握，则成竹在胸，很难出现意外。今天我们就来聊一聊状态机的是是非非。<br>虽然笔者也极力反对这种刻板化做题的行为，但不得不说，对于状态机而言，<font color="green">一直用一直爽！</font>      </p><h1 id="状态机基础知识"><a href="#状态机基础知识" class="headerlink" title="状态机基础知识"></a>状态机基础知识</h1><h2 id="Moore型状态机"><a href="#Moore型状态机" class="headerlink" title="Moore型状态机"></a>Moore型状态机</h2><p>关键点：输出信号<font color="red">仅</font>与当前状态相关<br><img src="https://s1.ax1x.com/2022/12/29/pSp1QyD.png" alt="Moore型状态机"></p><h2 id="Mealy型状态机"><a href="#Mealy型状态机" class="headerlink" title="Mealy型状态机"></a>Mealy型状态机</h2><p>关键点：输出信号与当前状态<font color="red">及</font>输入信号有关<br><img src="https://s1.ax1x.com/2022/12/29/pSp13eH.png" alt="Mealy型状态机"><br><strong>没错，做题只需要知道这么多，两句话两个图！</strong></p><h1 id="做题模板"><a href="#做题模板" class="headerlink" title="做题模板"></a>做题模板</h1><h2 id="Logisim"><a href="#Logisim" class="headerlink" title="Logisim"></a>Logisim</h2><p><img src="https://s1.ax1x.com/2022/12/29/pSp1Lp6.png" alt="状态机示例1"><br><img src="https://s1.ax1x.com/2022/12/29/pSp39AA.png" alt="状态机示例2"><br>仔细观察笔者每一道题，细心的大家一定会发现，笔者的搭建完全按照状态机基础知识中的那两个图进行搭建，线多也只是因为笔者图方便，每一条线代表一位，而基础知识中的那几个图一条线代表很多位，经此而已，所以，搭建：<font color="purple">输入-状态转移模块-寄存器-输出模块-输出</font>的框架,这便是第一步。<br>第二步也很简单：根据题意分析出状态转移，直接使用Logisim分析电路，利用真值表建立两个模块，游戏结束。<br><img src="https://s1.ax1x.com/2022/12/29/pSp3yuD.png" alt="分析电路"><br>第三步就是考虑题目的特殊组合电路，即有些题目会不仅仅考虑状态机的事情，可能会有一些额外的输出，这些就是利用电路的组合即可解出，比如第一张图中的Hit输出（不属于状态机的内容）</p><h2 id="Verilog"><a href="#Verilog" class="headerlink" title="Verilog"></a>Verilog</h2><p><strong>如果说Logsim或许由于大家不熟悉这种手搓电路的形式感觉有一点点难度，那么Verilog作为一个用代码描述电路的语言，学了一年C语言的我们将会更加得心应手</strong><br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">`<span class="keyword">timescale</span> 1ns / 1ps</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S0 2&#x27;b00  </span><span class="comment">//宏定义状态便于后续描述</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S1 2&#x27;b01</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> S2 2&#x27;b10</span></span><br><span class="line"><span class="keyword">module</span> id_fsm(</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] char, <span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> out</span><br><span class="line">    );</span><br><span class="line"> <span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] status=<span class="number">2&#x27;b00</span>;  <span class="comment">//寄存器</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span>    <span class="comment">//输入和状态转移模块</span></span><br><span class="line"><span class="keyword">case</span> (status)</span><br><span class="line">`S0: <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d48</span> &amp;&amp; char &lt;= <span class="number">8&#x27;d57</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d65</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d90</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d97</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d122</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">`S1: <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d48</span> &amp;&amp; char &lt;= <span class="number">8&#x27;d57</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S2; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d65</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d90</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d97</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d122</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">`S2: <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d48</span> &amp;&amp; char &lt;= <span class="number">8&#x27;d57</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S2; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d65</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d90</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(char &gt;= <span class="number">8&#x27;d97</span> &amp;&amp; char &lt;=<span class="number">8&#x27;d122</span>) <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S1; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">status &lt;= `S0; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> out = (status==`S2)? <span class="number">1&#x27;b1</span>:<span class="number">1&#x27;b0</span>; <span class="comment">//输出模块和输出（Moore型）</span></span><br><span class="line"><span class="keyword">assign</span> out = (status==`S2 &amp;&amp; char == <span class="string">&quot;A&quot;</span>) <span class="comment">//输出模块和输出（Mealy型）</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><br>笔者做题感觉，在P1中对于Moore状态机的考察会比Mealy多一些，但在Verilog下这些都大差不差，都可以分解为<font color="purple">定义+always块+assign语句（输出）</font>。<br>定义：输入和状态寄存器。<br>always块：状态转移，无脑Switch+if else语句判断即可，在笔者看来比Logisim都简单。<br>assign:输出电路，根据不同状态机类型选择不一样的判断条件。<br><strong>若该题有特殊输出，则可考虑新建立信号，并继续用assign语句输出</strong>    </p><h1 id="练习方式"><a href="#练习方式" class="headerlink" title="练习方式"></a>练习方式</h1><p>当然，笔者这里所说可能对于刚入门的大家不太能理解，所以我们需要在练习中感受思路，这里提供一下当时笔者练习的方式。</p><h2 id="Logisim："><a href="#Logisim：" class="headerlink" title="Logisim："></a>Logisim：</h2><p>1.上机前一天将课下重做一遍，保持手感。<br>2.见前一篇文章，获取<a href="https://foreveryolo.github.io/2022/12/29/%E6%88%90%E7%86%9F%E7%9A%84%E5%AD%A9%E5%AD%90%E8%A6%81%E8%87%AA%E5%B7%B1%E6%89%BE%E9%A2%98%E5%81%9A%E2%80%94%E2%80%94%E8%8E%B7%E5%8F%96CSCORE%E7%99%BD%E9%87%91%E7%89%88/">白金版CSCore</a></p><h2 id="Verilog-1"><a href="#Verilog-1" class="headerlink" title="Verilog:"></a>Verilog:</h2><p>1.上机前一天将课下重做一遍，保持手感。<br>2.<a href="https://hdlbits.01xz.net/wiki/Main_Page">HDLBits</a>,这是一个Verilog练习网站，类似于大一的OJ，洛谷。学有余力可以做一做这里的题，可能会有小惊喜。   </p><p><font color="green">（笔者只在这里做了一道题，然而这道题就成为了笔者的P1上机第三题，真是世事难预料！）</font><br><img src="https://s1.ax1x.com/2022/12/29/pSp8iVJ.png" alt="HDLBits">  </p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P0 </tag>
            
            <tag> 北航计算机组成-P1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成熟的孩子要自己找题做——获取CSCore白金版</title>
      <link href="/posts/30831/"/>
      <url>/posts/30831/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对CSCore的Selenium学习</font></strong>  </p><h2 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h2><p>在北航，有这样一群人，他享有着别人所羡慕不来的东西——<font color=purple>白金版CSCore</font>,他可以查看自己的统计图，看到自己学习的时长与成果；他可以被计组邮箱推题，评测别人看不到的题。<br>我们至今未能得知白金版CSCore的来源，或许正如助教所说，这是未开发功能，只供部分人试用，又或许这是来自计组平台对于不好好做Pre的小可爱的一种Push,我们不得而知。<br>笔者很不幸运，便是普通版的一员，即使拿到了统计图的网址，点进去也会被骗到BiliBili的《never gonna give you up》。<br>然而我们是成年人了，要学会自己去获取资源，要有自己去拿到<font color=red>王者版CSCore</font>的决心与努力，因此，我们就要学习WEB自动化工具——<strong>Selenium</strong><br>当然，不学习也可以，它毕竟只是一个<strong>自动化软件</strong>，选择用勤劳的双手创造财富也可以，再不济，笔者也为大家提供了<a href="https://www.bilibili.com/video/av156766/">亡灵版CSCore</a>,点击直接使用即可~<br><img src="https://s1.ax1x.com/2022/12/29/pSSDc34.png" alt="白金版CSCore">         </p><h2 id="Selenium安装"><a href="#Selenium安装" class="headerlink" title="Selenium安装"></a>Selenium安装</h2><p>Selenium是Python的一个工具包，所以我们需要先有Python，这里笔者推荐在安装解释器时直接使用<a href="https://anaconda.org.cn/">Anaconda</a>,其为Python的集成包，集成了Python及Python主流的工具包（库）多达1500个，让你可以开始你的Python编程。<br>如果你安装了Anaconda，那么大概率Anaconda中是有Selenium的，直接使用即可。<br>如果你只是安装了Python,那么大概率你是没有Selenium的，这时候需要在控制台输入以下指令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure><p>如果报错，请检查Python安装的正确性。</p><h2 id="浏览器驱动安装"><a href="#浏览器驱动安装" class="headerlink" title="浏览器驱动安装"></a>浏览器驱动安装</h2><p>既然Selenium是WEB自动化工具，那么我们自然需要给浏览器安装驱动程序让Python可以驱动浏览器干活，这里针对<font color=green>不同</font>的<font color=blue>浏览器</font>我们要安装不同的驱动，针对<font color=green>不同</font>的<font color=blue>浏览器</font>版本也要选择安装不同的版本。<br><strong>Firefox浏览器驱动：</strong><a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a><br><strong>Chrome浏览器驱动：</strong><a href="https://sites.google.com/a/chromium.org/chromedriver/home">chromedriver</a><br><strong>Edge浏览器驱动：</strong><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">MicrosoftWebDriver</a><br>拿<strong>Microsoft Edge</strong>举例，点击设置中的关于Microsoft Edge，我们可以看到Microsoft Edge的版本号：<br><img src="https://s1.ax1x.com/2022/12/29/pSSsESe.png" alt="Edge版本号"><br>发现开头的是108，所以我们去官网选择开头为108的驱动进行下载，后面不一样问题不大。<br><img src="https://s1.ax1x.com/2022/12/29/pSSsVQH.png" alt="Edge驱动"> </p><h2 id="正式编写针对于CSCore的代码"><a href="#正式编写针对于CSCore的代码" class="headerlink" title="正式编写针对于CSCore的代码"></a>正式编写针对于CSCore的代码</h2><h3 id="CSCore网址分析"><a href="#CSCore网址分析" class="headerlink" title="CSCore网址分析"></a>CSCore网址分析</h3><p>以上面的那道题为例，我们贴出网址如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://cscore.buaa.edu.cn/#/problem?ProblemId=336&amp;PieId=896</span><br></pre></td></tr></table></figure><br>分析看出,如果用小区做例子的话，PieId就是居民楼，ProblemId就是每一住户，我们遍历搜索每一居民楼，每一住户，问问家里是否有人（题目），便可以得到所有的隐藏题目，直升<font color = red>王者版CSCore</font>,问题来了：<br>0.Selenium让我望而却步，我<strong>不能接受</strong>。<br>1.手动改网址需要1000x1000=10^6次，我们<strong>不能接受</strong>。<br>2.肉眼观察每一户是否有人住（有题），我们<strong>不能接受</strong>。</p><h3 id="针对CSCore编写Selenium"><a href="#针对CSCore编写Selenium" class="headerlink" title="针对CSCore编写Selenium"></a>针对CSCore编写Selenium</h3><h4 id="Solution-Zero"><a href="#Solution-Zero" class="headerlink" title="Solution Zero"></a>Solution Zero</h4><p><strong>万事开头难，其实Selenium归根结底只是Python的一个库函数，学会则极其简单。</strong><br>我们首先进行初步的设置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">edge_options = Options()</span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>) <span class="comment"># 使用无头模式</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>) <span class="comment"># 禁用GPU，防止无头模式出现莫名的BUG</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;window-size=1920x1080&#x27;</span>) <span class="comment">#设置为电脑显示分辨率大小</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--start-maximized&#x27;</span>) <span class="comment">#全屏展开浏览器</span></span><br><span class="line"><span class="comment">#以上都是对于Edge的设置，若用其他浏览器同理。</span></span><br><span class="line"><span class="comment"># 开启开发者模式</span></span><br><span class="line">edge_options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line"><span class="comment"># 禁用启用Blink运行时的功能</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line"><span class="comment"># 打开Edge</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;exercise.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">driver = webdriver.Edge(options=edge_options)</span><br><span class="line">driver.maximize_window()  <span class="comment"># 窗口最大化</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐式等待10s查询元素</span></span><br><span class="line"><span class="comment">#以上是操作Edge驱动的基本过程</span></span><br></pre></td></tr></table></figure><br><strong>强调：</strong> 无头模式运行时不会将浏览器显示出来，所以如果你想观看自动化过程，请注释掉使用无头模式这条语句。</p><h4 id="Solution-First"><a href="#Solution-First" class="headerlink" title="Solution First"></a>Solution First</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    web = <span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span></span><br><span class="line">    driver.get(<span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[1]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;xxx&quot;</span>)   <span class="comment"># 输入账号</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[2]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;XXXX&quot;</span>)  <span class="comment"># 输入密码</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&#x27;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[3]/button/span&#x27;</span>).click()</span><br></pre></td></tr></table></figure> <p>看不懂没关系，我们慢慢解释：<br>第一行是for循环标准语句，我们需要敲响1000户的们，所以范围是1000.<br>第二行是定义了个变量用来存放网址，用于后面搜到题我们往文档里写入网址。<br>第三行是Selenium功能，利用驱动打开该网址，中间str(i)对应户，我们遍历查找896号居民楼。<br>第四行到第十二行是一个特判：第一次进入CSCore,我们自然会需要登陆，这时候利用Selenium功能，捕捉元素(find_element)捕捉到登陆框，利用Selenium功能(send_keys)将“xxx”自动输入进去。之后利用Selenium功能，模拟点击(click)点击登陆，进入计组平台。之后便是<font color = blue>天高任鸟飞，海阔凭鱼跃了</font>。</p><p><font color = red>TIPS：</font>Selenium有很多定位元素的方法:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">find_element_by_id()</span><br><span class="line">find_element_by_name()</span><br><span class="line">find_element_by_class_name()</span><br><span class="line">find_element_by_tag_name()</span><br><span class="line">find_element_by_link_text()</span><br><span class="line">find_element_by_partial_link_text()</span><br><span class="line">find_element_by_xpath()</span><br><span class="line">find_element_by_css_selector()</span><br></pre></td></tr></table></figure><br>我们采用最简单准确度高的操作，Xpath定位，毕竟我们是来学计组的，够用就行。   </p><h5 id="Xpath定位法"><a href="#Xpath定位法" class="headerlink" title="Xpath定位法"></a>Xpath定位法</h5><p>打开浏览器，F12进入开发者模式，出现如图所示画面，选择元素。<br><img src="https://s1.ax1x.com/2022/12/29/pSShBhn.png" alt="XPath定位1"><br>之后我们将鼠标移到每一行上面，会发现该行元素作用的范围将会以蓝色显示出来。<br><img src="https://s1.ax1x.com/2022/12/29/pSS4iDS.png" alt="XPath定位2"><br>如图，右侧浅蓝色为我<font color = blue>鼠标停留位置</font>，左侧为定位到的<font color = blue>元素</font>，我们以CSCore的密码为例。<br>之后我们点击右键，按照下图所示复制出完整的XPath路径，<font color = red>一定要完整！否则定位大概率失效！</font><br><img src="https://s1.ax1x.com/2022/12/29/pSS4QDU.png" alt="XPath定位3">   </p><h4 id="Solution-Second"><a href="#Solution-Second" class="headerlink" title="Solution Second"></a>Solution Second</h4><p>之后我们解决第二个问题:自动判断，那么我们如何才能实现自动判断？道理也很简单，我们只需要找出没有搜到题和搜到题的不同点即可，搜到题，会出现题目，没有搜到题，则是空白界面，所以我们只需要定位一个题目任意的元素，每次判断该元素是否出现，即可实现这个功能，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    info = driver.find_element(By.XPATH, <span class="string">&#x27;/html/body/div/div[1]/div[1]/div/main/div/div/div/div[1]/h2&#x27;</span>).text</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> info:</span><br><span class="line">        f.write(web) <span class="comment">#找到就将Web里的网址写入文件中</span></span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>) <span class="comment">#换行</span></span><br></pre></td></tr></table></figure>  </p><p><font color = red>TIPS：</font><br>如果我们只想搜编程题，则考虑搜索编程题特有的提交题目那个框。<br>如果我们全都要，那么考虑搜索题目这个元素即可。          </p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><img src="https://s1.ax1x.com/2022/12/29/pSS4HGn.png" alt="结果展示"> </p><p>至此，我们完成了Selenium针对计组的学习，之后我们想实现其他的功能按照上面类似操作即可，不记得对应的语句就去百度一下。<br>如果你真的这样做了，那么恭喜你的P0-P2将一帆风顺，因为你做到了许许多多的往年考题，还有自动评测。<br><strong><font color = purple>恭喜获得王者版CSCore</font></strong>  </p><h2 id="完整源代码放送"><a href="#完整源代码放送" class="headerlink" title="完整源代码放送"></a>完整源代码放送</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="keyword">import</span> selenium</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.edge.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> Select</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">edge_options = Options()</span><br><span class="line"><span class="comment"># 使用无头模式</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line"><span class="comment"># 禁用GPU，防止无头模式出现莫名的BUG</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-gpu&#x27;</span>)</span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;window-size=1920x1080&#x27;</span>)</span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--start-maximized&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启开发者模式</span></span><br><span class="line">edge_options.add_experimental_option(<span class="string">&#x27;excludeSwitches&#x27;</span>, [<span class="string">&#x27;enable-automation&#x27;</span>])</span><br><span class="line"><span class="comment"># 禁用启用Blink运行时的功能</span></span><br><span class="line">edge_options.add_argument(<span class="string">&#x27;--disable-blink-features=AutomationControlled&#x27;</span>)</span><br><span class="line"><span class="comment"># 打开Edge</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;exercise.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">driver = webdriver.Edge(options=edge_options)</span><br><span class="line">driver.maximize_window()  <span class="comment"># 窗口最大化</span></span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 隐式等待10s查询元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">    web = <span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span></span><br><span class="line">    driver.get(<span class="string">&quot;http://cscore.buaa.edu.cn/#/problem?ProblemId=&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot;&amp;PieId=896&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[1]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;xxx&quot;</span>)   <span class="comment"># 输入账号</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&quot;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[1]/form/div[2]/div/div[1]/div[1]/input&quot;</span>).send_keys(</span><br><span class="line">            <span class="string">&quot;XXXX&quot;</span>)  <span class="comment"># 输入密码</span></span><br><span class="line">        driver.find_element(By.XPATH,</span><br><span class="line">                            <span class="string">&#x27;/html/body/div/div/div[1]/div/main/div/div[1]/div/div/div/div[3]/button/span&#x27;</span>).click()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        info = driver.find_element(By.XPATH, <span class="string">&#x27;/html/body/div/div[1]/div[1]/div/main/div/div/div/div[1]/h2&#x27;</span>).text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> info:</span><br><span class="line">            f.write(web)</span><br><span class="line">            f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Done&quot;</span>)</span><br></pre></td></tr></table></figure> ]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P0 </tag>
            
            <tag> 北航计算机组成-P1 </tag>
            
            <tag> 北航计算机组成-P2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>何为从代码看Logisim?</title>
      <link href="/posts/54231/"/>
      <url>/posts/54231/</url>
      
        <content type="html"><![CDATA[<p><strong><font size = 5>这是一篇针对Logisim的做题思路学习</font></strong>  </p><h1 id="何为从代码看Logisim"><a href="#何为从代码看Logisim" class="headerlink" title="何为从代码看Logisim?"></a>何为从代码看Logisim?</h1><p>• MIPS中对于递归可以直接翻译C代码，那么Logisim是否可以？这就是这个问题的来源：<br>• 从代码看Logisim，即类比程设思想解决logisim问题，那么如何类比？如何解决？我想引用组合电路一种类型题——投票类型问题对其做出解释，方便大家理解，并提供解决投票问题普通投票部分的一个可行思路。当然这里我只谈思路，不谈实现，小小的抛砖引玉一波，具体怎么应用就看大家了。 </p><h1 id="Example-1-补码解决投票问题"><a href="#Example-1-补码解决投票问题" class="headerlink" title="Example 1 补码解决投票问题"></a>Example 1 补码解决投票问题</h1><h2 id="题面及分析"><a href="#题面及分析" class="headerlink" title="题面及分析"></a>题面及分析</h2><p>这是一道考试真题，大概意思是说有几个人进行投票，统计票数，要求通过输出1，不通过则输出0，这其实是一类问题，因为有时候大家权重一样进行投票，有时候大家权重不一样进行投票（一票否决），这都是会可能出的题。<br>听起来很简单的样子，但实现上其实是有一定难度的。主要难度体现在对于如何判断是否通过的输出上。下面我们谈一谈我当初的解法：    </p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>•    在初看投票类型题前，如果用C的想法去解这种题该怎么解? 主体思路便是：同意为1，弃权为0，反对为-1. 加起来看是否大于0就可以了。那么既然C可以这样实现,C归根结底是在电路上运行的，那么为什么不可以尝试转化为logisim呢？<br>•    有了这样的想法，首先要解决的就是加法问题，借助一点对计算机知识的了解，我们知道计算机中加法是按补码运算的，那么我们加法器有了，我们只需解决补码部分就可以。<br>•    假设投票人数有7个，那么考虑到最多7人同意，7人反对，那么值的范围就在-7~7之间，所以我们可选用4位数字位+1位符号位来表示（大于5位都可 不溢出就行）,同意则为00001,弃权则为00000，反对则为11111。蛤？你补码忘记了？<font color=red>计组pre进制介绍解君愁（笑）</font><br>•    但其实logisim自带了补码器，不记得的话就去手动试试<br><img src="https://s1.ax1x.com/2022/12/28/pSSpAit.png" alt="何为从代码看Logisim-1"><br>•    加法问题解决~<br>•    最后我们只需要把每个人的数据相加即可，用比较器和0判断一下即可，切记别习惯性点成无符号了！<br><img src="https://s1.ax1x.com/2022/12/28/pSS9ClT.png" alt="何为从代码看Logisim-6">    </p><h1 id="Example-2-从C中if和Switch到logisim"><a href="#Example-2-从C中if和Switch到logisim" class="headerlink" title="Example 2 从C中if和Switch到logisim"></a>Example 2 从C中if和Switch到logisim</h1><p>•    写C最离不开的就是if语句，现在我们实现加法之后也遇到了一个问题，怎么判断输入的数据是同意，弃权，还是反对？这显然是一个switch语句，我们可以借助MUX实现:<br><img src="https://s1.ax1x.com/2022/12/28/pSSpFII.png" alt="何为从代码看Logisim-2"><br>•    if的实现：如图，比较器便是if的条件判断部分，比较器的结果作用于MUX使其实现if else 功能<br><img src="https://s1.ax1x.com/2022/12/28/pSSpidA.png" alt="何为从代码看Logisim-3"><br>•    体现在投票问题当中就是最后和零的判断部分：if(结果&gt;0)执行1 else执行0<br><img src="https://s1.ax1x.com/2022/12/28/pSSpPZd.png" alt="何为从代码看Logisim-4"><br>•    回到例子，现在判断的问题也已经解决，我们可以顺利的从输入当中得到我们想要的信息进行运算了！离主体实现只有一步之遥。  </p><h1 id="Example-3-从C中for到logisim"><a href="#Example-3-从C中for到logisim" class="headerlink" title="Example 3 从C中for到logisim"></a>Example 3 从C中for到logisim</h1><p>•    这一部分，理论上可以用计数器来实现，设置stay at value. 外加比较器相等时freeze(跳出循环）但考虑到其实logisim并没有很复杂的循环，建议果断选择Ctrl C + Ctrl V<br>•    于是经过对于n个投票人的Ctrl C和Ctrl V，以及前面的一系列工作，我们得到最终主体电路，放在C中 就是 Switch 和 C的加法运算 和 if的结合 （电路自行实现~)</p><h1 id="Example-4-从C中多条件判断到Logisim"><a href="#Example-4-从C中多条件判断到Logisim" class="headerlink" title="Example 4 从C中多条件判断到Logisim"></a>Example 4 从C中多条件判断到Logisim</h1><p>•    实际过程中，if往往有多个条件，那么如何解决这个问题？其实C已经给了答案&amp;或者|对应与门或者或门，这样我们也可以完成多条件判断了.<br><img src="https://s1.ax1x.com/2022/12/28/pSSpEJP.png" alt="何为从代码看Logisim-5"><br>•    Tips:对于特殊投票人的特判就是这样实现的~（提供一个思路，实现就交给大家自行完成了）      </p><h1 id="Example-5-其余C语句实现"><a href="#Example-5-其余C语句实现" class="headerlink" title="Example 5 其余C语句实现"></a>Example 5 其余C语句实现</h1><p>•    根据代码意思转换普通电路即可</p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>•    到现在为止，C语言有的语法我们都可以借助Logisim实现，那么对于一道组合逻辑题若是实在没有思路，我们可以思考怎么用C怎么实现，进而一步步转化为Logisim电路。此法名为：翻译 （默念翻译大法好） </p><h1 id="True-END"><a href="#True-END" class="headerlink" title="True END"></a>True END</h1>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成-P0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在北航计算机组成总结的开头语</title>
      <link href="/posts/28817/"/>
      <url>/posts/28817/</url>
      
        <content type="html"><![CDATA[<font size=5>弹剑作歌奏苦声，曳裾王门不称情</font>  <h1 id="获得"><a href="#获得" class="headerlink" title="获得"></a>获得</h1><p>通过阅读本博客，你可以获得：<br>• 北航计算机组成从Pre到P8的一些经验与思考<br>• 北航计算机组成一些往年题题面及class文件（侵删）<br>• 北航计算机组成实用的Mars等工具<br>• 北航计算机组成从P3到P7的自动化测试思路分享<br>• 北航计算机组成从P3到P7的所有全自动强度较高的测试化程序<br>• 北航计算机组成从P3到P8的设计文档<br>• 北航计算机组成对笔者帮助很大的学长学姐博客传送门  </p><h1 id="行文思路"><a href="#行文思路" class="headerlink" title="行文思路"></a>行文思路</h1><p>笔者希望写一些有启发性，有独特性，有更深意义的计组学习文章，所以在笔者的博客中，你将不止看到往年题，更多的可能是一些技术性，思考性的文章，也是为了避免博客的同质化。再次先谢过大家的捧场了Orz</p><h1 id="计组实验内容"><a href="#计组实验内容" class="headerlink" title="计组实验内容"></a>计组实验内容</h1><p><strong>• Pre:</strong><br>课下内容：学习Logisim,Verilog,MIPS<br>课上内容：5-10道选择/填空题+3道编程题（Logisim,Verilog,MIPS各一道）<br>要求：3道编程题全部通过<br><strong>• P0：</strong><br>课下内容：学习Logisim状态机写法并进一步加深Logisim的学习<br>课上内容：3道Logisim编程题<br>要求：3过2<br><strong>• P1：</strong><br>课下内容：学习Verilog状态机写法并进一步加深Verilog的学习<br>课上内容：3道Verilog编程题<br>要求：3过2<br><strong>• P2：</strong><br>课下内容：学习MIPS语言<br>课上内容：3道MIPS编程题<br>要求：3过2<br><strong>• P3：</strong><br>课下内容：利用Logisim搭建单周期CPU,并添加一些基础指令。<br>课上内容：对课下所做的Logisim单周期CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong>• P4：</strong><br>课下内容：利用Verilog搭建单周期CPU,并添加一些基础指令。<br>课上内容：对课下所做的Verilog单周期CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong><font color="red">• P5：</font></strong><br>课下内容：利用Verilog搭建流水线CPU，并添加一些基础指令。<br>课上内容：对课下所做的Verilog五级流水线CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong>• P6：</strong><br>课下内容：利用Verilog对P5搭建的流水线CPU进行迭代开发，使其拥有乘除槽并添加更多指令。<br>课上内容：对课下所做的Verilog五级流水线CPU添加指令并顺带强测，一共三个指令<br>要求：3过2<br><strong>• P7：</strong><br>课下内容：利用Verilog对P6搭建的流水线CPU进行迭代开发，使其具备异常处理功能。<br>课上内容：强测CPU正确性，强测CPU异常处理，强测CPU中断处理，添加新异常/中断处理规则<br>要求：CPU正确性必须通过，其余3过2<br><strong><font color="red">• P8：</font></strong><br>课下内容：利用Verilog对P7搭建的流水线CPU进行迭代开发，使其成为MIPS微处理器，并进行板级验证<br>课上内容：编写MIPS程序，使得该MIPS微处理器实现新功能<br>要求：根据完成度给分</p><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>这一系列开始于笔者学完计算机组成的寒假时光，在这一学期的学习中，<font color="blue">笔者受益于助教团队们的耐心解答</font>，<font color="green">受益于计算机组成课程平台的严谨教程</font>，<font color="red">受益于各大学长学姐的博客帮助</font>，一路走来，从初学者变为学者，再到如今成为了过来人，<del>即将接受新一轮OO OS摧残的初学者</del>，笔者深感计组学习之不易，也因此想贡献自己的一份力量，这促成了这篇博客的产生。         </p><p>然，笔者已经尽量在学期中收集计算机组成实验的各种材料，可笔者真正坐在电脑前，开始写这一系列时也感受到了记忆的大量缺失，所以期望大家带有审慎的态度去观看笔者的每一篇博客，谢谢！      </p><p>作为过来人的笔者，教学谈不上，指导更谈不上，在此也就只是起一个抛砖引玉的作用，期盼大家在计算机组成上的优异表现！<br><img src="https://s1.ax1x.com/2022/12/28/pSS1kuQ.png" alt="通关图"><br><img src="https://s1.ax1x.com/2022/12/28/pSS1ABj.png" alt="AK图"><br><img src="https://s1.ax1x.com/2022/12/30/pSpDyWD.png" alt="计组文件大小"></p><center><font size=4>主要是生成的测试数据太多了Orz</font></center>      <p><strong><font color="purple">善始善终，Pre-P8无一次不通过记录，给自己留个纪念~非常感谢助教们的帮助Orz</font></strong>  </p>]]></content>
      
      
      <categories>
          
          <category> 北航计算机组成 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 北航计算机组成杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>archives</title>
      <link href="/archives/index.html"/>
      <url>/archives/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>书籍</title>
      <link href="/books/index.html"/>
      <url>/books/index.html</url>
      
        <content type="html"><![CDATA[<div class="fj-gallery"><p><img src="https://s1.ax1x.com/2023/01/28/pSanJat.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSaurlD.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSauyOH.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSanoZR.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSanOzD.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSaupdI.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSauQYV.jpg" alt=""><br><img src="https://s1.ax1x.com/2023/01/28/pSaulWT.png" alt=""></p>          </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>2021-2025 北航<br>感恩每一次相遇！</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=780 height=900 src="//music.163.com/outchain/player?type=0&id=8106272779&auto=1&height=430"></iframe>]]></content>
      
    </entry>
    
    
  
</search>
